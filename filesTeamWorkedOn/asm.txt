
bootimg:     file format elf32-i386

Disassembly of section .text:

00400000 <_start-0xc>:
  400000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
  400006:	00 00                	add    %al,(%eax)
  400008:	fb                   	sti    
  400009:	4f                   	dec    %edi
  40000a:	52                   	push   %edx
  40000b:	e4 fa                	in     $0xfa,%al

0040000c <_start>:
.align 4
start:
_start:
	# Make sure interrupts are off
	cli
  40000c:	fa                   	cli    
	jmp     continue
  40000d:	eb 00                	jmp    40000f <continue>

0040000f <continue>:

continue:

	# Load the GDT
.load_gdt:
	lgdt gdt_desc_ptr
  40000f:	0f 01 15 fc 01 40 00 	lgdtl  0x4001fc

	# Load CS with the new descriptor value
	ljmp    $KERNEL_CS, $keep_going
  400016:	ea 1d 00 40 00 10 00 	ljmp   $0x10,$0x40001d

0040001d <keep_going>:

keep_going:
	# Set up ESP so we can have an initial stack
	movl    $0x800000, %esp
  40001d:	bc 00 00 80 00       	mov    $0x800000,%esp

	# Set up the rest of the segment selector registers
	movw    $KERNEL_DS, %cx
  400022:	66 b9 18 00          	mov    $0x18,%cx
	movw    %cx, %ss
  400026:	8e d1                	movl   %ecx,%ss
	movw    %cx, %ds
  400028:	8e d9                	movl   %ecx,%ds
	movw    %cx, %es
  40002a:	8e c1                	movl   %ecx,%es
	movw    %cx, %fs
  40002c:	8e e1                	movl   %ecx,%fs
	movw    %cx, %gs
  40002e:	8e e9                	movl   %ecx,%gs

	# Push the parameters that entry() expects (see kernel.c):
	# eax = multiboot magic
	# ebx = address of multiboot info struct
	pushl   %ebx
  400030:	53                   	push   %ebx
	pushl   %eax
  400031:	50                   	push   %eax

	# Jump to the C entrypoint to the kernel.
	call    entry
  400032:	e8 0d 16 00 00       	call   401644 <entry>

00400037 <halt>:

	# We'll never get back here, but we put in a hlt anyway.
halt:
	hlt
  400037:	f4                   	hlt    
	jmp     halt
  400038:	eb fd                	jmp    400037 <halt>
  40003a:	90                   	nop    
  40003b:	90                   	nop    

0040003c <exception_print0>:
.globl rtc_handler_wrapper
.globl keyboard_handler_wrapper

exception_print0:
	movl $0, %eax
  40003c:	b8 00 00 00 00       	mov    $0x0,%eax
	jmp exception_print_handler
  400041:	e9 be 00 00 00       	jmp    400104 <exception_print_handler>

00400046 <exception_print1>:

exception_print1:
	movl $1, %eax
  400046:	b8 01 00 00 00       	mov    $0x1,%eax
	jmp exception_print_handler
  40004b:	e9 b4 00 00 00       	jmp    400104 <exception_print_handler>

00400050 <exception_print2>:

exception_print2:
	movl $2, %eax
  400050:	b8 02 00 00 00       	mov    $0x2,%eax
	jmp exception_print_handler
  400055:	e9 aa 00 00 00       	jmp    400104 <exception_print_handler>

0040005a <exception_print3>:

exception_print3:
	movl $3, %eax
  40005a:	b8 03 00 00 00       	mov    $0x3,%eax
	jmp exception_print_handler
  40005f:	e9 a0 00 00 00       	jmp    400104 <exception_print_handler>

00400064 <exception_print4>:

exception_print4:
	movl $4, %eax
  400064:	b8 04 00 00 00       	mov    $0x4,%eax
	jmp exception_print_handler
  400069:	e9 96 00 00 00       	jmp    400104 <exception_print_handler>

0040006e <exception_print5>:

exception_print5:
	movl $5, %eax
  40006e:	b8 05 00 00 00       	mov    $0x5,%eax
	jmp exception_print_handler
  400073:	e9 8c 00 00 00       	jmp    400104 <exception_print_handler>

00400078 <exception_print6>:

exception_print6:
	movl $6, %eax
  400078:	b8 06 00 00 00       	mov    $0x6,%eax
	jmp exception_print_handler
  40007d:	e9 82 00 00 00       	jmp    400104 <exception_print_handler>

00400082 <exception_print7>:

exception_print7:
	movl $7, %eax
  400082:	b8 07 00 00 00       	mov    $0x7,%eax
	jmp exception_print_handler
  400087:	e9 78 00 00 00       	jmp    400104 <exception_print_handler>

0040008c <exception_print8>:

exception_print8:
	movl $8, %eax
  40008c:	b8 08 00 00 00       	mov    $0x8,%eax
	jmp exception_print_handler
  400091:	e9 6e 00 00 00       	jmp    400104 <exception_print_handler>

00400096 <exception_print9>:

exception_print9:
	movl $9, %eax
  400096:	b8 09 00 00 00       	mov    $0x9,%eax
	jmp exception_print_handler
  40009b:	e9 64 00 00 00       	jmp    400104 <exception_print_handler>

004000a0 <exception_print10>:

exception_print10:
	movl $10, %eax
  4000a0:	b8 0a 00 00 00       	mov    $0xa,%eax
	jmp exception_print_handler
  4000a5:	e9 5a 00 00 00       	jmp    400104 <exception_print_handler>

004000aa <exception_print11>:

exception_print11:
	movl $11, %eax
  4000aa:	b8 0b 00 00 00       	mov    $0xb,%eax
	jmp exception_print_handler
  4000af:	e9 50 00 00 00       	jmp    400104 <exception_print_handler>

004000b4 <exception_print12>:

exception_print12:
	movl $12, %eax
  4000b4:	b8 0c 00 00 00       	mov    $0xc,%eax
	jmp exception_print_handler
  4000b9:	e9 46 00 00 00       	jmp    400104 <exception_print_handler>

004000be <exception_print13>:

exception_print13:
	movl $13, %eax
  4000be:	b8 0d 00 00 00       	mov    $0xd,%eax
	jmp exception_print_handler
  4000c3:	e9 3c 00 00 00       	jmp    400104 <exception_print_handler>

004000c8 <exception_print14>:

exception_print14:
	movl $14, %eax
  4000c8:	b8 0e 00 00 00       	mov    $0xe,%eax
	jmp exception_print_handler
  4000cd:	e9 32 00 00 00       	jmp    400104 <exception_print_handler>

004000d2 <exception_print16>:

exception_print16:
	movl $16, %eax
  4000d2:	b8 10 00 00 00       	mov    $0x10,%eax
	jmp exception_print_handler
  4000d7:	e9 28 00 00 00       	jmp    400104 <exception_print_handler>

004000dc <exception_print17>:

exception_print17:
	movl $17, %eax
  4000dc:	b8 11 00 00 00       	mov    $0x11,%eax
	jmp exception_print_handler
  4000e1:	e9 1e 00 00 00       	jmp    400104 <exception_print_handler>

004000e6 <exception_print18>:

exception_print18:
	movl $18, %eax
  4000e6:	b8 12 00 00 00       	mov    $0x12,%eax
	jmp exception_print_handler
  4000eb:	e9 14 00 00 00       	jmp    400104 <exception_print_handler>

004000f0 <exception_print19>:

exception_print19:
	movl $19, %eax
  4000f0:	b8 13 00 00 00       	mov    $0x13,%eax
	jmp exception_print_handler
  4000f5:	e9 0a 00 00 00       	jmp    400104 <exception_print_handler>

004000fa <exception_print_general>:

exception_print_general:
	movl $20, %eax
  4000fa:	b8 14 00 00 00       	mov    $0x14,%eax
	jmp exception_print_handler
  4000ff:	e9 00 00 00 00       	jmp    400104 <exception_print_handler>

00400104 <exception_print_handler>:

exception_print_handler:
	pushl %eax
  400104:	50                   	push   %eax
	call print_exceptions
  400105:	e8 93 30 00 00       	call   40319d <print_exceptions>

0040010a <spin>:

	# spin indefinitely
spin:
	hlt
  40010a:	f4                   	hlt    
	jmp spin
  40010b:	eb fd                	jmp    40010a <spin>

0040010d <rtc_handler_wrapper>:

rtc_handler_wrapper:
	cli
  40010d:	fa                   	cli    
	pusha
  40010e:	60                   	pusha  
	call rtc_handler
  40010f:	e8 76 33 00 00       	call   40348a <rtc_handler>
	popa
  400114:	61                   	popa   
	sti
  400115:	fb                   	sti    
	iret
  400116:	cf                   	iret   

00400117 <keyboard_handler_wrapper>:

keyboard_handler_wrapper:
	cli
  400117:	fa                   	cli    
	pusha
  400118:	60                   	pusha  
	call keyboard_handler
  400119:	e8 0e 21 00 00       	call   40222c <keyboard_handler>
	popa
  40011e:	61                   	popa   
	sti
  40011f:	fb                   	sti    
	iret
  400120:	cf                   	iret   

00400121 <syscall_handler>:

syscall_handler:
	# save syscall number to the stack, see piazza @1187
	pushl %eax
  400121:	50                   	push   %eax
	pusha
  400122:	60                   	pusha  

	# check if the syscall number is valid, 1 <= eax <= 10
	cmpl $1, %eax
  400123:	83 f8 01             	cmp    $0x1,%eax
	jl syscall_exit
  400126:	7c 0e                	jl     400136 <syscall_exit>
	cmpl $10, %eax
  400128:	83 f8 0a             	cmp    $0xa,%eax
	jg syscall_exit
  40012b:	7f 09                	jg     400136 <syscall_exit>

	# use eax as an index into syscall_table, so 0-9 instead of 1-10
	decl %eax
  40012d:	48                   	dec    %eax
	movl $syscall_table, %edi
  40012e:	bf 17 50 40 00       	mov    $0x405017,%edi
	call *(%edi, %eax, 4)
  400133:	ff 14 87             	call   *(%edi,%eax,4)

00400136 <syscall_exit>:

syscall_exit:
	# print syscall number
	pushl %eax
  400136:	50                   	push   %eax
	pushl $syscall_string
  400137:	68 00 50 40 00       	push   $0x405000
	call printf
  40013c:	e8 6c 29 00 00       	call   402aad <printf>
	addl $8, %esp
  400141:	83 c4 08             	add    $0x8,%esp

	popa
  400144:	61                   	popa   
	iret
  400145:	cf                   	iret   
  400146:	90                   	nop    
  400147:	90                   	nop    

00400148 <load_CR3>:
*	Function: Puts the page directory pointer into CR3
*/
load_CR3:
		//set up stack frame
		  push %ebp
  400148:	55                   	push   %ebp
		  mov %esp, %ebp
  400149:	89 e5                	mov    %esp,%ebp

		  //load parameter(address of pde) and put it in crs

		  mov 8(%ebp), %ecx
  40014b:	8b 4d 08             	mov    0x8(%ebp),%ecx
		  mov %ecx, %cr3
  40014e:	0f 22 d9             	mov    %ecx,%cr3
		 leave
  400151:	c9                   	leave  
		  ret
  400152:	c3                   	ret    

00400153 <set_cr0>:

/*
* void set_cr0 ()
*   Inputs: void
*   Return Value: none
*	Function: Set paging bit to enable paging
*/
.globl set_cr0
set_cr0:
				//set up stack frame
					push %ebp
  400153:	55                   	push   %ebp
					mov %esp, %ebp
  400154:	89 e5                	mov    %esp,%ebp

					mov %cr0, %eax
  400156:	0f 20 c0             	mov    %cr0,%eax

					//set paging bit(32th)
					or $0x80000000, %eax
  400159:	0d 00 00 00 80       	or     $0x80000000,%eax
					mov %eax, %cr0
  40015e:	0f 22 c0             	mov    %eax,%cr0

					leave
  400161:	c9                   	leave  
					ret
  400162:	c3                   	ret    

00400163 <set_pse>:

/*
* void set_pse()
*   Inputs: void
*   Return Value: none
*	Function: Sets the PSE to allow 4MB pages
*/
.globl set_pse
set_pse:
				//set up stack frame
					push %ebp
  400163:	55                   	push   %ebp
					mov %esp, %ebp
  400164:	89 e5                	mov    %esp,%ebp

					mov %cr4, %eax
  400166:	0f 20 e0             	mov    %cr4,%eax
					//magic number need to fix

					//set physical size extension bit(4th)
					or $0x00000010, %eax
  400169:	83 c8 10             	or     $0x10,%eax
					mov %eax, %cr4
  40016c:	0f 22 e0             	mov    %eax,%cr4
					leave
  40016f:	c9                   	leave  
					ret
  400170:	c3                   	ret    
  400171:	90                   	nop    
  400172:	90                   	nop    
  400173:	90                   	nop    
  400174:	90                   	nop    
  400175:	90                   	nop    
  400176:	90                   	nop    
  400177:	90                   	nop    
  400178:	90                   	nop    
  400179:	90                   	nop    
  40017a:	90                   	nop    
  40017b:	90                   	nop    
  40017c:	90                   	nop    
  40017d:	90                   	nop    
  40017e:	90                   	nop    
  40017f:	90                   	nop    

00400180 <gdt_size>:
  400180:	3f                   	aas    
  400181:	00 00                	add    %al,(%eax)
	...

00400184 <tss_size>:
  400184:	67 00 00             	addr16 add %al,(%bx,%si)
	...

00400188 <ldt_size>:
  400188:	1f                   	pop    %ds
  400189:	00 00                	add    %al,(%eax)
  40018b:	00 00                	add    %al,(%eax)
	...

0040018e <ldt_desc>:
  40018e:	38 00                	cmp    %al,(%eax)
  400190:	50                   	push   %eax
  400191:	02 40 00             	add    0x0(%eax),%al

00400194 <tss>:
	...

004001fc <gdt_desc_ptr>:
  4001fc:	3f                   	aas    
  4001fd:	00 10                	add    %dl,(%eax)
  4001ff:	02 40 00             	add    0x0(%eax),%al
  400202:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  400209:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

00400210 <gdt>:
	...

00400220 <gdt_ptr>:
  400220:	ff                   	(bad)  
  400221:	ff 00                	incl   (%eax)
  400223:	00 00                	add    %al,(%eax)
  400225:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
  40022c:	00 92 cf 00 ff ff    	add    %dl,0xffff00cf(%edx)
  400232:	00 00                	add    %al,(%eax)
  400234:	00 fa                	add    %bh,%dl
  400236:	cf                   	iret   
  400237:	00 ff                	add    %bh,%bh
  400239:	ff 00                	incl   (%eax)
  40023b:	00 00                	add    %al,(%eax)
  40023d:	f2 cf                	repnz iret 
	...

00400240 <tss_desc_ptr>:
	...

00400248 <ldt_desc_ptr>:
	...

00400250 <ldt>:
	...

00400270 <ldt_bottom>:
	...

00400272 <idt_desc_ptr>:
  400272:	ff 07                	incl   (%edi)
  400274:	80 02 40             	addb   $0x40,(%edx)
  400277:	00 90 8d b4 26 00    	add    %dl,0x26b48d(%eax)
  40027d:	00 00                	add    %al,(%eax)
	...

00400280 <idt>:
	...

00400a80 <sys_execute>:

extern pcb_t * pcb;

int32_t sys_execute(const uint8_t* command)
{
  400a80:	55                   	push   %ebp
  400a81:	89 e5                	mov    %esp,%ebp
  400a83:	53                   	push   %ebx
  400a84:	81 ec 94 f0 03 00    	sub    $0x3f094,%esp
  400a8a:	89 e0                	mov    %esp,%eax
  400a8c:	89 85 88 0f fc ff    	mov    %eax,0xfffc0f88(%ebp)
	uint32_t i;
	uint32_t size = strlen((int8_t*)command);
  400a92:	8b 45 08             	mov    0x8(%ebp),%eax
  400a95:	89 04 24             	mov    %eax,(%esp)
  400a98:	e8 be 24 00 00       	call   402f5b <strlen>
  400a9d:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
	uint8_t cmd[size+1];
  400aa0:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  400aa3:	83 c0 01             	add    $0x1,%eax
  400aa6:	83 c0 0f             	add    $0xf,%eax
  400aa9:	83 c0 0f             	add    $0xf,%eax
  400aac:	c1 e8 04             	shr    $0x4,%eax
  400aaf:	c1 e0 04             	shl    $0x4,%eax
  400ab2:	29 c4                	sub    %eax,%esp
  400ab4:	8d 44 24 10          	lea    0x10(%esp),%eax
  400ab8:	89 85 7c 0f fc ff    	mov    %eax,0xfffc0f7c(%ebp)
  400abe:	8b 85 7c 0f fc ff    	mov    0xfffc0f7c(%ebp),%eax
  400ac4:	83 c0 0f             	add    $0xf,%eax
  400ac7:	c1 e8 04             	shr    $0x4,%eax
  400aca:	c1 e0 04             	shl    $0x4,%eax
  400acd:	89 85 7c 0f fc ff    	mov    %eax,0xfffc0f7c(%ebp)
  400ad3:	8b 85 7c 0f fc ff    	mov    0xfffc0f7c(%ebp),%eax
  400ad9:	89 45 d0             	mov    %eax,0xffffffd0(%ebp)
	uint8_t args[size+1];
  400adc:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  400adf:	83 c0 01             	add    $0x1,%eax
  400ae2:	83 c0 0f             	add    $0xf,%eax
  400ae5:	83 c0 0f             	add    $0xf,%eax
  400ae8:	c1 e8 04             	shr    $0x4,%eax
  400aeb:	c1 e0 04             	shl    $0x4,%eax
  400aee:	29 c4                	sub    %eax,%esp
  400af0:	8d 44 24 10          	lea    0x10(%esp),%eax
  400af4:	89 85 80 0f fc ff    	mov    %eax,0xfffc0f80(%ebp)
  400afa:	8b 85 80 0f fc ff    	mov    0xfffc0f80(%ebp),%eax
  400b00:	83 c0 0f             	add    $0xf,%eax
  400b03:	c1 e8 04             	shr    $0x4,%eax
  400b06:	c1 e0 04             	shl    $0x4,%eax
  400b09:	89 85 80 0f fc ff    	mov    %eax,0xfffc0f80(%ebp)
  400b0f:	8b 85 80 0f fc ff    	mov    0xfffc0f80(%ebp),%eax
  400b15:	89 45 d4             	mov    %eax,0xffffffd4(%ebp)
	for(i=0; i<size; i++){
  400b18:	c7 45 d8 00 00 00 00 	movl   $0x0,0xffffffd8(%ebp)
  400b1f:	eb 18                	jmp    400b39 <sys_execute+0xb9>
		cmd[i]=0;
  400b21:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
  400b24:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
  400b27:	c6 04 10 00          	movb   $0x0,(%eax,%edx,1)
		args[i]=0;
  400b2b:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
  400b2e:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
  400b31:	c6 04 10 00          	movb   $0x0,(%eax,%edx,1)
  400b35:	83 45 d8 01          	addl   $0x1,0xffffffd8(%ebp)
  400b39:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  400b3c:	3b 45 dc             	cmp    0xffffffdc(%ebp),%eax
  400b3f:	72 e0                	jb     400b21 <sys_execute+0xa1>
	}
	parser(command, cmd, args);
  400b41:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
  400b44:	8b 55 d0             	mov    0xffffffd0(%ebp),%edx
  400b47:	89 44 24 08          	mov    %eax,0x8(%esp)
  400b4b:	89 54 24 04          	mov    %edx,0x4(%esp)
  400b4f:	8b 45 08             	mov    0x8(%ebp),%eax
  400b52:	89 04 24             	mov    %eax,(%esp)
  400b55:	e8 96 02 00 00       	call   400df0 <parser>
	uint32_t size_args = strlen((int8_t*)args);
  400b5a:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
  400b5d:	89 04 24             	mov    %eax,(%esp)
  400b60:	e8 f6 23 00 00       	call   402f5b <strlen>
  400b65:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
	printf("Typed:%s", command);
  400b68:	8b 45 08             	mov    0x8(%ebp),%eax
  400b6b:	89 44 24 04          	mov    %eax,0x4(%esp)
  400b6f:	c7 04 24 70 3f 40 00 	movl   $0x403f70,(%esp)
  400b76:	e8 32 1f 00 00       	call   402aad <printf>
	printf("Command:%s\n", cmd);
  400b7b:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
  400b7e:	89 44 24 04          	mov    %eax,0x4(%esp)
  400b82:	c7 04 24 79 3f 40 00 	movl   $0x403f79,(%esp)
  400b89:	e8 1f 1f 00 00       	call   402aad <printf>
	if (size_args){
  400b8e:	83 7d e0 00          	cmpl   $0x0,0xffffffe0(%ebp)
  400b92:	74 13                	je     400ba7 <sys_execute+0x127>
		printf("Arguments:%s\n", args);
  400b94:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
  400b97:	89 44 24 04          	mov    %eax,0x4(%esp)
  400b9b:	c7 04 24 85 3f 40 00 	movl   $0x403f85,(%esp)
  400ba2:	e8 06 1f 00 00       	call   402aad <printf>
	}
	if(checkExe(cmd) == -1){
  400ba7:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
  400baa:	89 04 24             	mov    %eax,(%esp)
  400bad:	e8 b1 02 00 00       	call   400e63 <checkExe>
  400bb2:	83 f8 ff             	cmp    $0xffffffff,%eax
  400bb5:	75 1b                	jne    400bd2 <sys_execute+0x152>
		printf("You don goofed!");
  400bb7:	c7 04 24 93 3f 40 00 	movl   $0x403f93,(%esp)
  400bbe:	e8 ea 1e 00 00       	call   402aad <printf>
		return -1;
  400bc3:	c7 85 84 0f fc ff ff 	movl   $0xffffffff,0xfffc0f84(%ebp)
  400bca:	ff ff ff 
  400bcd:	e9 0c 02 00 00       	jmp    400dde <halt_ret_label+0xb>
	}

	int32_t free_pid = 0;
  400bd2:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
	while (free_pid < 6) {
  400bd9:	eb 1a                	jmp    400bf5 <sys_execute+0x175>
		if ((pid_bitmap & (1 << free_pid)) == 0) {
  400bdb:	0f b6 05 00 60 40 00 	movzbl 0x406000,%eax
  400be2:	0f b6 c0             	movzbl %al,%eax
  400be5:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
  400be8:	d3 f8                	sar    %cl,%eax
  400bea:	83 e0 01             	and    $0x1,%eax
  400bed:	85 c0                	test   %eax,%eax
  400bef:	74 0a                	je     400bfb <sys_execute+0x17b>
			break;
		}
		free_pid++;
  400bf1:	83 45 e4 01          	addl   $0x1,0xffffffe4(%ebp)
  400bf5:	83 7d e4 05          	cmpl   $0x5,0xffffffe4(%ebp)
  400bf9:	7e e0                	jle    400bdb <sys_execute+0x15b>
	}

	/* copy file contents */

	//set up paging 
	setup_paging(free_pid);
  400bfb:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  400bfe:	89 04 24             	mov    %eax,(%esp)
  400c01:	e8 57 14 00 00       	call   40205d <setup_paging>

	dentry_t prog;

	if (read_dentry_by_name(cmd, &prog) == -1)
  400c06:	8b 55 d0             	mov    0xffffffd0(%ebp),%edx
  400c09:	8d 45 90             	lea    0xffffff90(%ebp),%eax
  400c0c:	89 44 24 04          	mov    %eax,0x4(%esp)
  400c10:	89 14 24             	mov    %edx,(%esp)
  400c13:	e8 44 03 00 00       	call   400f5c <read_dentry_by_name>
  400c18:	83 f8 ff             	cmp    $0xffffffff,%eax
  400c1b:	75 0f                	jne    400c2c <sys_execute+0x1ac>
		return -1;
  400c1d:	c7 85 84 0f fc ff ff 	movl   $0xffffffff,0xfffc0f84(%ebp)
  400c24:	ff ff ff 
  400c27:	e9 b2 01 00 00       	jmp    400dde <halt_ret_label+0xb>
	uint8_t prog_img[63*4096];
	int32_t num_byte = read_data(prog.inode_num, 0, prog_img, 63*4096);
  400c2c:	8b 45 b4             	mov    0xffffffb4(%ebp),%eax
  400c2f:	89 c2                	mov    %eax,%edx
  400c31:	c7 44 24 0c 00 f0 03 	movl   $0x3f000,0xc(%esp)
  400c38:	00 
  400c39:	8d 85 90 0f fc ff    	lea    0xfffc0f90(%ebp),%eax
  400c3f:	89 44 24 08          	mov    %eax,0x8(%esp)
  400c43:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  400c4a:	00 
  400c4b:	89 14 24             	mov    %edx,(%esp)
  400c4e:	e8 71 04 00 00       	call   4010c4 <read_data>
  400c53:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
	if(num_byte == -1)
  400c56:	83 7d e8 ff          	cmpl   $0xffffffff,0xffffffe8(%ebp)
  400c5a:	75 0f                	jne    400c6b <sys_execute+0x1eb>
		return -1;
  400c5c:	c7 85 84 0f fc ff ff 	movl   $0xffffffff,0xfffc0f84(%ebp)
  400c63:	ff ff ff 
  400c66:	e9 73 01 00 00       	jmp    400dde <halt_ret_label+0xb>
	memcpy((void*)((free_pid * physical_page_offset) + IMG_OFFSET + ENTRY_POINT_START), (void*)prog_img, num_byte);
  400c6b:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
  400c6e:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  400c71:	c1 e0 16             	shl    $0x16,%eax
  400c74:	05 00 80 04 08       	add    $0x8048000,%eax
  400c79:	89 c1                	mov    %eax,%ecx
  400c7b:	89 54 24 08          	mov    %edx,0x8(%esp)
  400c7f:	8d 85 90 0f fc ff    	lea    0xfffc0f90(%ebp),%eax
  400c85:	89 44 24 04          	mov    %eax,0x4(%esp)
  400c89:	89 0c 24             	mov    %ecx,(%esp)
  400c8c:	e8 8c 23 00 00       	call   40301d <memcpy>

	pcb = (pcb_t*)(KERNEL_STACK_BASE - ((free_pid+1) * TASK_STACK_SIZE));
  400c91:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  400c94:	c1 e0 0d             	shl    $0xd,%eax
  400c97:	f7 d8                	neg    %eax
  400c99:	05 00 e0 7f 00       	add    $0x7fe000,%eax
  400c9e:	a3 c0 d0 40 00       	mov    %eax,0x40d0c0
	pcb->parent_pid = pcb->pid;
  400ca3:	8b 15 c0 d0 40 00    	mov    0x40d0c0,%edx
  400ca9:	a1 c0 d0 40 00       	mov    0x40d0c0,%eax
  400cae:	8b 80 e0 00 00 00    	mov    0xe0(%eax),%eax
  400cb4:	89 82 e4 00 00 00    	mov    %eax,0xe4(%edx)
	pcb->pid = free_pid;
  400cba:	8b 15 c0 d0 40 00    	mov    0x40d0c0,%edx
  400cc0:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  400cc3:	89 82 e0 00 00 00    	mov    %eax,0xe0(%edx)

	pcb->file_array[0].fops_table.read = tRead;
  400cc9:	a1 c0 d0 40 00       	mov    0x40d0c0,%eax
  400cce:	c7 40 04 3b 3e 40 00 	movl   $0x403e3b,0x4(%eax)
	pcb->file_array[0].flags = TYPE_TERM & OPEN;
  400cd5:	a1 c0 d0 40 00       	mov    0x40d0c0,%eax
  400cda:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)

	pcb->file_array[1].fops_table.write = tWrite;
  400ce1:	a1 c0 d0 40 00       	mov    0x40d0c0,%eax
  400ce6:	c7 40 24 0f 3f 40 00 	movl   $0x403f0f,0x24(%eax)
	pcb->file_array[1].flags = TYPE_TERM & OPEN;
  400ced:	a1 c0 d0 40 00       	mov    0x40d0c0,%eax
  400cf2:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)

	pid_bitmap |= (1 << free_pid);
  400cf9:	8b 4d e4             	mov    0xffffffe4(%ebp),%ecx
  400cfc:	b8 01 00 00 00       	mov    $0x1,%eax
  400d01:	d3 e0                	shl    %cl,%eax
  400d03:	89 c2                	mov    %eax,%edx
  400d05:	0f b6 05 00 60 40 00 	movzbl 0x406000,%eax
  400d0c:	09 d0                	or     %edx,%eax
  400d0e:	a2 00 60 40 00       	mov    %al,0x406000

	 // calculate entry point: 128 MB + offset, where offset = buf[24-27]
	uint32_t entry_point = ENTRY_POINT_START;
  400d13:	c7 45 ec 00 00 00 08 	movl   $0x8000000,0xffffffec(%ebp)
	uint32_t * buf_bytes = (uint32_t *)prog_img;
  400d1a:	8d 85 90 0f fc ff    	lea    0xfffc0f90(%ebp),%eax
  400d20:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	entry_point = buf_bytes[6];
  400d23:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  400d26:	83 c0 18             	add    $0x18,%eax
  400d29:	8b 00                	mov    (%eax),%eax
  400d2b:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	tss.eip = entry_point;
  400d2e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  400d31:	a3 b4 01 40 00       	mov    %eax,0x4001b4

	//set up tss for context switch 
	tss.esp0 = KERNEL_STACK_BASE - (pcb->pid * TASK_STACK_SIZE);
  400d36:	a1 c0 d0 40 00       	mov    0x40d0c0,%eax
  400d3b:	8b 80 e0 00 00 00    	mov    0xe0(%eax),%eax
  400d41:	89 c2                	mov    %eax,%edx
  400d43:	c1 e2 0d             	shl    $0xd,%edx
  400d46:	b8 00 00 80 00       	mov    $0x800000,%eax
  400d4b:	29 d0                	sub    %edx,%eax
  400d4d:	a3 98 01 40 00       	mov    %eax,0x400198
	tss.ss0 = KERNEL_DS;
  400d52:	66 c7 05 9c 01 40 00 	movw   $0x18,0x40019c
  400d59:	18 00 

	/* save stuff into pcb */

	uint32_t * process_esp;

	asm (
  400d5b:	89 e0                	mov    %esp,%eax
  400d5d:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
		"movl %%esp, %0;"
		: "=r" ( process_esp )
	);

	pcb->parent_ebp = ENTRY_POINT_START - (pcb->pid*physical_page_offset);
  400d60:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  400d66:	a1 c0 d0 40 00       	mov    0x40d0c0,%eax
  400d6b:	8b 80 e0 00 00 00    	mov    0xe0(%eax),%eax
  400d71:	89 c2                	mov    %eax,%edx
  400d73:	c1 e2 16             	shl    $0x16,%edx
  400d76:	b8 00 00 00 08       	mov    $0x8000000,%eax
  400d7b:	29 d0                	sub    %edx,%eax
  400d7d:	89 81 ec 00 00 00    	mov    %eax,0xec(%ecx)
	pcb->parent_esp = *(process_esp + 15);
  400d83:	8b 15 c0 d0 40 00    	mov    0x40d0c0,%edx
  400d89:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  400d8c:	83 c0 3c             	add    $0x3c,%eax
  400d8f:	8b 00                	mov    (%eax),%eax
  400d91:	89 82 e8 00 00 00    	mov    %eax,0xe8(%edx)
	pcb->arguments = args;
  400d97:	8b 15 c0 d0 40 00    	mov    0x40d0c0,%edx
  400d9d:	8b 45 d4             	mov    0xffffffd4(%ebp),%eax
  400da0:	89 82 f0 00 00 00    	mov    %eax,0xf0(%edx)

	/* push artificial IRET context and return value onto stack;
	 * set IF to 1 and DPL to 3 then push eflags */
	int32_t child_esp = 0x8400000-4;
  400da6:	c7 45 f8 fc ff 3f 08 	movl   $0x83ffffc,0xfffffff8(%ebp)
	asm (
  400dad:	8b 5d ec             	mov    0xffffffec(%ebp),%ebx
  400db0:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  400db3:	66 6a 2b             	pushw  $0x2b
  400db6:	66 6a 00             	pushw  $0x0
  400db9:	50                   	push   %eax
  400dba:	9c                   	pushf  
  400dbb:	59                   	pop    %ecx
  400dbc:	81 c9 00 02 00 00    	or     $0x200,%ecx
  400dc2:	51                   	push   %ecx
  400dc3:	66 6a 23             	pushw  $0x23
  400dc6:	66 6a 00             	pushw  $0x0
  400dc9:	53                   	push   %ebx
  400dca:	66 ba 2b 00          	mov    $0x2b,%dx
  400dce:	66 52                	push   %dx
  400dd0:	66 1f                	popw   %ds
  400dd2:	cf                   	iret   

00400dd3 <halt_ret_label>:
  400dd3:	c3                   	ret    
		"pushw $0x002B;"
		"pushw $0;"
		"pushl %1;"
		"pushf;"
		"popl %%ecx;"
		"orl $0x0200, %%ecx;"
		"pushl %%ecx;"
		"pushw $0x0023;"
		"pushw $0;"
		"pushl %0;"
		"movw $0x002B, %%dx;"
		"pushw %%dx;"
		"popw %%ds;"
		"iret;"
		".globl halt_ret_label ;"
		"halt_ret_label: ;"
		"ret"
		:
		: "r" ( entry_point ), "r" (child_esp)
		: "%ecx", "%dx"
	);

	return 0;
  400dd4:	c7 85 84 0f fc ff 00 	movl   $0x0,0xfffc0f84(%ebp)
  400ddb:	00 00 00 
  400dde:	8b a5 88 0f fc ff    	mov    0xfffc0f88(%ebp),%esp
  400de4:	8b 85 84 0f fc ff    	mov    0xfffc0f84(%ebp),%eax
}
  400dea:	8b 5d fc             	mov    0xfffffffc(%ebp),%ebx
  400ded:	c9                   	leave  
  400dee:	c3                   	ret    
  400def:	90                   	nop    

00400df0 <parser>:

extern pcb_t * pcb;

void parser(const uint8_t* command, uint8_t* cmd, uint8_t* args)
{
  400df0:	55                   	push   %ebp
  400df1:	89 e5                	mov    %esp,%ebp
  400df3:	83 ec 10             	sub    $0x10,%esp
	uint32_t i = 0;
  400df6:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
	uint32_t t = 0;
  400dfd:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
	while(command[i] != ' ' && command[i] != '\n'){
  400e04:	eb 17                	jmp    400e1d <parser+0x2d>
		cmd[i] = command[i];
  400e06:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  400e09:	89 c2                	mov    %eax,%edx
  400e0b:	03 55 0c             	add    0xc(%ebp),%edx
  400e0e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  400e11:	03 45 08             	add    0x8(%ebp),%eax
  400e14:	0f b6 00             	movzbl (%eax),%eax
  400e17:	88 02                	mov    %al,(%edx)
		i++;
  400e19:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  400e1d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  400e20:	03 45 08             	add    0x8(%ebp),%eax
  400e23:	0f b6 00             	movzbl (%eax),%eax
  400e26:	3c 20                	cmp    $0x20,%al
  400e28:	74 2a                	je     400e54 <parser+0x64>
  400e2a:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  400e2d:	03 45 08             	add    0x8(%ebp),%eax
  400e30:	0f b6 00             	movzbl (%eax),%eax
  400e33:	3c 0a                	cmp    $0xa,%al
  400e35:	75 cf                	jne    400e06 <parser+0x16>
	}
	while(command[i] != '\n'){
  400e37:	eb 1b                	jmp    400e54 <parser+0x64>
		args[t] = command[i];
  400e39:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  400e3c:	89 c2                	mov    %eax,%edx
  400e3e:	03 55 10             	add    0x10(%ebp),%edx
  400e41:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  400e44:	03 45 08             	add    0x8(%ebp),%eax
  400e47:	0f b6 00             	movzbl (%eax),%eax
  400e4a:	88 02                	mov    %al,(%edx)
		t++;
  400e4c:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
		i++;
  400e50:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  400e54:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  400e57:	03 45 08             	add    0x8(%ebp),%eax
  400e5a:	0f b6 00             	movzbl (%eax),%eax
  400e5d:	3c 0a                	cmp    $0xa,%al
  400e5f:	75 d8                	jne    400e39 <parser+0x49>
	}
}
  400e61:	c9                   	leave  
  400e62:	c3                   	ret    

00400e63 <checkExe>:

uint32_t checkExe(uint8_t* cmd)
{
  400e63:	55                   	push   %ebp
  400e64:	89 e5                	mov    %esp,%ebp
  400e66:	83 ec 68             	sub    $0x68,%esp
	dentry_t prog;
	if (read_dentry_by_name(cmd, &prog) == -1)
  400e69:	8d 45 c0             	lea    0xffffffc0(%ebp),%eax
  400e6c:	89 44 24 04          	mov    %eax,0x4(%esp)
  400e70:	8b 45 08             	mov    0x8(%ebp),%eax
  400e73:	89 04 24             	mov    %eax,(%esp)
  400e76:	e8 e1 00 00 00       	call   400f5c <read_dentry_by_name>
  400e7b:	83 f8 ff             	cmp    $0xffffffff,%eax
  400e7e:	75 1f                	jne    400e9f <checkExe+0x3c>
	{
		printf("%s is an invalid filename!\n", cmd);
  400e80:	8b 45 08             	mov    0x8(%ebp),%eax
  400e83:	89 44 24 04          	mov    %eax,0x4(%esp)
  400e87:	c7 04 24 a3 3f 40 00 	movl   $0x403fa3,(%esp)
  400e8e:	e8 1a 1c 00 00       	call   402aad <printf>
		return -1;
  400e93:	c7 45 ac ff ff ff ff 	movl   $0xffffffff,0xffffffac(%ebp)
  400e9a:	e9 b6 00 00 00       	jmp    400f55 <checkExe+0xf2>
	}
	uint8_t elf[4];
	if(read_data(prog.inode_num, 0, elf, 4)==-1){
  400e9f:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  400ea2:	89 c2                	mov    %eax,%edx
  400ea4:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
  400eab:	00 
  400eac:	8d 45 bc             	lea    0xffffffbc(%ebp),%eax
  400eaf:	89 44 24 08          	mov    %eax,0x8(%esp)
  400eb3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  400eba:	00 
  400ebb:	89 14 24             	mov    %edx,(%esp)
  400ebe:	e8 01 02 00 00       	call   4010c4 <read_data>
  400ec3:	83 f8 ff             	cmp    $0xffffffff,%eax
  400ec6:	75 1c                	jne    400ee4 <checkExe+0x81>
		printf("Could not read file:%s\n", cmd);
  400ec8:	8b 45 08             	mov    0x8(%ebp),%eax
  400ecb:	89 44 24 04          	mov    %eax,0x4(%esp)
  400ecf:	c7 04 24 bf 3f 40 00 	movl   $0x403fbf,(%esp)
  400ed6:	e8 d2 1b 00 00       	call   402aad <printf>
		return -1;
  400edb:	c7 45 ac ff ff ff ff 	movl   $0xffffffff,0xffffffac(%ebp)
  400ee2:	eb 71                	jmp    400f55 <checkExe+0xf2>
	}
	if(elf[0]==0x7F&&elf[1]=='E'&&elf[2]=='L'&&elf[3]=='F'){
  400ee4:	0f b6 45 bc          	movzbl 0xffffffbc(%ebp),%eax
  400ee8:	3c 7f                	cmp    $0x7f,%al
  400eea:	75 4f                	jne    400f3b <checkExe+0xd8>
  400eec:	0f b6 45 bd          	movzbl 0xffffffbd(%ebp),%eax
  400ef0:	3c 45                	cmp    $0x45,%al
  400ef2:	75 47                	jne    400f3b <checkExe+0xd8>
  400ef4:	0f b6 45 be          	movzbl 0xffffffbe(%ebp),%eax
  400ef8:	3c 4c                	cmp    $0x4c,%al
  400efa:	75 3f                	jne    400f3b <checkExe+0xd8>
  400efc:	0f b6 45 bf          	movzbl 0xffffffbf(%ebp),%eax
  400f00:	3c 46                	cmp    $0x46,%al
  400f02:	75 37                	jne    400f3b <checkExe+0xd8>
		printf("%s is an ELF file!\n", cmd);
  400f04:	8b 45 08             	mov    0x8(%ebp),%eax
  400f07:	89 44 24 04          	mov    %eax,0x4(%esp)
  400f0b:	c7 04 24 d7 3f 40 00 	movl   $0x403fd7,(%esp)
  400f12:	e8 96 1b 00 00       	call   402aad <printf>
		printf("Argumets in the pcb struct:%s", pcb->arguments);
  400f17:	a1 c0 d0 40 00       	mov    0x40d0c0,%eax
  400f1c:	8b 80 f0 00 00 00    	mov    0xf0(%eax),%eax
  400f22:	89 44 24 04          	mov    %eax,0x4(%esp)
  400f26:	c7 04 24 eb 3f 40 00 	movl   $0x403feb,(%esp)
  400f2d:	e8 7b 1b 00 00       	call   402aad <printf>
		return 0;
  400f32:	c7 45 ac 00 00 00 00 	movl   $0x0,0xffffffac(%ebp)
  400f39:	eb 1a                	jmp    400f55 <checkExe+0xf2>
	}
	else{
		printf("%s is not an ELF file :(", cmd);
  400f3b:	8b 45 08             	mov    0x8(%ebp),%eax
  400f3e:	89 44 24 04          	mov    %eax,0x4(%esp)
  400f42:	c7 04 24 09 40 40 00 	movl   $0x404009,(%esp)
  400f49:	e8 5f 1b 00 00       	call   402aad <printf>
		return -1;
  400f4e:	c7 45 ac ff ff ff ff 	movl   $0xffffffff,0xffffffac(%ebp)
  400f55:	8b 45 ac             	mov    0xffffffac(%ebp),%eax
	}
	return 0;
}
  400f58:	c9                   	leave  
  400f59:	c3                   	ret    
  400f5a:	90                   	nop    
  400f5b:	90                   	nop    

00400f5c <read_dentry_by_name>:
*   Return Value: int32_t (0 if success, -1 if failure)
*	Function: updates the dentry struct to the values of the filename passed in.
*/
int32_t read_dentry_by_name (const uint8_t* fname, dentry_t* dentry)
{
  400f5c:	55                   	push   %ebp
  400f5d:	89 e5                	mov    %esp,%ebp
  400f5f:	83 ec 28             	sub    $0x28,%esp
	int d = 0;
  400f62:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
	while (strncmp(bblock->dentry[d].file_name, (int8_t*)fname, 32))	//compare the value of the filename passed in and the filename in the bootblock
  400f69:	eb 16                	jmp    400f81 <read_dentry_by_name+0x25>
	{
		if (d >= MAX_FILES - 1)	//check if all files are checked
  400f6b:	83 7d fc 3d          	cmpl   $0x3d,0xfffffffc(%ebp)
  400f6f:	7e 0c                	jle    400f7d <read_dentry_by_name+0x21>
			return -1;
  400f71:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  400f78:	e9 8c 00 00 00       	jmp    401009 <read_dentry_by_name+0xad>
		d++;
  400f7d:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  400f81:	8b 4d 08             	mov    0x8(%ebp),%ecx
  400f84:	8b 15 c8 d0 40 00    	mov    0x40d0c8,%edx
  400f8a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  400f8d:	c1 e0 06             	shl    $0x6,%eax
  400f90:	83 c0 40             	add    $0x40,%eax
  400f93:	8d 04 02             	lea    (%edx,%eax,1),%eax
  400f96:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  400f9d:	00 
  400f9e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  400fa2:	89 04 24             	mov    %eax,(%esp)
  400fa5:	e8 f0 20 00 00       	call   40309a <strncmp>
  400faa:	85 c0                	test   %eax,%eax
  400fac:	75 bd                	jne    400f6b <read_dentry_by_name+0xf>
	}
	strcpy(dentry->file_name, bblock->dentry[d].file_name);	//update the dentry values when the file is found
  400fae:	8b 15 c8 d0 40 00    	mov    0x40d0c8,%edx
  400fb4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  400fb7:	c1 e0 06             	shl    $0x6,%eax
  400fba:	83 c0 40             	add    $0x40,%eax
  400fbd:	8d 04 02             	lea    (%edx,%eax,1),%eax
  400fc0:	8b 55 0c             	mov    0xc(%ebp),%edx
  400fc3:	89 44 24 04          	mov    %eax,0x4(%esp)
  400fc7:	89 14 24             	mov    %edx,(%esp)
  400fca:	e8 36 21 00 00       	call   403105 <strcpy>
	dentry->file_type = bblock->dentry[d].file_type;
  400fcf:	8b 15 c8 d0 40 00    	mov    0x40d0c8,%edx
  400fd5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  400fd8:	c1 e0 06             	shl    $0x6,%eax
  400fdb:	01 d0                	add    %edx,%eax
  400fdd:	83 c0 60             	add    $0x60,%eax
  400fe0:	8b 10                	mov    (%eax),%edx
  400fe2:	8b 45 0c             	mov    0xc(%ebp),%eax
  400fe5:	89 50 20             	mov    %edx,0x20(%eax)
	dentry->inode_num = bblock->dentry[d].inode_num;
  400fe8:	8b 15 c8 d0 40 00    	mov    0x40d0c8,%edx
  400fee:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  400ff1:	c1 e0 06             	shl    $0x6,%eax
  400ff4:	01 d0                	add    %edx,%eax
  400ff6:	83 c0 60             	add    $0x60,%eax
  400ff9:	8b 50 04             	mov    0x4(%eax),%edx
  400ffc:	8b 45 0c             	mov    0xc(%ebp),%eax
  400fff:	89 50 24             	mov    %edx,0x24(%eax)
	return 0;
  401002:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  401009:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  40100c:	c9                   	leave  
  40100d:	c3                   	ret    

0040100e <read_dentry_by_index>:

/*
* int32_t read_dentry_by_index (uint32_t index, dentry_t* dentry)
*   Inputs: index -- Index node of the file that needs to be read from.
*			dentry -- Dentry structure that needs to be populated.
*   Return Value: int32_t (0 if success, -1 if failure)
*	Function: updates the dentry struct to the values of the index nodes passed in.
*/
int32_t read_dentry_by_index (uint32_t index, dentry_t* dentry)
{
  40100e:	55                   	push   %ebp
  40100f:	89 e5                	mov    %esp,%ebp
  401011:	83 ec 28             	sub    $0x28,%esp
	int d = 0;
  401014:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
	while (bblock->dentry[d].inode_num != index || bblock->dentry[d].file_type != 2)	//compare the value of the index node passed in and the inode in the bootblock & ignore all entries except for regular files
  40101b:	eb 16                	jmp    401033 <read_dentry_by_index+0x25>
	{
		if (d >= MAX_FILES - 1)	//check if all files are checked
  40101d:	83 7d fc 3d          	cmpl   $0x3d,0xfffffffc(%ebp)
  401021:	7e 0c                	jle    40102f <read_dentry_by_index+0x21>
			return -1;
  401023:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  40102a:	e9 90 00 00 00       	jmp    4010bf <read_dentry_by_index+0xb1>
		d++;
  40102f:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  401033:	8b 15 c8 d0 40 00    	mov    0x40d0c8,%edx
  401039:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  40103c:	c1 e0 06             	shl    $0x6,%eax
  40103f:	01 d0                	add    %edx,%eax
  401041:	83 c0 60             	add    $0x60,%eax
  401044:	8b 40 04             	mov    0x4(%eax),%eax
  401047:	3b 45 08             	cmp    0x8(%ebp),%eax
  40104a:	75 d1                	jne    40101d <read_dentry_by_index+0xf>
  40104c:	8b 15 c8 d0 40 00    	mov    0x40d0c8,%edx
  401052:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  401055:	c1 e0 06             	shl    $0x6,%eax
  401058:	01 d0                	add    %edx,%eax
  40105a:	83 c0 60             	add    $0x60,%eax
  40105d:	8b 00                	mov    (%eax),%eax
  40105f:	83 f8 02             	cmp    $0x2,%eax
  401062:	75 b9                	jne    40101d <read_dentry_by_index+0xf>
	}
	strcpy(dentry->file_name, bblock->dentry[d].file_name);	//update the dentry values when the file is found
  401064:	8b 15 c8 d0 40 00    	mov    0x40d0c8,%edx
  40106a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  40106d:	c1 e0 06             	shl    $0x6,%eax
  401070:	83 c0 40             	add    $0x40,%eax
  401073:	8d 04 02             	lea    (%edx,%eax,1),%eax
  401076:	8b 55 0c             	mov    0xc(%ebp),%edx
  401079:	89 44 24 04          	mov    %eax,0x4(%esp)
  40107d:	89 14 24             	mov    %edx,(%esp)
  401080:	e8 80 20 00 00       	call   403105 <strcpy>
	dentry->file_type = bblock->dentry[d].file_type;
  401085:	8b 15 c8 d0 40 00    	mov    0x40d0c8,%edx
  40108b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  40108e:	c1 e0 06             	shl    $0x6,%eax
  401091:	01 d0                	add    %edx,%eax
  401093:	83 c0 60             	add    $0x60,%eax
  401096:	8b 10                	mov    (%eax),%edx
  401098:	8b 45 0c             	mov    0xc(%ebp),%eax
  40109b:	89 50 20             	mov    %edx,0x20(%eax)
	dentry->inode_num = bblock->dentry[d].inode_num;
  40109e:	8b 15 c8 d0 40 00    	mov    0x40d0c8,%edx
  4010a4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  4010a7:	c1 e0 06             	shl    $0x6,%eax
  4010aa:	01 d0                	add    %edx,%eax
  4010ac:	83 c0 60             	add    $0x60,%eax
  4010af:	8b 50 04             	mov    0x4(%eax),%edx
  4010b2:	8b 45 0c             	mov    0xc(%ebp),%eax
  4010b5:	89 50 24             	mov    %edx,0x24(%eax)
	return 0;
  4010b8:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  4010bf:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  4010c2:	c9                   	leave  
  4010c3:	c3                   	ret    

004010c4 <read_data>:

/*
* int32_t read_data (uint32_t inode, uint32_t offset, uint8_t* buf, uint32_t length)
*   Inputs: inode -- Index node of the file that needs to be read from.
*			offset -- Offset bytes into the file and read from there.
*			buf -- buffer to store values read from file.
*			length -- number of bytes to read.
*   Return Value: int32_t (number of bytes read from file, 0 if none were read and -1 if there is an error)
*	Function: reads data of length bytes from the file referred to by inode starting from offset and stores it into the buf
*/
int32_t read_data (uint32_t inode, uint32_t offset, uint8_t* buf, uint32_t length)
{
  4010c4:	55                   	push   %ebp
  4010c5:	89 e5                	mov    %esp,%ebp
  4010c7:	83 ec 24             	sub    $0x24,%esp
	/* the first block to start reading from */
	uint32_t start_block;
	/* how many blocks need to be read from (including start_block itself) */
	uint32_t num_blocks_left;
	/* the number of the block currently being read */
	uint32_t cur_block_num;
	/* how many bytes copied into the buffer */
	uint32_t bytes_copied = 0;
  4010ca:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)

	int i, j;
	uint8_t * ptr;

	inode_t * in = GET_INODE_ADRS(inode);
  4010d1:	a1 c8 d0 40 00       	mov    0x40d0c8,%eax
  4010d6:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
  4010dc:	8b 45 08             	mov    0x8(%ebp),%eax
  4010df:	c1 e0 0c             	shl    $0xc,%eax
  4010e2:	8d 04 02             	lea    (%edx,%eax,1),%eax
  4010e5:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

	/* is inode number in range? */
	if (inode >= bblock->inode_cnt) {
  4010e8:	a1 c8 d0 40 00       	mov    0x40d0c8,%eax
  4010ed:	8b 40 04             	mov    0x4(%eax),%eax
  4010f0:	3b 45 08             	cmp    0x8(%ebp),%eax
  4010f3:	77 0c                	ja     401101 <read_data+0x3d>
		/* DEBUG print statement */
		// printf("read_data: inode number %u out of range 0 to %u\n", inode, bblock->inode_cnt - 1);
		return -1;
  4010f5:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,0xffffffdc(%ebp)
  4010fc:	e9 fa 00 00 00       	jmp    4011fb <read_data+0x137>
	}

	/* does offset refer to a valid block number? */
	if (offset >= in->length) {
  401101:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  401104:	8b 00                	mov    (%eax),%eax
  401106:	3b 45 0c             	cmp    0xc(%ebp),%eax
  401109:	77 0c                	ja     401117 <read_data+0x53>
		/* DEBUG print statement */
		// printf("read_data: offset %u out of range\n", offset);
		return -1;
  40110b:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,0xffffffdc(%ebp)
  401112:	e9 e4 00 00 00       	jmp    4011fb <read_data+0x137>
	}

	/* is length valid? */
	if (length == 0) {
  401117:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  40111b:	75 0c                	jne    401129 <read_data+0x65>
		/* DEBUG print statement */
		// printf("read_data: number of bytes to read is 0\n");
		return 0;
  40111d:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  401124:	e9 d2 00 00 00       	jmp    4011fb <read_data+0x137>
	}

	start_block = offset / BYTES_PER_BLOCK;
  401129:	8b 45 0c             	mov    0xc(%ebp),%eax
  40112c:	c1 e8 0c             	shr    $0xc,%eax
  40112f:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
	num_blocks_left = length / BYTES_PER_BLOCK + 1;
  401132:	8b 45 14             	mov    0x14(%ebp),%eax
  401135:	c1 e8 0c             	shr    $0xc,%eax
  401138:	83 c0 01             	add    $0x1,%eax
  40113b:	89 45 e4             	mov    %eax,0xffffffe4(%ebp)

	for (i = 0; i < num_blocks_left; i++) {
  40113e:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
  401145:	e9 9f 00 00 00       	jmp    4011e9 <read_data+0x125>
		if (i == 0) {
  40114a:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  40114e:	75 09                	jne    401159 <read_data+0x95>
			/* calculate the offset from the start of start_block instead of
			 * from the start of the file
			*/
			offset = offset % BYTES_PER_BLOCK;
  401150:	81 65 0c ff 0f 00 00 	andl   $0xfff,0xc(%ebp)
  401157:	eb 07                	jmp    401160 <read_data+0x9c>
		} else {
			/* start reading from the beginning of the block */
			offset = 0;
  401159:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
		}

		cur_block_num = in->data_block[start_block + i];
  401160:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  401163:	89 c2                	mov    %eax,%edx
  401165:	03 55 e0             	add    0xffffffe0(%ebp),%edx
  401168:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  40116b:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
  40116f:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
		ptr = GET_DATABLOCK_ADRS(cur_block_num);
  401172:	a1 c8 d0 40 00       	mov    0x40d0c8,%eax
  401177:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
  40117d:	a1 c8 d0 40 00       	mov    0x40d0c8,%eax
  401182:	8b 40 04             	mov    0x4(%eax),%eax
  401185:	03 45 e8             	add    0xffffffe8(%ebp),%eax
  401188:	c1 e0 0c             	shl    $0xc,%eax
  40118b:	8d 04 02             	lea    (%edx,%eax,1),%eax
  40118e:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
		/* if end of file reached */
		if (cur_block_num == 0) {
  401191:	83 7d e8 00          	cmpl   $0x0,0xffffffe8(%ebp)
  401195:	75 08                	jne    40119f <read_data+0xdb>
			/* DEBUG print statement */
			// printf("read_data: end of file reached\n");
			return bytes_copied;
  401197:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  40119a:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  40119d:	eb 5c                	jmp    4011fb <read_data+0x137>
		}

		for (j = offset; j < BYTES_PER_BLOCK; j++) {
  40119f:	8b 45 0c             	mov    0xc(%ebp),%eax
  4011a2:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  4011a5:	eb 35                	jmp    4011dc <read_data+0x118>
			if (bytes_copied == length || bytes_copied == in->length) {
  4011a7:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  4011aa:	3b 45 14             	cmp    0x14(%ebp),%eax
  4011ad:	74 0a                	je     4011b9 <read_data+0xf5>
  4011af:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  4011b2:	8b 00                	mov    (%eax),%eax
  4011b4:	3b 45 ec             	cmp    0xffffffec(%ebp),%eax
  4011b7:	75 08                	jne    4011c1 <read_data+0xfd>
				/* DEBUG print statement */
				// printf("read_data: copied all bytes\n");
				return bytes_copied;
  4011b9:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  4011bc:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  4011bf:	eb 3a                	jmp    4011fb <read_data+0x137>
			}

			buf[bytes_copied] = ptr[j];
  4011c1:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  4011c4:	89 c2                	mov    %eax,%edx
  4011c6:	03 55 10             	add    0x10(%ebp),%edx
  4011c9:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  4011cc:	03 45 f8             	add    0xfffffff8(%ebp),%eax
  4011cf:	0f b6 00             	movzbl (%eax),%eax
  4011d2:	88 02                	mov    %al,(%edx)
			bytes_copied++;
  4011d4:	83 45 ec 01          	addl   $0x1,0xffffffec(%ebp)
  4011d8:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
  4011dc:	81 7d f4 ff 0f 00 00 	cmpl   $0xfff,0xfffffff4(%ebp)
  4011e3:	7e c2                	jle    4011a7 <read_data+0xe3>
  4011e5:	83 45 f0 01          	addl   $0x1,0xfffffff0(%ebp)
  4011e9:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  4011ec:	3b 45 e4             	cmp    0xffffffe4(%ebp),%eax
  4011ef:	0f 82 55 ff ff ff    	jb     40114a <read_data+0x86>
		}
	}

	/* DEBUG print statement */
	// printf("read_data: copied all blocks\n");
	return bytes_copied;
  4011f5:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  4011f8:	89 45 dc             	mov    %eax,0xffffffdc(%ebp)
  4011fb:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax

}
  4011fe:	c9                   	leave  
  4011ff:	c3                   	ret    

00401200 <reg_file_open>:

/*
* int32_t reg_file_open(const uint8_t* filename)
*   Inputs: filename -- Name of the file that needs to be opened.
*   Return Value: int32_t (0 if success, -1 if failure)
*	Function: Sets up the file system struct in the PCB for the file to be opened.
*/
int32_t reg_file_open(const uint8_t* filename)
{
  401200:	55                   	push   %ebp
  401201:	89 e5                	mov    %esp,%ebp
	return 0;
  401203:	b8 00 00 00 00       	mov    $0x0,%eax
}
  401208:	5d                   	pop    %ebp
  401209:	c3                   	ret    

0040120a <reg_file_read>:

/*
* int32_t reg_file_read (file_struct_t * fs_ptr, void* buf, int32_t nbytes)
*   Inputs: fs_ptr -- Pointer to the file system struct of the file to read.
*			buf -- Buffer to put read data on to.
*			nbytes -- Number of bytes to read from file
*   Return Value: int32_t (number of bytes read from file or -1 if failure)
*	Function: Reads nbytes from a file refered to by fs_ptr and stores them into buf.
*/
int32_t reg_file_read (int32_t fd, void* buf, int32_t nbytes)
{
  40120a:	55                   	push   %ebp
  40120b:	89 e5                	mov    %esp,%ebp
  40120d:	57                   	push   %edi
  40120e:	56                   	push   %esi
  40120f:	53                   	push   %ebx
  401210:	83 ec 24             	sub    $0x24,%esp
	if(pcb->file_array[fd].flags == (TYPE_FILE & OPEN))	//check if the file is open
  401213:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  401219:	8b 45 08             	mov    0x8(%ebp),%eax
  40121c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  401223:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  40122a:	29 d0                	sub    %edx,%eax
  40122c:	01 c8                	add    %ecx,%eax
  40122e:	83 c0 10             	add    $0x10,%eax
  401231:	8b 40 08             	mov    0x8(%eax),%eax
  401234:	85 c0                	test   %eax,%eax
  401236:	0f 85 b7 00 00 00    	jne    4012f3 <reg_file_read+0xe9>
	{
		int ret_val = read_data(pcb->file_array[fd].inode, pcb->file_array[fd].file_position, buf, nbytes);	//read nbytes using the read_data function
  40123c:	8b 5d 10             	mov    0x10(%ebp),%ebx
  40123f:	8b 75 0c             	mov    0xc(%ebp),%esi
  401242:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  401248:	8b 45 08             	mov    0x8(%ebp),%eax
  40124b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  401252:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  401259:	29 d0                	sub    %edx,%eax
  40125b:	01 c8                	add    %ecx,%eax
  40125d:	83 c0 10             	add    $0x10,%eax
  401260:	8b 40 04             	mov    0x4(%eax),%eax
  401263:	89 c7                	mov    %eax,%edi
  401265:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  40126b:	8b 45 08             	mov    0x8(%ebp),%eax
  40126e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  401275:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  40127c:	29 d0                	sub    %edx,%eax
  40127e:	01 c8                	add    %ecx,%eax
  401280:	83 c0 10             	add    $0x10,%eax
  401283:	8b 00                	mov    (%eax),%eax
  401285:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  401289:	89 74 24 08          	mov    %esi,0x8(%esp)
  40128d:	89 7c 24 04          	mov    %edi,0x4(%esp)
  401291:	89 04 24             	mov    %eax,(%esp)
  401294:	e8 2b fe ff ff       	call   4010c4 <read_data>
  401299:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
		if (ret_val > 0)
  40129c:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  4012a0:	7e 49                	jle    4012eb <reg_file_read+0xe1>
		{
			pcb->file_array[fd].file_position += ret_val;		//move the file position to the current position in the file
  4012a2:	8b 1d c0 d0 40 00    	mov    0x40d0c0,%ebx
  4012a8:	8b 75 08             	mov    0x8(%ebp),%esi
  4012ab:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  4012b1:	8b 45 08             	mov    0x8(%ebp),%eax
  4012b4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  4012bb:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  4012c2:	29 d0                	sub    %edx,%eax
  4012c4:	01 c8                	add    %ecx,%eax
  4012c6:	83 c0 10             	add    $0x10,%eax
  4012c9:	8b 40 04             	mov    0x4(%eax),%eax
  4012cc:	89 c1                	mov    %eax,%ecx
  4012ce:	03 4d f0             	add    0xfffffff0(%ebp),%ecx
  4012d1:	89 f0                	mov    %esi,%eax
  4012d3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  4012da:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  4012e1:	29 d0                	sub    %edx,%eax
  4012e3:	01 d8                	add    %ebx,%eax
  4012e5:	83 c0 10             	add    $0x10,%eax
  4012e8:	89 48 04             	mov    %ecx,0x4(%eax)
		}
		else
		{
			// printf("read_data returned value %d\n", ret_val);
		}
		return ret_val;
  4012eb:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  4012ee:	89 45 e0             	mov    %eax,0xffffffe0(%ebp)
  4012f1:	eb 07                	jmp    4012fa <reg_file_read+0xf0>
	}
	// printf("reg_file_read failed because file is not open!\n");
	return -1;
  4012f3:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,0xffffffe0(%ebp)
  4012fa:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
}
  4012fd:	83 c4 24             	add    $0x24,%esp
  401300:	5b                   	pop    %ebx
  401301:	5e                   	pop    %esi
  401302:	5f                   	pop    %edi
  401303:	5d                   	pop    %ebp
  401304:	c3                   	ret    

00401305 <reg_file_write>:

/*
* int32_t reg_file_write (file_struct_t * fs_ptr, void* buf, int32_t nbytes)
*   Inputs: fs_ptr -- Pointer to the file system struct of the file to write.
*			buf -- Buffer with data that needs to be written to file.
*			nbytes -- Number of bytes to write to file.
*   Return Value: int32_t (number of bytes written to file or -1 if failure)
*	Function: Writes nbytes from the buf to the file.
*/
int32_t reg_file_write (int32_t fd, const void* buf, int32_t nbytes)
{
  401305:	55                   	push   %ebp
  401306:	89 e5                	mov    %esp,%ebp
	return -1;
  401308:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  40130d:	5d                   	pop    %ebp
  40130e:	c3                   	ret    

0040130f <reg_file_close>:

/*
* int32_t reg_file_close(int32_t fd)
*   Inputs: fd -- File descriptor of file to close.
*   Return Value: int32_t (0 if success, -1 if failure)
*	Function: Closes the file in the PCB array and makes it available.
*/
int32_t reg_file_close(int32_t fd)
{
  40130f:	55                   	push   %ebp
  401310:	89 e5                	mov    %esp,%ebp
	return 0;
  401312:	b8 00 00 00 00       	mov    $0x0,%eax
}
  401317:	5d                   	pop    %ebp
  401318:	c3                   	ret    

00401319 <dir_open>:

/*
* int32_t dir_open(const uint8_t* dir_name)
*   Inputs: dir_name -- Name of the directory that needs to be opened.
*   Return Value: int32_t (0 if success, -1 if failure)
*	Function: Sets up the file system struct in the PCB for the directory to be opened.
*/
int32_t dir_open(const uint8_t* dir_name)
{
  401319:	55                   	push   %ebp
  40131a:	89 e5                	mov    %esp,%ebp
	return 0;
  40131c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  401321:	5d                   	pop    %ebp
  401322:	c3                   	ret    

00401323 <dir_read>:

/*
* int32_t dir_read (file_struct_t * fs_ptr, void* buf, int32_t nbytes)
*   Inputs: fs_ptr -- Pointer to the file system struct of the directory to read
*			buf -- Buffer to put read filenames in to.
*			nbytes -- Number of bytes to read from file.
*   Return Value: int32_t (number of bytes read from directory or -1 if failure)
*	Function: Reads nbytes of a filename in a directory refered to by fs_ptr and stores them into buf.
*/
int32_t dir_read (int32_t fd, void* buf, int32_t nbytes)
{
  401323:	55                   	push   %ebp
  401324:	89 e5                	mov    %esp,%ebp
  401326:	56                   	push   %esi
  401327:	53                   	push   %ebx
  401328:	83 ec 10             	sub    $0x10,%esp
	if(pcb->file_array[fd].flags == (TYPE_DIR & OPEN))
  40132b:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  401331:	8b 45 08             	mov    0x8(%ebp),%eax
  401334:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  40133b:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  401342:	29 d0                	sub    %edx,%eax
  401344:	01 c8                	add    %ecx,%eax
  401346:	83 c0 10             	add    $0x10,%eax
  401349:	8b 40 08             	mov    0x8(%eax),%eax
  40134c:	85 c0                	test   %eax,%eax
  40134e:	0f 85 e5 00 00 00    	jne    401439 <dir_read+0x116>
	{
		if (strncmp("", bblock->dentry[pcb->file_array[fd].file_position].file_name, nbytes) == 0) //check if reached end of directory
  401354:	8b 5d 10             	mov    0x10(%ebp),%ebx
  401357:	8b 35 c8 d0 40 00    	mov    0x40d0c8,%esi
  40135d:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  401363:	8b 45 08             	mov    0x8(%ebp),%eax
  401366:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  40136d:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  401374:	29 d0                	sub    %edx,%eax
  401376:	01 c8                	add    %ecx,%eax
  401378:	83 c0 10             	add    $0x10,%eax
  40137b:	8b 40 04             	mov    0x4(%eax),%eax
  40137e:	c1 e0 06             	shl    $0x6,%eax
  401381:	83 c0 40             	add    $0x40,%eax
  401384:	8d 04 06             	lea    (%esi,%eax,1),%eax
  401387:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  40138b:	89 44 24 04          	mov    %eax,0x4(%esp)
  40138f:	c7 04 24 22 40 40 00 	movl   $0x404022,(%esp)
  401396:	e8 ff 1c 00 00       	call   40309a <strncmp>
  40139b:	85 c0                	test   %eax,%eax
  40139d:	75 0c                	jne    4013ab <dir_read+0x88>
		{
			return 0;
  40139f:	c7 45 f4 00 00 00 00 	movl   $0x0,0xfffffff4(%ebp)
  4013a6:	e9 95 00 00 00       	jmp    401440 <dir_read+0x11d>
		}
		else
		{
			strncpy(buf, bblock->dentry[pcb->file_array[fd].file_position].file_name, nbytes);	//store filename up to nbytes into the buffer
  4013ab:	8b 5d 10             	mov    0x10(%ebp),%ebx
  4013ae:	8b 35 c8 d0 40 00    	mov    0x40d0c8,%esi
  4013b4:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  4013ba:	8b 45 08             	mov    0x8(%ebp),%eax
  4013bd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  4013c4:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  4013cb:	29 d0                	sub    %edx,%eax
  4013cd:	01 c8                	add    %ecx,%eax
  4013cf:	83 c0 10             	add    $0x10,%eax
  4013d2:	8b 40 04             	mov    0x4(%eax),%eax
  4013d5:	c1 e0 06             	shl    $0x6,%eax
  4013d8:	83 c0 40             	add    $0x40,%eax
  4013db:	8d 04 06             	lea    (%esi,%eax,1),%eax
  4013de:	8b 55 0c             	mov    0xc(%ebp),%edx
  4013e1:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  4013e5:	89 44 24 04          	mov    %eax,0x4(%esp)
  4013e9:	89 14 24             	mov    %edx,(%esp)
  4013ec:	e8 55 1d 00 00       	call   403146 <strncpy>
			pcb->file_array[fd].file_position++;
  4013f1:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  4013f7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  4013fa:	89 d8                	mov    %ebx,%eax
  4013fc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  401403:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  40140a:	29 d0                	sub    %edx,%eax
  40140c:	01 c8                	add    %ecx,%eax
  40140e:	83 c0 10             	add    $0x10,%eax
  401411:	8b 40 04             	mov    0x4(%eax),%eax
  401414:	8d 70 01             	lea    0x1(%eax),%esi
  401417:	89 d8                	mov    %ebx,%eax
  401419:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  401420:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  401427:	29 d0                	sub    %edx,%eax
  401429:	01 c8                	add    %ecx,%eax
  40142b:	83 c0 10             	add    $0x10,%eax
  40142e:	89 70 04             	mov    %esi,0x4(%eax)
			return nbytes;
  401431:	8b 45 10             	mov    0x10(%ebp),%eax
  401434:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  401437:	eb 07                	jmp    401440 <dir_read+0x11d>
		}
	}
	// printf("reg_file_read failed because directory is not open!\n");
	return -1;
  401439:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,0xfffffff4(%ebp)
  401440:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
}
  401443:	83 c4 10             	add    $0x10,%esp
  401446:	5b                   	pop    %ebx
  401447:	5e                   	pop    %esi
  401448:	5d                   	pop    %ebp
  401449:	c3                   	ret    

0040144a <dir_write>:

/*
* int32_t dir_write (file_struct_t * fs_ptr, void* buf, int32_t nbytes)
*   Inputs: fs_ptr -- Pointer to the file system struct of the directory to write.
*			buf -- Buffer with data that needs to be written to directory.
*			nbytes -- Number of bytes to write to the directory.
*   Return Value: int32_t (number of bytes written to file or -1 if failure)
*	Function: Writes nbytes from the buf to the directory.
*/
int32_t dir_write (int32_t fd, const void* buf, int32_t nbytes)
{
  40144a:	55                   	push   %ebp
  40144b:	89 e5                	mov    %esp,%ebp
	return -1;
  40144d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  401452:	5d                   	pop    %ebp
  401453:	c3                   	ret    

00401454 <dir_close>:

/*
* int32_t dir_close(int32_t fd)
*   Inputs: fd -- File descriptor of directory to close.
*   Return Value: int32_t (0 if success, -1 if failure)
*	Function: Closes the directory in the PCB array and makes it available.
*/
int32_t dir_close(int32_t fd)
{
  401454:	55                   	push   %ebp
  401455:	89 e5                	mov    %esp,%ebp
	return 0;
  401457:	b8 00 00 00 00       	mov    $0x0,%eax
}
  40145c:	5d                   	pop    %ebp
  40145d:	c3                   	ret    
  40145e:	90                   	nop    
  40145f:	90                   	nop    

00401460 <i8259_init>:
 *	Function: Initializes the 8259 PIC
 */
void
i8259_init(void)
{
  401460:	55                   	push   %ebp
  401461:	89 e5                	mov    %esp,%ebp
  401463:	83 ec 10             	sub    $0x10,%esp
	/*first create a variable to hold the flags then lock by using the given ways to stops interrupts*/
	uint32_t flags;
	cli_and_save(flags);
  401466:	9c                   	pushf  
  401467:	58                   	pop    %eax
  401468:	fa                   	cli    
  401469:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

	/*mask all interrupts by setting all bit in IMR for both master and slave PIC*/
	outb(DISABLE, MASTER_PORT_DATA);
  40146c:	ba 21 00 00 00       	mov    $0x21,%edx
  401471:	b8 ff 00 00 00       	mov    $0xff,%eax
  401476:	ee                   	out    %al,(%dx)
	outb(DISABLE, SLAVE_PORT_DATA);
  401477:	ba a1 00 00 00       	mov    $0xa1,%edx
  40147c:	b8 ff 00 00 00       	mov    $0xff,%eax
  401481:	ee                   	out    %al,(%dx)

	/*send the ICWs to the PIC for init*/
	//send first word
	outb(ICW1, MASTER_8259_PORT);
  401482:	ba 20 00 00 00       	mov    $0x20,%edx
  401487:	b8 11 00 00 00       	mov    $0x11,%eax
  40148c:	ee                   	out    %al,(%dx)
	outb(ICW1, SLAVE_8259_PORT);
  40148d:	ba a0 00 00 00       	mov    $0xa0,%edx
  401492:	b8 11 00 00 00       	mov    $0x11,%eax
  401497:	ee                   	out    %al,(%dx)
	//send secondword
	outb(ICW2_MASTER, MASTER_PORT_DATA);
  401498:	ba 21 00 00 00       	mov    $0x21,%edx
  40149d:	b8 20 00 00 00       	mov    $0x20,%eax
  4014a2:	ee                   	out    %al,(%dx)
	outb(ICW2_SLAVE, SLAVE_PORT_DATA);
  4014a3:	ba a1 00 00 00       	mov    $0xa1,%edx
  4014a8:	b8 28 00 00 00       	mov    $0x28,%eax
  4014ad:	ee                   	out    %al,(%dx)
	//send third word
	outb(ICW3_MASTER, MASTER_PORT_DATA);
  4014ae:	ba 21 00 00 00       	mov    $0x21,%edx
  4014b3:	b8 04 00 00 00       	mov    $0x4,%eax
  4014b8:	ee                   	out    %al,(%dx)
	outb(ICW3_SLAVE, SLAVE_PORT_DATA);
  4014b9:	ba a1 00 00 00       	mov    $0xa1,%edx
  4014be:	b8 02 00 00 00       	mov    $0x2,%eax
  4014c3:	ee                   	out    %al,(%dx)
	//send 4th word
	outb(ICW4, MASTER_PORT_DATA);
  4014c4:	ba 21 00 00 00       	mov    $0x21,%edx
  4014c9:	b8 01 00 00 00       	mov    $0x1,%eax
  4014ce:	ee                   	out    %al,(%dx)
	outb(ICW4, SLAVE_PORT_DATA);
  4014cf:	ba a1 00 00 00       	mov    $0xa1,%edx
  4014d4:	b8 01 00 00 00       	mov    $0x1,%eax
  4014d9:	ee                   	out    %al,(%dx)

	/*mask all interrupts by setting all bit in IMR for both master and slave PIC*/
	outb(DISABLE, MASTER_PORT_DATA);
  4014da:	ba 21 00 00 00       	mov    $0x21,%edx
  4014df:	b8 ff 00 00 00       	mov    $0xff,%eax
  4014e4:	ee                   	out    %al,(%dx)
	outb(DISABLE, SLAVE_PORT_DATA);	
  4014e5:	ba a1 00 00 00       	mov    $0xa1,%edx
  4014ea:	b8 ff 00 00 00       	mov    $0xff,%eax
  4014ef:	ee                   	out    %al,(%dx)

	//sti();
	restore_flags(flags);
  4014f0:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  4014f3:	50                   	push   %eax
  4014f4:	9d                   	popf   
	
}
  4014f5:	c9                   	leave  
  4014f6:	c3                   	ret    

004014f7 <enable_irq>:

/*
 * void enable_irq(uint32_t irq_num)
 *   Inputs: IRQ line to enable (unmask)
 *   Return Value: void
 *	Function: Enable (unmask) the specified IRQ
 */
void
enable_irq(uint32_t irq_num)
{
  4014f7:	55                   	push   %ebp
  4014f8:	89 e5                	mov    %esp,%ebp
  4014fa:	83 ec 18             	sub    $0x18,%esp
	uint8_t tmp;
	uint8_t unmask;
	if((irq_num >= 8)&&(irq_num < 16)) {		//check if irq_num is within the bounds of 0-15 (Master: lines 0-7, Slave: lines 8-15)
  4014fd:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
  401501:	76 3e                	jbe    401541 <enable_irq+0x4a>
  401503:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
  401507:	77 38                	ja     401541 <enable_irq+0x4a>
		irq_num -= 8;							//get the correct IRQ on the IMR for the slave PIC
  401509:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
		tmp = 1<<irq_num;						//left shift the amount needed to make to correct bit unmask the IRQ on the IMR
  40150d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  401510:	b8 01 00 00 00       	mov    $0x1,%eax
  401515:	d3 e0                	shl    %cl,%eax
  401517:	88 45 fe             	mov    %al,0xfffffffe(%ebp)
		tmp = ~tmp;								//must do this to make that bit zero and the rest one to not change the rest of the IMR
  40151a:	0f b6 45 fe          	movzbl 0xfffffffe(%ebp),%eax
  40151e:	f7 d0                	not    %eax
  401520:	88 45 fe             	mov    %al,0xfffffffe(%ebp)
		unmask = inb(SLAVE_PORT_DATA)&tmp;		//get original IMR from slave and bitwise AND with the bit we want to enable
  401523:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  40152a:	e8 4c 00 00 00       	call   40157b <inb>
  40152f:	22 45 fe             	and    0xfffffffe(%ebp),%al
  401532:	88 45 ff             	mov    %al,0xffffffff(%ebp)
		outb(unmask, SLAVE_PORT_DATA);
  401535:	ba a1 00 00 00       	mov    $0xa1,%edx
  40153a:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  40153e:	ee                   	out    %al,(%dx)
  40153f:	eb 38                	jmp    401579 <enable_irq+0x82>
	}
	else if((irq_num >= 0)&&(irq_num < 8)){		//make sure the irq_num is within the bounds
  401541:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
  401545:	77 32                	ja     401579 <enable_irq+0x82>
		/*do not need to subtract here since it is already between 0-7 also same steps as above*/
		tmp = 1<<irq_num;
  401547:	8b 4d 08             	mov    0x8(%ebp),%ecx
  40154a:	b8 01 00 00 00       	mov    $0x1,%eax
  40154f:	d3 e0                	shl    %cl,%eax
  401551:	88 45 fe             	mov    %al,0xfffffffe(%ebp)
		tmp = ~tmp;
  401554:	0f b6 45 fe          	movzbl 0xfffffffe(%ebp),%eax
  401558:	f7 d0                	not    %eax
  40155a:	88 45 fe             	mov    %al,0xfffffffe(%ebp)
		unmask = inb(MASTER_PORT_DATA)&tmp;		//same but for master PIC
  40155d:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  401564:	e8 12 00 00 00       	call   40157b <inb>
  401569:	22 45 fe             	and    0xfffffffe(%ebp),%al
  40156c:	88 45 ff             	mov    %al,0xffffffff(%ebp)
		outb(unmask, MASTER_PORT_DATA);
  40156f:	ba 21 00 00 00       	mov    $0x21,%edx
  401574:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  401578:	ee                   	out    %al,(%dx)
	}
}
  401579:	c9                   	leave  
  40157a:	c3                   	ret    

0040157b <inb>:
/* Port read functions */
/* Inb reads a byte and returns its value as a zero-extended 32-bit
 * unsigned int */
static inline uint32_t inb(port)
{
  40157b:	55                   	push   %ebp
  40157c:	89 e5                	mov    %esp,%ebp
  40157e:	83 ec 10             	sub    $0x10,%esp
	uint32_t val;
	asm volatile("xorl %0, %0\n \
  401581:	8b 55 08             	mov    0x8(%ebp),%edx
  401584:	31 c0                	xor    %eax,%eax
  401586:	ec                   	in     (%dx),%al
  401587:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
			inb   (%w1), %b0"
			: "=a"(val)
			: "d"(port)
			: "memory" );
	return val;
  40158a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  40158d:	c9                   	leave  
  40158e:	c3                   	ret    

0040158f <disable_irq>:

/*
 * void disable_irq(uint32_t irq_num)
 *   Inputs: IRQ line to disable (mask)
 *   Return Value: void
 *	Function: Disable (mask) the specified IRQ
 */
void
disable_irq(uint32_t irq_num)
{
  40158f:	55                   	push   %ebp
  401590:	89 e5                	mov    %esp,%ebp
  401592:	83 ec 14             	sub    $0x14,%esp
	uint8_t mask;
	if((irq_num >= 8)&&(irq_num < 16)){				//check if irq_num is within the bounds of 0-15 (Master: lines 0-7, Slave: lines 8-15)
  401595:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
  401599:	76 33                	jbe    4015ce <disable_irq+0x3f>
  40159b:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
  40159f:	77 2d                	ja     4015ce <disable_irq+0x3f>
		irq_num -= 8;								//get correct IRQ num for slave
  4015a1:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
		mask = inb(SLAVE_PORT_DATA)|(1<<irq_num);	//get IMR currently on slave and bitwise OR with the bit we want to mask
  4015a5:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  4015ac:	e8 ca ff ff ff       	call   40157b <inb>
  4015b1:	89 c2                	mov    %eax,%edx
  4015b3:	8b 4d 08             	mov    0x8(%ebp),%ecx
  4015b6:	b8 01 00 00 00       	mov    $0x1,%eax
  4015bb:	d3 e0                	shl    %cl,%eax
  4015bd:	09 d0                	or     %edx,%eax
  4015bf:	88 45 ff             	mov    %al,0xffffffff(%ebp)
		outb(mask, SLAVE_PORT_DATA);
  4015c2:	ba a1 00 00 00       	mov    $0xa1,%edx
  4015c7:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  4015cb:	ee                   	out    %al,(%dx)
  4015cc:	eb 2d                	jmp    4015fb <disable_irq+0x6c>
	}
	else if((irq_num >= 0)&&(irq_num < 8)){			//make sure the irq_num is within the bounds
  4015ce:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
  4015d2:	77 27                	ja     4015fb <disable_irq+0x6c>
		/*Do not to change irq_num and everything here is the same as that in the first if statement*/
		mask = inb(MASTER_PORT_DATA)|(1<<irq_num);	//get IMR currently on master and bitwise OR with the bit we want to mask
  4015d4:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  4015db:	e8 9b ff ff ff       	call   40157b <inb>
  4015e0:	89 c2                	mov    %eax,%edx
  4015e2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  4015e5:	b8 01 00 00 00       	mov    $0x1,%eax
  4015ea:	d3 e0                	shl    %cl,%eax
  4015ec:	09 d0                	or     %edx,%eax
  4015ee:	88 45 ff             	mov    %al,0xffffffff(%ebp)
		outb(mask, MASTER_PORT_DATA);
  4015f1:	ba 21 00 00 00       	mov    $0x21,%edx
  4015f6:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  4015fa:	ee                   	out    %al,(%dx)
	}
}
  4015fb:	c9                   	leave  
  4015fc:	c3                   	ret    

004015fd <send_eoi>:

/*
 * void send_eoi(uint32_t irq_num)
 *   Inputs: IRQ line to send EOI
 *   Return Value: void
 *	Function: Send end-of-interrupt signal for the specified IRQ
 */
void
send_eoi(uint32_t irq_num)
{
  4015fd:	55                   	push   %ebp
  4015fe:	89 e5                	mov    %esp,%ebp
  401600:	83 ec 10             	sub    $0x10,%esp
	uint8_t eoiSig;
	if((irq_num >= 0)&&(irq_num < 16)){	//check if irq_num is within the bounds of 0-15 (Master: lines 0-7, Slave: lines 8-15)
  401603:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
  401607:	77 36                	ja     40163f <send_eoi+0x42>
		if(irq_num >= 8){				// check if slave (lines 8-15)
  401609:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
  40160d:	76 1d                	jbe    40162c <send_eoi+0x2f>
			irq_num -= 8;				//get correct IRQ num for slave
  40160f:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
			eoiSig = EOI|irq_num;
  401613:	8b 45 08             	mov    0x8(%ebp),%eax
  401616:	83 c8 60             	or     $0x60,%eax
  401619:	88 45 ff             	mov    %al,0xffffffff(%ebp)
			outb(eoiSig, SLAVE_8259_PORT);
  40161c:	ba a0 00 00 00       	mov    $0xa0,%edx
  401621:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  401625:	ee                   	out    %al,(%dx)
			eoiSig = EOI|2; // now send EOI to the master for IR 2
  401626:	c6 45 ff 62          	movb   $0x62,0xffffffff(%ebp)
  40162a:	eb 09                	jmp    401635 <send_eoi+0x38>
		} else {
			//have to send to both when in cascade mode
			eoiSig = EOI|irq_num;
  40162c:	8b 45 08             	mov    0x8(%ebp),%eax
  40162f:	83 c8 60             	or     $0x60,%eax
  401632:	88 45 ff             	mov    %al,0xffffffff(%ebp)
		}

		outb(eoiSig, MASTER_8259_PORT);
  401635:	ba 20 00 00 00       	mov    $0x20,%edx
  40163a:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  40163e:	ee                   	out    %al,(%dx)
	}
}
  40163f:	c9                   	leave  
  401640:	c3                   	ret    
  401641:	90                   	nop    
  401642:	90                   	nop    
  401643:	90                   	nop    

00401644 <entry>:
/* Check if MAGIC is valid and print the Multiboot information structure
   pointed by ADDR. */
void
entry (unsigned long magic, unsigned long addr)
{
  401644:	55                   	push   %ebp
  401645:	89 e5                	mov    %esp,%ebp
  401647:	57                   	push   %edi
  401648:	56                   	push   %esi
  401649:	53                   	push   %ebx
  40164a:	83 ec 4c             	sub    $0x4c,%esp
	multiboot_info_t *mbi;

	/* Clear the screen. */
	clear();
  40164d:	e8 a2 12 00 00       	call   4028f4 <clear>

	/* Am I booted by a Multiboot-compliant boot loader? */
	if (magic != MULTIBOOT_BOOTLOADER_MAGIC)
  401652:	81 7d 08 02 b0 ad 2b 	cmpl   $0x2badb002,0x8(%ebp)
  401659:	74 18                	je     401673 <entry+0x2f>
	{
		printf ("Invalid magic number: 0x%#x\n", (unsigned) magic);
  40165b:	8b 45 08             	mov    0x8(%ebp),%eax
  40165e:	89 44 24 04          	mov    %eax,0x4(%esp)
  401662:	c7 04 24 24 40 40 00 	movl   $0x404024,(%esp)
  401669:	e8 3f 14 00 00       	call   402aad <printf>
		return;
  40166e:	e9 73 09 00 00       	jmp    401fe6 <.1+0x3>
	}

	/* Set MBI to the address of the Multiboot information structure. */
	mbi = (multiboot_info_t *) addr;
  401673:	8b 45 0c             	mov    0xc(%ebp),%eax
  401676:	89 45 d8             	mov    %eax,0xffffffd8(%ebp)

	/* Print out the flags. */
	printf ("flags = 0x%#x\n", (unsigned) mbi->flags);
  401679:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  40167c:	8b 00                	mov    (%eax),%eax
  40167e:	89 44 24 04          	mov    %eax,0x4(%esp)
  401682:	c7 04 24 41 40 40 00 	movl   $0x404041,(%esp)
  401689:	e8 1f 14 00 00       	call   402aad <printf>

	/* Are mem_* valid? */
	if (CHECK_FLAG (mbi->flags, 0))
  40168e:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  401691:	8b 00                	mov    (%eax),%eax
  401693:	83 e0 01             	and    $0x1,%eax
  401696:	84 c0                	test   %al,%al
  401698:	74 20                	je     4016ba <entry+0x76>
		printf ("mem_lower = %uKB, mem_upper = %uKB\n",
  40169a:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  40169d:	8b 50 08             	mov    0x8(%eax),%edx
  4016a0:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  4016a3:	8b 40 04             	mov    0x4(%eax),%eax
  4016a6:	89 54 24 08          	mov    %edx,0x8(%esp)
  4016aa:	89 44 24 04          	mov    %eax,0x4(%esp)
  4016ae:	c7 04 24 50 40 40 00 	movl   $0x404050,(%esp)
  4016b5:	e8 f3 13 00 00       	call   402aad <printf>
				(unsigned) mbi->mem_lower, (unsigned) mbi->mem_upper);

	/* Is boot_device valid? */
	if (CHECK_FLAG (mbi->flags, 1))
  4016ba:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  4016bd:	8b 00                	mov    (%eax),%eax
  4016bf:	83 e0 02             	and    $0x2,%eax
  4016c2:	85 c0                	test   %eax,%eax
  4016c4:	74 16                	je     4016dc <entry+0x98>
		printf ("boot_device = 0x%#x\n", (unsigned) mbi->boot_device);
  4016c6:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  4016c9:	8b 40 0c             	mov    0xc(%eax),%eax
  4016cc:	89 44 24 04          	mov    %eax,0x4(%esp)
  4016d0:	c7 04 24 74 40 40 00 	movl   $0x404074,(%esp)
  4016d7:	e8 d1 13 00 00       	call   402aad <printf>

	/* Is the command line passed? */
	if (CHECK_FLAG (mbi->flags, 2))
  4016dc:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  4016df:	8b 00                	mov    (%eax),%eax
  4016e1:	83 e0 04             	and    $0x4,%eax
  4016e4:	85 c0                	test   %eax,%eax
  4016e6:	74 16                	je     4016fe <entry+0xba>
		printf ("cmdline = %s\n", (char *) mbi->cmdline);
  4016e8:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  4016eb:	8b 40 10             	mov    0x10(%eax),%eax
  4016ee:	89 44 24 04          	mov    %eax,0x4(%esp)
  4016f2:	c7 04 24 89 40 40 00 	movl   $0x404089,(%esp)
  4016f9:	e8 af 13 00 00       	call   402aad <printf>

	if (CHECK_FLAG (mbi->flags, 3)) {
  4016fe:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  401701:	8b 00                	mov    (%eax),%eax
  401703:	83 e0 08             	and    $0x8,%eax
  401706:	85 c0                	test   %eax,%eax
  401708:	0f 84 d0 00 00 00    	je     4017de <entry+0x19a>
		int mod_count = 0;
  40170e:	c7 45 e0 00 00 00 00 	movl   $0x0,0xffffffe0(%ebp)
		int i;
		module_t* mod = (module_t*)mbi->mods_addr;
  401715:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  401718:	8b 40 18             	mov    0x18(%eax),%eax
  40171b:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)
		while(mod_count < mbi->mods_count) {
  40171e:	e9 aa 00 00 00       	jmp    4017cd <entry+0x189>
			printf("string in module %d is : %s\n", mod_count, mod->string);
  401723:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  401726:	8b 40 08             	mov    0x8(%eax),%eax
  401729:	89 44 24 08          	mov    %eax,0x8(%esp)
  40172d:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  401730:	89 44 24 04          	mov    %eax,0x4(%esp)
  401734:	c7 04 24 97 40 40 00 	movl   $0x404097,(%esp)
  40173b:	e8 6d 13 00 00       	call   402aad <printf>
			printf("Module %d loaded at address: 0x%#x\n", mod_count, (unsigned int)mod->mod_start);
  401740:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  401743:	8b 00                	mov    (%eax),%eax
  401745:	89 44 24 08          	mov    %eax,0x8(%esp)
  401749:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  40174c:	89 44 24 04          	mov    %eax,0x4(%esp)
  401750:	c7 04 24 b4 40 40 00 	movl   $0x4040b4,(%esp)
  401757:	e8 51 13 00 00       	call   402aad <printf>
			printf("Module %d ends at address: 0x%#x\n", mod_count, (unsigned int)mod->mod_end);
  40175c:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  40175f:	8b 40 04             	mov    0x4(%eax),%eax
  401762:	89 44 24 08          	mov    %eax,0x8(%esp)
  401766:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  401769:	89 44 24 04          	mov    %eax,0x4(%esp)
  40176d:	c7 04 24 d8 40 40 00 	movl   $0x4040d8,(%esp)
  401774:	e8 34 13 00 00       	call   402aad <printf>
			printf("First few bytes of module:\n");
  401779:	c7 04 24 fa 40 40 00 	movl   $0x4040fa,(%esp)
  401780:	e8 28 13 00 00       	call   402aad <printf>
			for(i = 0; i<16; i++) {
  401785:	c7 45 e4 00 00 00 00 	movl   $0x0,0xffffffe4(%ebp)
  40178c:	eb 25                	jmp    4017b3 <entry+0x16f>
				printf("0x%x ", *((char*)(mod->mod_start+i)));
  40178e:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  401791:	8b 10                	mov    (%eax),%edx
  401793:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  401796:	8d 04 02             	lea    (%edx,%eax,1),%eax
  401799:	0f b6 00             	movzbl (%eax),%eax
  40179c:	0f be c0             	movsbl %al,%eax
  40179f:	89 44 24 04          	mov    %eax,0x4(%esp)
  4017a3:	c7 04 24 16 41 40 00 	movl   $0x404116,(%esp)
  4017aa:	e8 fe 12 00 00       	call   402aad <printf>
  4017af:	83 45 e4 01          	addl   $0x1,0xffffffe4(%ebp)
  4017b3:	83 7d e4 0f          	cmpl   $0xf,0xffffffe4(%ebp)
  4017b7:	7e d5                	jle    40178e <entry+0x14a>
			}
			printf("\n");
  4017b9:	c7 04 24 1c 41 40 00 	movl   $0x40411c,(%esp)
  4017c0:	e8 e8 12 00 00       	call   402aad <printf>
			mod_count++;
  4017c5:	83 45 e0 01          	addl   $0x1,0xffffffe0(%ebp)
			mod++;
  4017c9:	83 45 e8 10          	addl   $0x10,0xffffffe8(%ebp)
  4017cd:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  4017d0:	8b 55 d8             	mov    0xffffffd8(%ebp),%edx
  4017d3:	8b 52 14             	mov    0x14(%edx),%edx
  4017d6:	39 d0                	cmp    %edx,%eax
  4017d8:	0f 82 45 ff ff ff    	jb     401723 <entry+0xdf>
		}
	}

	/* Start of fs test functions */

	// clear();
	// test_reg_file_open((uint8_t *)"shell");

	// WARNING: test_reg_file_open must return successfully before running this function"
	//clear();
	// printf("%c\n", 0x01);
	// test_reg_file_read (&fs_test, 100000);

	// WARNING: test_reg_file_open must return successfully before running this function"
	// clear();
	// test_reg_file_write (&fs_test, "test!", 1);

	// WARNING: test_reg_file_open must return successfully before running this function"
	// clear();
	// test_reg_file_close (2);

	// clear();
	// test_dir_open((uint8_t *)".");

	// WARNING: test_dir_open must return successfully before running this function"
	// clear();
	// test_dir_read (&fs_test, 32, 20);

	// WARNING: test_dir_open must return successfully before running this function"
	// clear();
	// test_dir_write (&fs_test, "test!", 1);

	// WARNING: test_dir_open must return successfully before running this function"
	// clear();
	// test_dir_close (2);

	// clear();
	// unit_test_read_dentry_filename((uint8_t *)"shell");

	// clear();
	// unit_test_read_dentry_inode(10000);
	// unit_test_read_dentry_inode(0);

	// clear();
	// unit_test_read_data(0);

	// /* print all files in the directory, plus their inodes */
	// clear();
	// test_fs_print_filenames(1);

	// /* print the size of sigtest */
	// clear();
	// printf("size of sigtest:\n");
	// test_fs_print_filesize(1);
	// asm volatile(".2: hlt; jmp .2;"); // comment this after testing fs
	/* End of fs test functions */

	/*Test terminal*/
	//printf("Testing Terminal Read");
	//test_term_read();

	/* Bits 4 and 5 are mutually exclusive! */
	if (CHECK_FLAG (mbi->flags, 4) && CHECK_FLAG (mbi->flags, 5))
  4017de:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  4017e1:	8b 00                	mov    (%eax),%eax
  4017e3:	83 e0 10             	and    $0x10,%eax
  4017e6:	85 c0                	test   %eax,%eax
  4017e8:	74 1d                	je     401807 <entry+0x1c3>
  4017ea:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  4017ed:	8b 00                	mov    (%eax),%eax
  4017ef:	83 e0 20             	and    $0x20,%eax
  4017f2:	85 c0                	test   %eax,%eax
  4017f4:	74 11                	je     401807 <entry+0x1c3>
	{
		printf ("Both bits 4 and 5 are set.\n");
  4017f6:	c7 04 24 1e 41 40 00 	movl   $0x40411e,(%esp)
  4017fd:	e8 ab 12 00 00       	call   402aad <printf>
		return;
  401802:	e9 df 07 00 00       	jmp    401fe6 <.1+0x3>
	}

	/* Is the section header table of ELF valid? */
	if (CHECK_FLAG (mbi->flags, 5))
  401807:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  40180a:	8b 00                	mov    (%eax),%eax
  40180c:	83 e0 20             	and    $0x20,%eax
  40180f:	85 c0                	test   %eax,%eax
  401811:	74 3c                	je     40184f <entry+0x20b>
	{
		elf_section_header_table_t *elf_sec = &(mbi->elf_sec);
  401813:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  401816:	83 c0 1c             	add    $0x1c,%eax
  401819:	89 45 ec             	mov    %eax,0xffffffec(%ebp)

		printf ("elf_sec: num = %u, size = 0x%#x,"
  40181c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  40181f:	8b 48 0c             	mov    0xc(%eax),%ecx
  401822:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  401825:	8b 58 08             	mov    0x8(%eax),%ebx
  401828:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  40182b:	8b 50 04             	mov    0x4(%eax),%edx
  40182e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  401831:	8b 00                	mov    (%eax),%eax
  401833:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  401837:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  40183b:	89 54 24 08          	mov    %edx,0x8(%esp)
  40183f:	89 44 24 04          	mov    %eax,0x4(%esp)
  401843:	c7 04 24 3c 41 40 00 	movl   $0x40413c,(%esp)
  40184a:	e8 5e 12 00 00       	call   402aad <printf>
				" addr = 0x%#x, shndx = 0x%#x\n",
				(unsigned) elf_sec->num, (unsigned) elf_sec->size,
				(unsigned) elf_sec->addr, (unsigned) elf_sec->shndx);
	}

	/* Are mmap_* valid? */
	if (CHECK_FLAG (mbi->flags, 6))
  40184f:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  401852:	8b 00                	mov    (%eax),%eax
  401854:	83 e0 40             	and    $0x40,%eax
  401857:	85 c0                	test   %eax,%eax
  401859:	0f 84 9b 00 00 00    	je     4018fa <entry+0x2b6>
	{
		memory_map_t *mmap;

		printf ("mmap_addr = 0x%#x, mmap_length = 0x%x\n",
  40185f:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  401862:	8b 50 2c             	mov    0x2c(%eax),%edx
  401865:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  401868:	8b 40 30             	mov    0x30(%eax),%eax
  40186b:	89 54 24 08          	mov    %edx,0x8(%esp)
  40186f:	89 44 24 04          	mov    %eax,0x4(%esp)
  401873:	c7 04 24 7c 41 40 00 	movl   $0x40417c,(%esp)
  40187a:	e8 2e 12 00 00       	call   402aad <printf>
				(unsigned) mbi->mmap_addr, (unsigned) mbi->mmap_length);
		for (mmap = (memory_map_t *) mbi->mmap_addr;
  40187f:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  401882:	8b 40 30             	mov    0x30(%eax),%eax
  401885:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
				(unsigned long) mmap < mbi->mmap_addr + mbi->mmap_length;
  401888:	eb 58                	jmp    4018e2 <entry+0x29e>
				mmap = (memory_map_t *) ((unsigned long) mmap
					+ mmap->size + sizeof (mmap->size)))
			printf (" size = 0x%x,     base_addr = 0x%#x%#x\n"
  40188a:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  40188d:	8b 78 0c             	mov    0xc(%eax),%edi
  401890:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  401893:	8b 50 10             	mov    0x10(%eax),%edx
  401896:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  401899:	8b 48 14             	mov    0x14(%eax),%ecx
  40189c:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  40189f:	8b 58 04             	mov    0x4(%eax),%ebx
  4018a2:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  4018a5:	8b 70 08             	mov    0x8(%eax),%esi
  4018a8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  4018ab:	8b 00                	mov    (%eax),%eax
  4018ad:	89 7c 24 18          	mov    %edi,0x18(%esp)
  4018b1:	89 54 24 14          	mov    %edx,0x14(%esp)
  4018b5:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  4018b9:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  4018bd:	89 74 24 08          	mov    %esi,0x8(%esp)
  4018c1:	89 44 24 04          	mov    %eax,0x4(%esp)
  4018c5:	c7 04 24 a4 41 40 00 	movl   $0x4041a4,(%esp)
  4018cc:	e8 dc 11 00 00       	call   402aad <printf>
  4018d1:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  4018d4:	8b 10                	mov    (%eax),%edx
  4018d6:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  4018d9:	8d 04 02             	lea    (%edx,%eax,1),%eax
  4018dc:	83 c0 04             	add    $0x4,%eax
  4018df:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
  4018e2:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  4018e5:	89 c1                	mov    %eax,%ecx
  4018e7:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  4018ea:	8b 50 30             	mov    0x30(%eax),%edx
  4018ed:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  4018f0:	8b 40 2c             	mov    0x2c(%eax),%eax
  4018f3:	8d 04 02             	lea    (%edx,%eax,1),%eax
  4018f6:	39 c1                	cmp    %eax,%ecx
  4018f8:	72 90                	jb     40188a <entry+0x246>
					"     type = 0x%x,  length    = 0x%#x%#x\n",
					(unsigned) mmap->size,
					(unsigned) mmap->base_addr_high,
					(unsigned) mmap->base_addr_low,
					(unsigned) mmap->type,
					(unsigned) mmap->length_high,
					(unsigned) mmap->length_low);
	}

	/* Construct an LDT entry in the GDT */
	{
		seg_desc_t the_ldt_desc;
		the_ldt_desc.granularity    = 0;
  4018fa:	0f b6 45 d6          	movzbl 0xffffffd6(%ebp),%eax
  4018fe:	83 e0 7f             	and    $0x7f,%eax
  401901:	88 45 d6             	mov    %al,0xffffffd6(%ebp)
		the_ldt_desc.opsize         = 1;
  401904:	0f b6 45 d6          	movzbl 0xffffffd6(%ebp),%eax
  401908:	83 c8 40             	or     $0x40,%eax
  40190b:	88 45 d6             	mov    %al,0xffffffd6(%ebp)
		the_ldt_desc.reserved       = 0;
  40190e:	0f b6 45 d6          	movzbl 0xffffffd6(%ebp),%eax
  401912:	83 e0 df             	and    $0xffffffdf,%eax
  401915:	88 45 d6             	mov    %al,0xffffffd6(%ebp)
		the_ldt_desc.avail          = 0;
  401918:	0f b6 45 d6          	movzbl 0xffffffd6(%ebp),%eax
  40191c:	83 e0 ef             	and    $0xffffffef,%eax
  40191f:	88 45 d6             	mov    %al,0xffffffd6(%ebp)
		the_ldt_desc.present        = 1;
  401922:	0f b6 45 d5          	movzbl 0xffffffd5(%ebp),%eax
  401926:	83 c8 80             	or     $0xffffff80,%eax
  401929:	88 45 d5             	mov    %al,0xffffffd5(%ebp)
		the_ldt_desc.dpl            = 0x0;
  40192c:	0f b6 45 d5          	movzbl 0xffffffd5(%ebp),%eax
  401930:	83 e0 9f             	and    $0xffffff9f,%eax
  401933:	88 45 d5             	mov    %al,0xffffffd5(%ebp)
		the_ldt_desc.sys            = 0;
  401936:	0f b6 45 d5          	movzbl 0xffffffd5(%ebp),%eax
  40193a:	83 e0 ef             	and    $0xffffffef,%eax
  40193d:	88 45 d5             	mov    %al,0xffffffd5(%ebp)
		the_ldt_desc.type           = 0x2;
  401940:	0f b6 45 d5          	movzbl 0xffffffd5(%ebp),%eax
  401944:	83 e0 f0             	and    $0xfffffff0,%eax
  401947:	83 c8 02             	or     $0x2,%eax
  40194a:	88 45 d5             	mov    %al,0xffffffd5(%ebp)

		SET_LDT_PARAMS(the_ldt_desc, &ldt, ldt_size);
  40194d:	b8 50 02 40 00       	mov    $0x400250,%eax
  401952:	25 00 00 00 ff       	and    $0xff000000,%eax
  401957:	c1 e8 18             	shr    $0x18,%eax
  40195a:	88 45 d7             	mov    %al,0xffffffd7(%ebp)
  40195d:	b8 50 02 40 00       	mov    $0x400250,%eax
  401962:	25 00 00 ff 00       	and    $0xff0000,%eax
  401967:	c1 e8 10             	shr    $0x10,%eax
  40196a:	88 45 d4             	mov    %al,0xffffffd4(%ebp)
  40196d:	b8 50 02 40 00       	mov    $0x400250,%eax
  401972:	66 89 45 d2          	mov    %ax,0xffffffd2(%ebp)
  401976:	a1 88 01 40 00       	mov    0x400188,%eax
  40197b:	25 00 00 0f 00       	and    $0xf0000,%eax
  401980:	c1 e8 10             	shr    $0x10,%eax
  401983:	83 e0 0f             	and    $0xf,%eax
  401986:	89 c2                	mov    %eax,%edx
  401988:	83 e2 0f             	and    $0xf,%edx
  40198b:	0f b6 45 d6          	movzbl 0xffffffd6(%ebp),%eax
  40198f:	83 e0 f0             	and    $0xfffffff0,%eax
  401992:	09 d0                	or     %edx,%eax
  401994:	88 45 d6             	mov    %al,0xffffffd6(%ebp)
  401997:	a1 88 01 40 00       	mov    0x400188,%eax
  40199c:	66 89 45 d0          	mov    %ax,0xffffffd0(%ebp)
		ldt_desc_ptr = the_ldt_desc;
  4019a0:	8b 45 d0             	mov    0xffffffd0(%ebp),%eax
  4019a3:	8b 55 d4             	mov    0xffffffd4(%ebp),%edx
  4019a6:	a3 48 02 40 00       	mov    %eax,0x400248
  4019ab:	89 15 4c 02 40 00    	mov    %edx,0x40024c
		lldt(KERNEL_LDT);
  4019b1:	b8 38 00 00 00       	mov    $0x38,%eax
  4019b6:	0f 00 d0             	lldt   %ax
	}

	/* Construct a TSS entry in the GDT */
	{
		seg_desc_t the_tss_desc;
		the_tss_desc.granularity    = 0;
  4019b9:	0f b6 45 ce          	movzbl 0xffffffce(%ebp),%eax
  4019bd:	83 e0 7f             	and    $0x7f,%eax
  4019c0:	88 45 ce             	mov    %al,0xffffffce(%ebp)
		the_tss_desc.opsize         = 0;
  4019c3:	0f b6 45 ce          	movzbl 0xffffffce(%ebp),%eax
  4019c7:	83 e0 bf             	and    $0xffffffbf,%eax
  4019ca:	88 45 ce             	mov    %al,0xffffffce(%ebp)
		the_tss_desc.reserved       = 0;
  4019cd:	0f b6 45 ce          	movzbl 0xffffffce(%ebp),%eax
  4019d1:	83 e0 df             	and    $0xffffffdf,%eax
  4019d4:	88 45 ce             	mov    %al,0xffffffce(%ebp)
		the_tss_desc.avail          = 0;
  4019d7:	0f b6 45 ce          	movzbl 0xffffffce(%ebp),%eax
  4019db:	83 e0 ef             	and    $0xffffffef,%eax
  4019de:	88 45 ce             	mov    %al,0xffffffce(%ebp)
		the_tss_desc.seg_lim_19_16  = TSS_SIZE & 0x000F0000;
  4019e1:	0f b6 45 ce          	movzbl 0xffffffce(%ebp),%eax
  4019e5:	83 e0 f0             	and    $0xfffffff0,%eax
  4019e8:	88 45 ce             	mov    %al,0xffffffce(%ebp)
		the_tss_desc.present        = 1;
  4019eb:	0f b6 45 cd          	movzbl 0xffffffcd(%ebp),%eax
  4019ef:	83 c8 80             	or     $0xffffff80,%eax
  4019f2:	88 45 cd             	mov    %al,0xffffffcd(%ebp)
		the_tss_desc.dpl            = 0x0;
  4019f5:	0f b6 45 cd          	movzbl 0xffffffcd(%ebp),%eax
  4019f9:	83 e0 9f             	and    $0xffffff9f,%eax
  4019fc:	88 45 cd             	mov    %al,0xffffffcd(%ebp)
		the_tss_desc.sys            = 0;
  4019ff:	0f b6 45 cd          	movzbl 0xffffffcd(%ebp),%eax
  401a03:	83 e0 ef             	and    $0xffffffef,%eax
  401a06:	88 45 cd             	mov    %al,0xffffffcd(%ebp)
		the_tss_desc.type           = 0x9;
  401a09:	0f b6 45 cd          	movzbl 0xffffffcd(%ebp),%eax
  401a0d:	83 e0 f0             	and    $0xfffffff0,%eax
  401a10:	83 c8 09             	or     $0x9,%eax
  401a13:	88 45 cd             	mov    %al,0xffffffcd(%ebp)
		the_tss_desc.seg_lim_15_00  = TSS_SIZE & 0x0000FFFF;
  401a16:	66 c7 45 c8 68 00    	movw   $0x68,0xffffffc8(%ebp)

		SET_TSS_PARAMS(the_tss_desc, &tss, tss_size);
  401a1c:	b8 94 01 40 00       	mov    $0x400194,%eax
  401a21:	25 00 00 00 ff       	and    $0xff000000,%eax
  401a26:	c1 e8 18             	shr    $0x18,%eax
  401a29:	88 45 cf             	mov    %al,0xffffffcf(%ebp)
  401a2c:	b8 94 01 40 00       	mov    $0x400194,%eax
  401a31:	25 00 00 ff 00       	and    $0xff0000,%eax
  401a36:	c1 e8 10             	shr    $0x10,%eax
  401a39:	88 45 cc             	mov    %al,0xffffffcc(%ebp)
  401a3c:	b8 94 01 40 00       	mov    $0x400194,%eax
  401a41:	66 89 45 ca          	mov    %ax,0xffffffca(%ebp)
  401a45:	a1 84 01 40 00       	mov    0x400184,%eax
  401a4a:	25 00 00 0f 00       	and    $0xf0000,%eax
  401a4f:	c1 e8 10             	shr    $0x10,%eax
  401a52:	83 e0 0f             	and    $0xf,%eax
  401a55:	89 c2                	mov    %eax,%edx
  401a57:	83 e2 0f             	and    $0xf,%edx
  401a5a:	0f b6 45 ce          	movzbl 0xffffffce(%ebp),%eax
  401a5e:	83 e0 f0             	and    $0xfffffff0,%eax
  401a61:	09 d0                	or     %edx,%eax
  401a63:	88 45 ce             	mov    %al,0xffffffce(%ebp)
  401a66:	a1 84 01 40 00       	mov    0x400184,%eax
  401a6b:	66 89 45 c8          	mov    %ax,0xffffffc8(%ebp)

		tss_desc_ptr = the_tss_desc;
  401a6f:	8b 45 c8             	mov    0xffffffc8(%ebp),%eax
  401a72:	8b 55 cc             	mov    0xffffffcc(%ebp),%edx
  401a75:	a3 40 02 40 00       	mov    %eax,0x400240
  401a7a:	89 15 44 02 40 00    	mov    %edx,0x400244

		tss.ldt_segment_selector = KERNEL_LDT;
  401a80:	66 c7 05 f4 01 40 00 	movw   $0x38,0x4001f4
  401a87:	38 00 
		tss.ss0 = KERNEL_DS;
  401a89:	66 c7 05 9c 01 40 00 	movw   $0x18,0x40019c
  401a90:	18 00 
		tss.esp0 = 0x800000;
  401a92:	c7 05 98 01 40 00 00 	movl   $0x800000,0x400198
  401a99:	00 80 00 
		ltr(KERNEL_TSS);
  401a9c:	b8 30 00 00 00       	mov    $0x30,%eax
  401aa1:	0f 00 d8             	ltr    %ax
	}

	// /* load the IDT and add some entries */
	lidt(idt_desc_ptr);
  401aa4:	0f 01 1d 72 02 40 00 	lidtl  0x400272

	/* exceptions, numbered 0 to 20 */
	unsigned int i;
	for (i = 0; i < 32; i++) {
  401aab:	c7 45 dc 00 00 00 00 	movl   $0x0,0xffffffdc(%ebp)
  401ab2:	e9 af 00 00 00       	jmp    401b66 <entry+0x522>

			idt[i].present = 1;
  401ab7:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
  401aba:	0f b6 04 d5 85 02 40 	movzbl 0x400285(,%edx,8),%eax
  401ac1:	00 
  401ac2:	83 c8 80             	or     $0xffffff80,%eax
  401ac5:	88 04 d5 85 02 40 00 	mov    %al,0x400285(,%edx,8)
			idt[i].dpl = 0;
  401acc:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
  401acf:	0f b6 04 d5 85 02 40 	movzbl 0x400285(,%edx,8),%eax
  401ad6:	00 
  401ad7:	83 e0 9f             	and    $0xffffff9f,%eax
  401ada:	88 04 d5 85 02 40 00 	mov    %al,0x400285(,%edx,8)
			idt[i].seg_selector = KERNEL_CS;
  401ae1:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  401ae4:	66 c7 04 c5 82 02 40 	movw   $0x10,0x400282(,%eax,8)
  401aeb:	00 10 00 
			idt[i].reserved4 = 0;
  401aee:	8b 45 dc             	mov    0xffffffdc(%ebp),%eax
  401af1:	c6 04 c5 84 02 40 00 	movb   $0x0,0x400284(,%eax,8)
  401af8:	00 
			idt[i].reserved3 = 0;			/* interrupt gate */
  401af9:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
  401afc:	0f b6 04 d5 85 02 40 	movzbl 0x400285(,%edx,8),%eax
  401b03:	00 
  401b04:	83 e0 fe             	and    $0xfffffffe,%eax
  401b07:	88 04 d5 85 02 40 00 	mov    %al,0x400285(,%edx,8)
			idt[i].reserved2 = 1;
  401b0e:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
  401b11:	0f b6 04 d5 85 02 40 	movzbl 0x400285(,%edx,8),%eax
  401b18:	00 
  401b19:	83 c8 02             	or     $0x2,%eax
  401b1c:	88 04 d5 85 02 40 00 	mov    %al,0x400285(,%edx,8)
			idt[i].reserved1 = 1;
  401b23:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
  401b26:	0f b6 04 d5 85 02 40 	movzbl 0x400285(,%edx,8),%eax
  401b2d:	00 
  401b2e:	83 c8 04             	or     $0x4,%eax
  401b31:	88 04 d5 85 02 40 00 	mov    %al,0x400285(,%edx,8)
			idt[i].size = 1;				/* gate is 32 bits */
  401b38:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
  401b3b:	0f b6 04 d5 85 02 40 	movzbl 0x400285(,%edx,8),%eax
  401b42:	00 
  401b43:	83 c8 08             	or     $0x8,%eax
  401b46:	88 04 d5 85 02 40 00 	mov    %al,0x400285(,%edx,8)
			idt[i].reserved0 = 0;
  401b4d:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
  401b50:	0f b6 04 d5 85 02 40 	movzbl 0x400285(,%edx,8),%eax
  401b57:	00 
  401b58:	83 e0 ef             	and    $0xffffffef,%eax
  401b5b:	88 04 d5 85 02 40 00 	mov    %al,0x400285(,%edx,8)
  401b62:	83 45 dc 01          	addl   $0x1,0xffffffdc(%ebp)
  401b66:	83 7d dc 1f          	cmpl   $0x1f,0xffffffdc(%ebp)
  401b6a:	0f 86 47 ff ff ff    	jbe    401ab7 <entry+0x473>

	}

	SET_IDT_ENTRY(idt[0], exception_print0);
  401b70:	b8 3c 00 40 00       	mov    $0x40003c,%eax
  401b75:	66 b8 00 00          	mov    $0x0,%ax
  401b79:	c1 e8 10             	shr    $0x10,%eax
  401b7c:	66 a3 86 02 40 00    	mov    %ax,0x400286
  401b82:	b8 3c 00 40 00       	mov    $0x40003c,%eax
  401b87:	66 a3 80 02 40 00    	mov    %ax,0x400280
	SET_IDT_ENTRY(idt[1], exception_print1);
  401b8d:	b8 46 00 40 00       	mov    $0x400046,%eax
  401b92:	66 b8 00 00          	mov    $0x0,%ax
  401b96:	c1 e8 10             	shr    $0x10,%eax
  401b99:	66 a3 8e 02 40 00    	mov    %ax,0x40028e
  401b9f:	b8 46 00 40 00       	mov    $0x400046,%eax
  401ba4:	66 a3 88 02 40 00    	mov    %ax,0x400288
	SET_IDT_ENTRY(idt[2], exception_print2);
  401baa:	b8 50 00 40 00       	mov    $0x400050,%eax
  401baf:	66 b8 00 00          	mov    $0x0,%ax
  401bb3:	c1 e8 10             	shr    $0x10,%eax
  401bb6:	66 a3 96 02 40 00    	mov    %ax,0x400296
  401bbc:	b8 50 00 40 00       	mov    $0x400050,%eax
  401bc1:	66 a3 90 02 40 00    	mov    %ax,0x400290
	SET_IDT_ENTRY(idt[3], exception_print3);
  401bc7:	b8 5a 00 40 00       	mov    $0x40005a,%eax
  401bcc:	66 b8 00 00          	mov    $0x0,%ax
  401bd0:	c1 e8 10             	shr    $0x10,%eax
  401bd3:	66 a3 9e 02 40 00    	mov    %ax,0x40029e
  401bd9:	b8 5a 00 40 00       	mov    $0x40005a,%eax
  401bde:	66 a3 98 02 40 00    	mov    %ax,0x400298
	SET_IDT_ENTRY(idt[4], exception_print4);
  401be4:	b8 64 00 40 00       	mov    $0x400064,%eax
  401be9:	66 b8 00 00          	mov    $0x0,%ax
  401bed:	c1 e8 10             	shr    $0x10,%eax
  401bf0:	66 a3 a6 02 40 00    	mov    %ax,0x4002a6
  401bf6:	b8 64 00 40 00       	mov    $0x400064,%eax
  401bfb:	66 a3 a0 02 40 00    	mov    %ax,0x4002a0
	SET_IDT_ENTRY(idt[5], exception_print5);
  401c01:	b8 6e 00 40 00       	mov    $0x40006e,%eax
  401c06:	66 b8 00 00          	mov    $0x0,%ax
  401c0a:	c1 e8 10             	shr    $0x10,%eax
  401c0d:	66 a3 ae 02 40 00    	mov    %ax,0x4002ae
  401c13:	b8 6e 00 40 00       	mov    $0x40006e,%eax
  401c18:	66 a3 a8 02 40 00    	mov    %ax,0x4002a8
	SET_IDT_ENTRY(idt[6], exception_print6);
  401c1e:	b8 78 00 40 00       	mov    $0x400078,%eax
  401c23:	66 b8 00 00          	mov    $0x0,%ax
  401c27:	c1 e8 10             	shr    $0x10,%eax
  401c2a:	66 a3 b6 02 40 00    	mov    %ax,0x4002b6
  401c30:	b8 78 00 40 00       	mov    $0x400078,%eax
  401c35:	66 a3 b0 02 40 00    	mov    %ax,0x4002b0
	SET_IDT_ENTRY(idt[7], exception_print7);
  401c3b:	b8 82 00 40 00       	mov    $0x400082,%eax
  401c40:	66 b8 00 00          	mov    $0x0,%ax
  401c44:	c1 e8 10             	shr    $0x10,%eax
  401c47:	66 a3 be 02 40 00    	mov    %ax,0x4002be
  401c4d:	b8 82 00 40 00       	mov    $0x400082,%eax
  401c52:	66 a3 b8 02 40 00    	mov    %ax,0x4002b8
	SET_IDT_ENTRY(idt[8], exception_print8);
  401c58:	b8 8c 00 40 00       	mov    $0x40008c,%eax
  401c5d:	66 b8 00 00          	mov    $0x0,%ax
  401c61:	c1 e8 10             	shr    $0x10,%eax
  401c64:	66 a3 c6 02 40 00    	mov    %ax,0x4002c6
  401c6a:	b8 8c 00 40 00       	mov    $0x40008c,%eax
  401c6f:	66 a3 c0 02 40 00    	mov    %ax,0x4002c0
	SET_IDT_ENTRY(idt[9], exception_print9);
  401c75:	b8 96 00 40 00       	mov    $0x400096,%eax
  401c7a:	66 b8 00 00          	mov    $0x0,%ax
  401c7e:	c1 e8 10             	shr    $0x10,%eax
  401c81:	66 a3 ce 02 40 00    	mov    %ax,0x4002ce
  401c87:	b8 96 00 40 00       	mov    $0x400096,%eax
  401c8c:	66 a3 c8 02 40 00    	mov    %ax,0x4002c8
	SET_IDT_ENTRY(idt[10], exception_print10);
  401c92:	b8 a0 00 40 00       	mov    $0x4000a0,%eax
  401c97:	66 b8 00 00          	mov    $0x0,%ax
  401c9b:	c1 e8 10             	shr    $0x10,%eax
  401c9e:	66 a3 d6 02 40 00    	mov    %ax,0x4002d6
  401ca4:	b8 a0 00 40 00       	mov    $0x4000a0,%eax
  401ca9:	66 a3 d0 02 40 00    	mov    %ax,0x4002d0
	SET_IDT_ENTRY(idt[11], exception_print11);
  401caf:	b8 aa 00 40 00       	mov    $0x4000aa,%eax
  401cb4:	66 b8 00 00          	mov    $0x0,%ax
  401cb8:	c1 e8 10             	shr    $0x10,%eax
  401cbb:	66 a3 de 02 40 00    	mov    %ax,0x4002de
  401cc1:	b8 aa 00 40 00       	mov    $0x4000aa,%eax
  401cc6:	66 a3 d8 02 40 00    	mov    %ax,0x4002d8
	SET_IDT_ENTRY(idt[12], exception_print12);
  401ccc:	b8 b4 00 40 00       	mov    $0x4000b4,%eax
  401cd1:	66 b8 00 00          	mov    $0x0,%ax
  401cd5:	c1 e8 10             	shr    $0x10,%eax
  401cd8:	66 a3 e6 02 40 00    	mov    %ax,0x4002e6
  401cde:	b8 b4 00 40 00       	mov    $0x4000b4,%eax
  401ce3:	66 a3 e0 02 40 00    	mov    %ax,0x4002e0
	SET_IDT_ENTRY(idt[13], exception_print13);
  401ce9:	b8 be 00 40 00       	mov    $0x4000be,%eax
  401cee:	66 b8 00 00          	mov    $0x0,%ax
  401cf2:	c1 e8 10             	shr    $0x10,%eax
  401cf5:	66 a3 ee 02 40 00    	mov    %ax,0x4002ee
  401cfb:	b8 be 00 40 00       	mov    $0x4000be,%eax
  401d00:	66 a3 e8 02 40 00    	mov    %ax,0x4002e8
	SET_IDT_ENTRY(idt[14], exception_print14);
  401d06:	b8 c8 00 40 00       	mov    $0x4000c8,%eax
  401d0b:	66 b8 00 00          	mov    $0x0,%ax
  401d0f:	c1 e8 10             	shr    $0x10,%eax
  401d12:	66 a3 f6 02 40 00    	mov    %ax,0x4002f6
  401d18:	b8 c8 00 40 00       	mov    $0x4000c8,%eax
  401d1d:	66 a3 f0 02 40 00    	mov    %ax,0x4002f0
	SET_IDT_ENTRY(idt[16], exception_print16);
  401d23:	b8 d2 00 40 00       	mov    $0x4000d2,%eax
  401d28:	66 b8 00 00          	mov    $0x0,%ax
  401d2c:	c1 e8 10             	shr    $0x10,%eax
  401d2f:	66 a3 06 03 40 00    	mov    %ax,0x400306
  401d35:	b8 d2 00 40 00       	mov    $0x4000d2,%eax
  401d3a:	66 a3 00 03 40 00    	mov    %ax,0x400300
	SET_IDT_ENTRY(idt[17], exception_print17);
  401d40:	b8 dc 00 40 00       	mov    $0x4000dc,%eax
  401d45:	66 b8 00 00          	mov    $0x0,%ax
  401d49:	c1 e8 10             	shr    $0x10,%eax
  401d4c:	66 a3 0e 03 40 00    	mov    %ax,0x40030e
  401d52:	b8 dc 00 40 00       	mov    $0x4000dc,%eax
  401d57:	66 a3 08 03 40 00    	mov    %ax,0x400308
	SET_IDT_ENTRY(idt[18], exception_print18);
  401d5d:	b8 e6 00 40 00       	mov    $0x4000e6,%eax
  401d62:	66 b8 00 00          	mov    $0x0,%ax
  401d66:	c1 e8 10             	shr    $0x10,%eax
  401d69:	66 a3 16 03 40 00    	mov    %ax,0x400316
  401d6f:	b8 e6 00 40 00       	mov    $0x4000e6,%eax
  401d74:	66 a3 10 03 40 00    	mov    %ax,0x400310
	SET_IDT_ENTRY(idt[19], exception_print19);
  401d7a:	b8 f0 00 40 00       	mov    $0x4000f0,%eax
  401d7f:	66 b8 00 00          	mov    $0x0,%ax
  401d83:	c1 e8 10             	shr    $0x10,%eax
  401d86:	66 a3 1e 03 40 00    	mov    %ax,0x40031e
  401d8c:	b8 f0 00 40 00       	mov    $0x4000f0,%eax
  401d91:	66 a3 18 03 40 00    	mov    %ax,0x400318

	SET_IDT_ENTRY(idt[15], exception_print_general);
  401d97:	b8 fa 00 40 00       	mov    $0x4000fa,%eax
  401d9c:	66 b8 00 00          	mov    $0x0,%ax
  401da0:	c1 e8 10             	shr    $0x10,%eax
  401da3:	66 a3 fe 02 40 00    	mov    %ax,0x4002fe
  401da9:	b8 fa 00 40 00       	mov    $0x4000fa,%eax
  401dae:	66 a3 f8 02 40 00    	mov    %ax,0x4002f8

	for (i = 20; i < 32; i++){
  401db4:	c7 45 dc 14 00 00 00 	movl   $0x14,0xffffffdc(%ebp)
  401dbb:	eb 2b                	jmp    401de8 <entry+0x7a4>

		SET_IDT_ENTRY(idt[i], exception_print_general);
  401dbd:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
  401dc0:	b8 fa 00 40 00       	mov    $0x4000fa,%eax
  401dc5:	66 b8 00 00          	mov    $0x0,%ax
  401dc9:	c1 e8 10             	shr    $0x10,%eax
  401dcc:	66 89 04 d5 86 02 40 	mov    %ax,0x400286(,%edx,8)
  401dd3:	00 
  401dd4:	8b 55 dc             	mov    0xffffffdc(%ebp),%edx
  401dd7:	b8 fa 00 40 00       	mov    $0x4000fa,%eax
  401ddc:	66 89 04 d5 80 02 40 	mov    %ax,0x400280(,%edx,8)
  401de3:	00 
  401de4:	83 45 dc 01          	addl   $0x1,0xffffffdc(%ebp)
  401de8:	83 7d dc 1f          	cmpl   $0x1f,0xffffffdc(%ebp)
  401dec:	76 cf                	jbe    401dbd <entry+0x779>
	}


	/* devices: keyboard on interupt vector 0x21 */
	idt[0x21].present = 1;
  401dee:	0f b6 05 8d 03 40 00 	movzbl 0x40038d,%eax
  401df5:	83 c8 80             	or     $0xffffff80,%eax
  401df8:	a2 8d 03 40 00       	mov    %al,0x40038d
	idt[0x21].dpl = 0;
  401dfd:	0f b6 05 8d 03 40 00 	movzbl 0x40038d,%eax
  401e04:	83 e0 9f             	and    $0xffffff9f,%eax
  401e07:	a2 8d 03 40 00       	mov    %al,0x40038d
	idt[0x21].seg_selector = KERNEL_CS;
  401e0c:	66 c7 05 8a 03 40 00 	movw   $0x10,0x40038a
  401e13:	10 00 
	idt[0x21].reserved4 = 0;
  401e15:	c6 05 8c 03 40 00 00 	movb   $0x0,0x40038c
	idt[0x21].reserved3 = 0;		/* interrupt gate */
  401e1c:	0f b6 05 8d 03 40 00 	movzbl 0x40038d,%eax
  401e23:	83 e0 fe             	and    $0xfffffffe,%eax
  401e26:	a2 8d 03 40 00       	mov    %al,0x40038d
	idt[0x21].reserved2 = 1;
  401e2b:	0f b6 05 8d 03 40 00 	movzbl 0x40038d,%eax
  401e32:	83 c8 02             	or     $0x2,%eax
  401e35:	a2 8d 03 40 00       	mov    %al,0x40038d
	idt[0x21].reserved1 = 1;
  401e3a:	0f b6 05 8d 03 40 00 	movzbl 0x40038d,%eax
  401e41:	83 c8 04             	or     $0x4,%eax
  401e44:	a2 8d 03 40 00       	mov    %al,0x40038d
	idt[0x21].size = 1;				/* gate is 32 bits */
  401e49:	0f b6 05 8d 03 40 00 	movzbl 0x40038d,%eax
  401e50:	83 c8 08             	or     $0x8,%eax
  401e53:	a2 8d 03 40 00       	mov    %al,0x40038d
	idt[0x21].reserved0 = 0;
  401e58:	0f b6 05 8d 03 40 00 	movzbl 0x40038d,%eax
  401e5f:	83 e0 ef             	and    $0xffffffef,%eax
  401e62:	a2 8d 03 40 00       	mov    %al,0x40038d

	SET_IDT_ENTRY(idt[0x21], keyboard_handler_wrapper);
  401e67:	b8 17 01 40 00       	mov    $0x400117,%eax
  401e6c:	66 b8 00 00          	mov    $0x0,%ax
  401e70:	c1 e8 10             	shr    $0x10,%eax
  401e73:	66 a3 8e 03 40 00    	mov    %ax,0x40038e
  401e79:	b8 17 01 40 00       	mov    $0x400117,%eax
  401e7e:	66 a3 88 03 40 00    	mov    %ax,0x400388

	/* devices: RTC on interupt vector 0x28 */
	idt[0x28].present = 1;
  401e84:	0f b6 05 c5 03 40 00 	movzbl 0x4003c5,%eax
  401e8b:	83 c8 80             	or     $0xffffff80,%eax
  401e8e:	a2 c5 03 40 00       	mov    %al,0x4003c5
	idt[0x28].dpl = 0;
  401e93:	0f b6 05 c5 03 40 00 	movzbl 0x4003c5,%eax
  401e9a:	83 e0 9f             	and    $0xffffff9f,%eax
  401e9d:	a2 c5 03 40 00       	mov    %al,0x4003c5
	idt[0x28].seg_selector = KERNEL_CS;
  401ea2:	66 c7 05 c2 03 40 00 	movw   $0x10,0x4003c2
  401ea9:	10 00 
	idt[0x28].reserved4 = 0;
  401eab:	c6 05 c4 03 40 00 00 	movb   $0x0,0x4003c4
	idt[0x28].reserved3 = 0;		/* interrupt gate */
  401eb2:	0f b6 05 c5 03 40 00 	movzbl 0x4003c5,%eax
  401eb9:	83 e0 fe             	and    $0xfffffffe,%eax
  401ebc:	a2 c5 03 40 00       	mov    %al,0x4003c5
	idt[0x28].reserved2 = 1;
  401ec1:	0f b6 05 c5 03 40 00 	movzbl 0x4003c5,%eax
  401ec8:	83 c8 02             	or     $0x2,%eax
  401ecb:	a2 c5 03 40 00       	mov    %al,0x4003c5
	idt[0x28].reserved1 = 1;
  401ed0:	0f b6 05 c5 03 40 00 	movzbl 0x4003c5,%eax
  401ed7:	83 c8 04             	or     $0x4,%eax
  401eda:	a2 c5 03 40 00       	mov    %al,0x4003c5
	idt[0x28].size = 1;
  401edf:	0f b6 05 c5 03 40 00 	movzbl 0x4003c5,%eax
  401ee6:	83 c8 08             	or     $0x8,%eax
  401ee9:	a2 c5 03 40 00       	mov    %al,0x4003c5
	idt[0x28].reserved0 = 0;
  401eee:	0f b6 05 c5 03 40 00 	movzbl 0x4003c5,%eax
  401ef5:	83 e0 ef             	and    $0xffffffef,%eax
  401ef8:	a2 c5 03 40 00       	mov    %al,0x4003c5

	SET_IDT_ENTRY(idt[0x28], rtc_handler_wrapper);
  401efd:	b8 0d 01 40 00       	mov    $0x40010d,%eax
  401f02:	66 b8 00 00          	mov    $0x0,%ax
  401f06:	c1 e8 10             	shr    $0x10,%eax
  401f09:	66 a3 c6 03 40 00    	mov    %ax,0x4003c6
  401f0f:	b8 0d 01 40 00       	mov    $0x40010d,%eax
  401f14:	66 a3 c0 03 40 00    	mov    %ax,0x4003c0

	/* syscalls on trap vector 0x80 */
	idt[0x80].present = 1;
  401f1a:	0f b6 05 85 06 40 00 	movzbl 0x400685,%eax
  401f21:	83 c8 80             	or     $0xffffff80,%eax
  401f24:	a2 85 06 40 00       	mov    %al,0x400685
	idt[0x80].dpl = 3;
  401f29:	0f b6 05 85 06 40 00 	movzbl 0x400685,%eax
  401f30:	83 c8 60             	or     $0x60,%eax
  401f33:	a2 85 06 40 00       	mov    %al,0x400685
	idt[0x80].seg_selector = KERNEL_CS;
  401f38:	66 c7 05 82 06 40 00 	movw   $0x10,0x400682
  401f3f:	10 00 
	idt[0x80].reserved4 = 0;
  401f41:	c6 05 84 06 40 00 00 	movb   $0x0,0x400684
	idt[0x80].reserved3 = 0;		/* interupt gate */
  401f48:	0f b6 05 85 06 40 00 	movzbl 0x400685,%eax
  401f4f:	83 e0 fe             	and    $0xfffffffe,%eax
  401f52:	a2 85 06 40 00       	mov    %al,0x400685
	idt[0x80].reserved2 = 1;
  401f57:	0f b6 05 85 06 40 00 	movzbl 0x400685,%eax
  401f5e:	83 c8 02             	or     $0x2,%eax
  401f61:	a2 85 06 40 00       	mov    %al,0x400685
	idt[0x80].reserved1 = 1;
  401f66:	0f b6 05 85 06 40 00 	movzbl 0x400685,%eax
  401f6d:	83 c8 04             	or     $0x4,%eax
  401f70:	a2 85 06 40 00       	mov    %al,0x400685
	idt[0x80].size = 1;				/* gate is 32 bits */
  401f75:	0f b6 05 85 06 40 00 	movzbl 0x400685,%eax
  401f7c:	83 c8 08             	or     $0x8,%eax
  401f7f:	a2 85 06 40 00       	mov    %al,0x400685
	idt[0x80].reserved0 = 0;
  401f84:	0f b6 05 85 06 40 00 	movzbl 0x400685,%eax
  401f8b:	83 e0 ef             	and    $0xffffffef,%eax
  401f8e:	a2 85 06 40 00       	mov    %al,0x400685

	SET_IDT_ENTRY(idt[0x80], syscall_handler);
  401f93:	b8 21 01 40 00       	mov    $0x400121,%eax
  401f98:	66 b8 00 00          	mov    $0x0,%ax
  401f9c:	c1 e8 10             	shr    $0x10,%eax
  401f9f:	66 a3 86 06 40 00    	mov    %ax,0x400686
  401fa5:	b8 21 01 40 00       	mov    $0x400121,%eax
  401faa:	66 a3 80 06 40 00    	mov    %ax,0x400680

	/* Init the PIC */
	i8259_init();
  401fb0:	e8 ab f4 ff ff       	call   401460 <i8259_init>

	/*Init the RTC*/
	rtc_init();
  401fb5:	e8 5a 14 00 00       	call   403414 <rtc_init>

	/*Init the Keyboard*/
	keyboard_init();
  401fba:	e8 ed 01 00 00       	call   4021ac <keyboard_init>

	/* Initialize devices, memory, filesystem, enable device interrupts on the
	 * PIC, any other initialization stuff... */

	initilize_paging();
  401fbf:	e8 2a 00 00 00       	call   401fee <initilize_paging>

	/* test various exceptions */
	/*
	int * ptrr;
	int b;
	for(i = kernel_start; i<kernel_start+(PAGE_SIZE*1024)-1;i++) {
		ptrr = i;
		printf("pass kernel memory %x \n",i);
		b  = *ptrr;}

		printf("pass all kernel memory\n");

		ptrr = i;

		b = *ptrr;
		int32_t aa;
		while(1){
		aa += 0x0ffffff;
		printf("num is %x \n",aa);
		asm volatile ("into");
	}
	*/

	/* Enable interrupts */
	/* test rtc_write */

	/* Execute the first program (`shell') ... */

	/* Enable interrupts
	clear();
	printf("Enabling Interrupts\n");
	sti();
	*/

	/* test rtc_open

	uint8_t rtc_name[] = "rtc_test_filename";
	printf("running rtc_open with filename %s\n", rtc_name);
	rtc_open(rtc_name);

	rtc_wait(5, 0);
	clear();

	*/

	/* test rtc_write

	rtc_write(300); // freq not a power of 2
	rtc_write(RTC_DEFAULT_FREQ * 2); // freq out of range
	rtc_write(RTC_DEFAULT_FREQ / 2); // freq out of range

	rtc_wait(5, 1);
	clear();

	rtc_write(4);

	rtc_wait(5, 1);
	clear();

	rtc_write(1024);

	rtc_wait(5, 1);
	clear();

	*/

	/* rtc_read in an infinite loop

	rtc_write(2);
	while (1) {
		rtc_read();
	} */

	/*Testing terminal*/
	//test_terminal();

	bblock = (bootblock_t *)((module_t *)(mbi->mods_addr))->mod_start;
  401fc4:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  401fc7:	8b 40 18             	mov    0x18(%eax),%eax
  401fca:	8b 00                	mov    (%eax),%eax
  401fcc:	a3 c8 d0 40 00       	mov    %eax,0x40d0c8

	clear();
  401fd1:	e8 1e 09 00 00       	call   4028f4 <clear>
	sys_execute((uint8_t*)"shell\n");
  401fd6:	b8 f4 41 40 00       	mov    $0x4041f4,%eax
  401fdb:	89 04 24             	mov    %eax,(%esp)
  401fde:	e8 9d ea ff ff       	call   400a80 <sys_execute>

00401fe3 <.1>:



	/* Execute the first program (`shell') ... */


	/* Spin (nicely, so we don't chew up cycles) */
	asm volatile(".1: hlt; jmp .1;");
  401fe3:	f4                   	hlt    
  401fe4:	eb fd                	jmp    401fe3 <.1>
}
  401fe6:	83 c4 4c             	add    $0x4c,%esp
  401fe9:	5b                   	pop    %ebx
  401fea:	5e                   	pop    %esi
  401feb:	5f                   	pop    %edi
  401fec:	5d                   	pop    %ebp
  401fed:	c3                   	ret    

00401fee <initilize_paging>:

/*
* void initilize_paging(void)
*   Inputs: none
*   Return Value: void
*	Function: Initializes paging
*/
void initilize_paging(){
  401fee:	55                   	push   %ebp
  401fef:	89 e5                	mov    %esp,%ebp
  401ff1:	83 ec 18             	sub    $0x18,%esp

//static uint32_t page_table_0[NUM_PAGES] __attribute__((aligned(PAGE_SIZE)));//0-4mb table

int i, j;

//initialize all page directory entry to 010, that is read/write, supervisor mode and nonpresent

for(i=0;i<NUM_PROCESS;i++){
  401ff4:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  401ffb:	eb 30                	jmp    40202d <initilize_paging+0x3f>
	for(j=0;j<NUM_PAGE_TABLES;j++){
  401ffd:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  402004:	eb 1a                	jmp    402020 <initilize_paging+0x32>
		page_dir[i][j] = R_W_BIT_ENABLE;
  402006:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  402009:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  40200c:	c1 e0 0a             	shl    $0xa,%eax
  40200f:	01 d0                	add    %edx,%eax
  402011:	c7 04 85 00 70 40 00 	movl   $0x2,0x407000(,%eax,4)
  402018:	02 00 00 00 
  40201c:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  402020:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,0xfffffffc(%ebp)
  402027:	7e dd                	jle    402006 <initilize_paging+0x18>
  402029:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  40202d:	83 7d f8 05          	cmpl   $0x5,0xfffffff8(%ebp)
  402031:	7e ca                	jle    401ffd <initilize_paging+0xf>
	}
}


//set page directory entry 1 to point to kernel memory

//set page size bit and the pde points to
	// page_dir[1] = kernel_start | (0X01<<7) | 0x03;
	
for(i=0;i<NUM_PROCESS;i++){
  402033:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  40203a:	eb 14                	jmp    402050 <initilize_paging+0x62>
	page_dir[i][1] = kernel_hardcode;
  40203c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  40203f:	c1 e0 0c             	shl    $0xc,%eax
  402042:	c7 80 04 70 40 00 83 	movl   $0x400183,0x407004(%eax)
  402049:	01 40 00 
  40204c:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  402050:	83 7d f8 05          	cmpl   $0x5,0xfffffff8(%ebp)
  402054:	7e e6                	jle    40203c <initilize_paging+0x4e>
}
///////////////////////////////////
//set PSE to allow 4mb page
 	set_pse();
  402056:	e8 08 e1 ff ff       	call   400163 <set_pse>


///////////////////////////////////

/*static uint32_t page_table_ls[NUM_PAGES] __attribute__((aligned(PAGE_SIZE)));//0-4mb table
	
	map_to_addr = 0x0;

for(i=0;i<NUM_PAGES;i++){

	page_table_ls[i] = map_to_addr | R_W_BIT_ENABLE;
	map_to_addr += PAGE_SIZE;

}

// set up shell
page_dir[1][0] = (uint32_t) page_table_ls | R_W_BIT_ENABLE;
page_dir[1][1] = kernel_hardcode;

//map 128 mb virtual addr to 8mb

page_dir[1][31] = SHELL_HARDCODE;*/

}
  40205b:	c9                   	leave  
  40205c:	c3                   	ret    

0040205d <setup_paging>:

void
setup_paging(int pid ){
  40205d:	55                   	push   %ebp
  40205e:	89 e5                	mov    %esp,%ebp
  402060:	83 ec 08             	sub    $0x8,%esp

//map 128 mb virtual addr to 8mb
page_dir[pid][32] = SHELL_HARDCODE + pid * physical_page_offset;
  402063:	8b 4d 08             	mov    0x8(%ebp),%ecx
  402066:	8b 45 08             	mov    0x8(%ebp),%eax
  402069:	c1 e0 16             	shl    $0x16,%eax
  40206c:	05 83 01 80 00       	add    $0x800183,%eax
  402071:	89 c2                	mov    %eax,%edx
  402073:	89 c8                	mov    %ecx,%eax
  402075:	c1 e0 0c             	shl    $0xc,%eax
  402078:	89 90 80 70 40 00    	mov    %edx,0x407080(%eax)
load_CR3(page_dir[pid]);
  40207e:	8b 45 08             	mov    0x8(%ebp),%eax
  402081:	c1 e0 0c             	shl    $0xc,%eax
  402084:	05 00 70 40 00       	add    $0x407000,%eax
  402089:	89 04 24             	mov    %eax,(%esp)
  40208c:	e8 b7 e0 ff ff       	call   400148 <load_CR3>

//set paging bit

set_cr0();
  402091:	e8 bd e0 ff ff       	call   400153 <set_cr0>

}
  402096:	c9                   	leave  
  402097:	c3                   	ret    

00402098 <unit_test_read_dentry_filename>:
// /*
// * void test_reg_file_open (uint8_t * file_name)
// *   Inputs: filename (the name of the file to open)
// *   Return Value: none
// *	Function: tries to open a filename and prints out success or failure
// */
// void
// test_reg_file_open (uint8_t * file_name)
// {
// 	if (reg_file_open(file_name) == -1)
// 	{
// 		printf("%s is an invalid filename!\n", file_name);
// 		return;
// 	}
// 	printf("%s successfully opened!\n", file_name);
// // 	printf("fs_test.inode = %d\n", fs_test.inode);
// // 	printf("fs_test.file_position = %d\n", fs_test.file_position);
// // 	printf("fs_test.flags = %d\n", fs_test.flags);
// }

// /*
// * void test_reg_file_read (file_struct_t * fs_test, int32_t nbytes)
// *   Inputs: fs_test (the dummy file descriptor), nbytes (num bytes to read)
// *   Return Value: none
// *	Function: uses helper function reg_file_read to read nbytes from a file,
// *			prints out the return value of reg_file_read
// */
// void
// test_reg_file_read (file_struct_t * fs_test, int32_t nbytes)
// {

// 	/* test read_data */
// 	uint8_t buf[64 * 4096 + 1];
// 	buf[64 * 4096] = '\0';

// 	int32_t ret_val = reg_file_read(fs_test, buf, nbytes);

// 	printf("reg_file_read returned value %d\n", ret_val);
// 	printf("%s\n", buf);
// }

// /*
// * void test_reg_file_write (file_struct_t * fs_test, char * string, int32_t nbytes)
// *   Inputs: fs_test (the dummy file descriptor), string (the string to write),
// *			nbytes (number of bytes to write)
// *   Return Value: none
// *	Function: tests reg_file_write, prints its return value
// */
// void
// test_reg_file_write (file_struct_t * fs_test, char * string, int32_t nbytes)
// {
// 	printf("reg_file_write returned %d\n", reg_file_write(fs_test, string, nbytes));
// }

// /*
// * void test_reg_file_close (int32_t fd)
// *	Inputs: fd (file index)
// *	Return Value: none
// *	Function: tests reg_file_close
// */
// void
// test_reg_file_close (int32_t fd)
// {
// 	reg_file_close(fd);
// }

// /*
// * void test_dir_open (uint8_t * dir_name)
// *	Inputs: dir_name (the directory name to open)
// *	Return Value: none
// *	Function: tests test_dir_open
// */
// void
// test_dir_open (uint8_t * dir_name)
// {
// 	if (dir_open(dir_name) == -1)
// 	{
// 		printf("%s is an invalid directory name!\n", dir_name);
// 		return;
// 	}
// 	printf("%s successfully opened!\n", dir_name);
// // 	printf("fs_test.inode = %d\n", fs_test.inode);
// // 	printf("fs_test.file_position = %d\n", fs_test.file_position);
// // 	printf("fs_test.flags = %d\n", fs_test.flags);
// }

// /*
// * void test_dir_read (file_struct_t * fs_test, int32_t nbytes, int32_t num_files)
// *	Inputs: fs_test (dummy file descriptor), nbytes, num_files
// *	Return Value: none
// *	Function: tests dir_read, prints its return value
// */
// void
// test_dir_read (file_struct_t * fs_test, int32_t nbytes, int32_t num_files)
// {

// 	/* test dir_read by reading num_files times */
// 	uint8_t buf[32];

// 	int32_t ret_val;

// 	while(num_files)
// 	{
// 		ret_val = dir_read(fs_test, buf, nbytes);
// 		if (ret_val <= 0)
// 		{
// 			printf("dir_read returned value %d\n", ret_val);
// 			break;
// 		}
// 		printf("%s\n", buf);
// 		num_files--;
// 	}
// }

// /*
// * void test_dir_write (file_struct_t * fs_test, char * string, int32_t nbytes)
// *	Inputs: fs_test (dummy file descriptor), string (stuff to write to the file), nbytes
// *	Return Value: none
// *	Function: tests dir_write, prints its return value
// */
// void
// test_dir_write (file_struct_t * fs_test, char * string, int32_t nbytes)
// {
// 	printf("dir_write returned %d\n", dir_write(fs_test, string, nbytes));
// }

// /*
// * void test_dir_close (int32_t fd)
// *	Inputs: fd (file index)
// *	Return Value: none
// *	Function: tests dir_close, prints its return value
// */
// void
// test_dir_close (int32_t fd)
// {
// 	dir_close(fd);
// }

/*
* void unit_test_read_dentry_filename (const uint8_t * file_name)
*	Inputs: file_name
*	Return Value: none
*	Function: tests read_dentry_by_name, prints debug info
*/
void
unit_test_read_dentry_filename (const uint8_t * file_name)
{
  402098:	55                   	push   %ebp
  402099:	89 e5                	mov    %esp,%ebp
  40209b:	83 ec 48             	sub    $0x48,%esp
	dentry_t test;
	if (read_dentry_by_name(file_name, &test) == 0)
  40209e:	8d 45 c0             	lea    0xffffffc0(%ebp),%eax
  4020a1:	89 44 24 04          	mov    %eax,0x4(%esp)
  4020a5:	8b 45 08             	mov    0x8(%ebp),%eax
  4020a8:	89 04 24             	mov    %eax,(%esp)
  4020ab:	e8 ac ee ff ff       	call   400f5c <read_dentry_by_name>
  4020b0:	85 c0                	test   %eax,%eax
  4020b2:	75 3b                	jne    4020ef <unit_test_read_dentry_filename+0x57>
	{
		printf("file_name : %s\n", test.file_name);
  4020b4:	8d 45 c0             	lea    0xffffffc0(%ebp),%eax
  4020b7:	89 44 24 04          	mov    %eax,0x4(%esp)
  4020bb:	c7 04 24 fb 41 40 00 	movl   $0x4041fb,(%esp)
  4020c2:	e8 e6 09 00 00       	call   402aad <printf>
		printf("file_type : %d\n", test.file_type);
  4020c7:	8b 45 e0             	mov    0xffffffe0(%ebp),%eax
  4020ca:	89 44 24 04          	mov    %eax,0x4(%esp)
  4020ce:	c7 04 24 0b 42 40 00 	movl   $0x40420b,(%esp)
  4020d5:	e8 d3 09 00 00       	call   402aad <printf>
		printf("inode_num : %d\n", test.inode_num);
  4020da:	8b 45 e4             	mov    0xffffffe4(%ebp),%eax
  4020dd:	89 44 24 04          	mov    %eax,0x4(%esp)
  4020e1:	c7 04 24 1b 42 40 00 	movl   $0x40421b,(%esp)
  4020e8:	e8 c0 09 00 00       	call   402aad <printf>
  4020ed:	eb 13                	jmp    402102 <unit_test_read_dentry_filename+0x6a>
	}
	else
	{
		printf("file_name: %s does not exist!\n", file_name);
  4020ef:	8b 45 08             	mov    0x8(%ebp),%eax
  4020f2:	89 44 24 04          	mov    %eax,0x4(%esp)
  4020f6:	c7 04 24 2c 42 40 00 	movl   $0x40422c,(%esp)
  4020fd:	e8 ab 09 00 00       	call   402aad <printf>
	}
}
  402102:	c9                   	leave  
  402103:	c3                   	ret    

00402104 <test_terminal>:

// /*
// * void unit_test_read_dentry_inode (int32_t inode_num)
// *	Inputs: inode_num
// *	Return Value: none
// *	Function: tests read_dentry_by_index, prints debug info
// */
// void
// unit_test_read_dentry_inode(int32_t inode_num)
// {
// 	dentry_t test;
// 	if (read_dentry_by_index(inode_num, &test) == 0)
// 	{
// 		printf("file_name : %s\n", test.file_name);
// 		printf("file_type : %d\n", test.file_type);
// 		printf("inode_num : %d\n", test.inode_num);
// 	}
// 	else
// 	{
// 		printf("inode_num: %d does not exist!\n", inode_num);
// 	}
// }

// /*
// * void unit_test_read_data (uint32_t index)
// *	Inputs: index (the inode number of the file to read)
// *	Return Value: none
// *	Function: tests read_data, prints debug info
// */
// void
// unit_test_read_data(uint32_t index)
// {
// 	uint8_t buf[64 * 4096 + 1];
// 	buf[64 * 4096] = '\0';

// 	int32_t read_data_retval;

// 	/* read more than the filesize of frame1.txt */
// 	read_data_retval = read_data(index, 0, buf, 10000);
// 	printf("read_data returned with value %d\n", read_data_retval);

// 	/* use an invalid offset to read frame1.txt */
// 	// read_data_retval = read_data(index, 1000, buf, 10000);
// 	// printf("read_data returned with value %d\n", read_data_retval);

// 	// /* use an invalid length to read frame1.txt */
// 	// read_data_retval = read_data(index, 10, buf, 0);
// 	// printf("read_data returned with value %d\n", read_data_retval);

// 	// /* start in the middle of frame1.txt */
// 	// read_data_retval = read_data(index, 50, buf, 10000);
// 	// printf("read_data returned with value %d\n", read_data_retval);
// }

// /*
// * void test_fs_print_filenames (int32_t print_inodes)
// *	Inputs: print_inodes (flag, if 0, doesn't print the inode numbers of every
// *			file, else, prints them)
// *	Return Value: none
// *	Function: print all filenames in the filesystem
// */
// void
// test_fs_print_filenames (int32_t print_inodes)
// {
// 	int d;
// 	for(d = 0; d < bblock->dir_entries; d++) {
// 		printf("filename: %s", bblock->dentry[d].file_name);
// 		if (print_inodes) {
// 			printf("        inode_num: %d\n", bblock->dentry[d].inode_num);
// 		} else {
// 			printf("\n");
// 		}
// 	}

// }

// /*
// * void test_fs_print_filesize (int32_t inode)
// *	Inputs: inode (inode num of the file that we want to print the size of)
// *	Return Value: none
// *	Function: prints the filesize of a file
// */
// void
// test_fs_print_filesize (int32_t inode)
// {
// 	inode_t * in = GET_INODE_ADRS(inode);
// 	printf("inode %u:, size %u\n", inode, in->length);
// }


void
test_terminal(void)
{
  402104:	55                   	push   %ebp
  402105:	89 e5                	mov    %esp,%ebp
  402107:	81 ec 78 08 00 00    	sub    $0x878,%esp
	int32_t n = 5;
  40210d:	c7 45 fc 05 00 00 00 	movl   $0x5,0xfffffffc(%ebp)
	clear();
  402114:	e8 db 07 00 00       	call   4028f4 <clear>
	int8_t scroll[2001];
	memset(scroll, 's', 2000);
  402119:	c7 44 24 08 d0 07 00 	movl   $0x7d0,0x8(%esp)
  402120:	00 
  402121:	c7 44 24 04 73 00 00 	movl   $0x73,0x4(%esp)
  402128:	00 
  402129:	8d 85 2b f8 ff ff    	lea    0xfffff82b(%ebp),%eax
  40212f:	89 04 24             	mov    %eax,(%esp)
  402132:	e8 49 0e 00 00       	call   402f80 <memset>
	scroll[2000] = '\0';
  402137:	c6 45 fb 00          	movb   $0x0,0xfffffffb(%ebp)
	printf("%s", scroll);
  40213b:	8d 85 2b f8 ff ff    	lea    0xfffff82b(%ebp),%eax
  402141:	89 44 24 04          	mov    %eax,0x4(%esp)
  402145:	c7 04 24 4b 42 40 00 	movl   $0x40424b,(%esp)
  40214c:	e8 5c 09 00 00       	call   402aad <printf>
	tOpen((uint8_t*)"hello");
  402151:	b8 4e 42 40 00       	mov    $0x40424e,%eax
  402156:	89 04 24             	mov    %eax,(%esp)
  402159:	e8 f6 1d 00 00       	call   403f54 <tOpen>
	int8_t buf[128];
	printf("%d\n", tRead(0, buf, n));
  40215e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  402161:	89 44 24 08          	mov    %eax,0x8(%esp)
  402165:	8d 85 ab f7 ff ff    	lea    0xfffff7ab(%ebp),%eax
  40216b:	89 44 24 04          	mov    %eax,0x4(%esp)
  40216f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  402176:	e8 c0 1c 00 00       	call   403e3b <tRead>
  40217b:	89 44 24 04          	mov    %eax,0x4(%esp)
  40217f:	c7 04 24 54 42 40 00 	movl   $0x404254,(%esp)
  402186:	e8 22 09 00 00       	call   402aad <printf>
	tWrite(0, buf, n);
  40218b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  40218e:	89 44 24 08          	mov    %eax,0x8(%esp)
  402192:	8d 85 ab f7 ff ff    	lea    0xfffff7ab(%ebp),%eax
  402198:	89 44 24 04          	mov    %eax,0x4(%esp)
  40219c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  4021a3:	e8 67 1d 00 00       	call   403f0f <tWrite>

}
  4021a8:	c9                   	leave  
  4021a9:	c3                   	ret    
  4021aa:	90                   	nop    
  4021ab:	90                   	nop    

004021ac <keyboard_init>:
*	Function: Initializes the keyboard
*/
void
keyboard_init(void)
{
  4021ac:	55                   	push   %ebp
  4021ad:	89 e5                	mov    %esp,%ebp
  4021af:	83 ec 18             	sub    $0x18,%esp
	/*uint8_t check;
	check = (inb(PORT_DATA)&0x01);
	if(!check){

	}*/									//maybe possible to just turn on interrupt line on PIC

	uint8_t check;
	uint8_t curCmd;
	uint32_t flags;

	cli_and_save(flags);
  4021b2:	9c                   	pushf  
  4021b3:	58                   	pop    %eax
  4021b4:	fa                   	cli    
  4021b5:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

	check = (inb(KB_STAT)&0x01);			//check to see if the buffer is full if not then we can write to it
  4021b8:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
  4021bf:	e8 54 00 00 00       	call   402218 <inb>
  4021c4:	83 e0 01             	and    $0x1,%eax
  4021c7:	88 45 fa             	mov    %al,0xfffffffa(%ebp)
	if(!check){
  4021ca:	80 7d fa 00          	cmpb   $0x0,0xfffffffa(%ebp)
  4021ce:	75 35                	jne    402205 <keyboard_init+0x59>
		outb(RD_CMD, KB_STAT);				//tell keyboard we want to read the current command bits
  4021d0:	ba 64 00 00 00       	mov    $0x64,%edx
  4021d5:	b8 20 00 00 00       	mov    $0x20,%eax
  4021da:	ee                   	out    %al,(%dx)
		curCmd = inb(KB_PORT);				//get the current command bits
  4021db:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  4021e2:	e8 31 00 00 00       	call   402218 <inb>
  4021e7:	88 45 fb             	mov    %al,0xfffffffb(%ebp)
		outb(WRT_CMD, KB_STAT);				//tell the keyboard we want to write command bits
  4021ea:	ba 64 00 00 00       	mov    $0x64,%edx
  4021ef:	b8 60 00 00 00       	mov    $0x60,%eax
  4021f4:	ee                   	out    %al,(%dx)
		outb((curCmd|SET_BITS), KB_PORT);	//enable the interrupt bit and the scancode set 1 transformation
  4021f5:	0f b6 45 fb          	movzbl 0xfffffffb(%ebp),%eax
  4021f9:	83 c8 41             	or     $0x41,%eax
  4021fc:	0f b6 c0             	movzbl %al,%eax
  4021ff:	ba 60 00 00 00       	mov    $0x60,%edx
  402204:	ee                   	out    %al,(%dx)
	}

	enable_irq(KB_IR_LINE);					//enable the interrupt line
  402205:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  40220c:	e8 e6 f2 ff ff       	call   4014f7 <enable_irq>

	// sti();
	restore_flags(flags);
  402211:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  402214:	50                   	push   %eax
  402215:	9d                   	popf   

}
  402216:	c9                   	leave  
  402217:	c3                   	ret    

00402218 <inb>:
/* Port read functions */
/* Inb reads a byte and returns its value as a zero-extended 32-bit
 * unsigned int */
static inline uint32_t inb(port)
{
  402218:	55                   	push   %ebp
  402219:	89 e5                	mov    %esp,%ebp
  40221b:	83 ec 10             	sub    $0x10,%esp
	uint32_t val;
	asm volatile("xorl %0, %0\n \
  40221e:	8b 55 08             	mov    0x8(%ebp),%edx
  402221:	31 c0                	xor    %eax,%eax
  402223:	ec                   	in     (%dx),%al
  402224:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
			inb   (%w1), %b0"
			: "=a"(val)
			: "d"(port)
			: "memory" );
	return val;
  402227:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  40222a:	c9                   	leave  
  40222b:	c3                   	ret    

0040222c <keyboard_handler>:

/*
* void keyboard_handler(void)
*   Inputs: void
*   Return Value: void
*	Function: prints out the character preseed when we get a keyboard interrupt
*/
void
keyboard_handler(void)
{
  40222c:	55                   	push   %ebp
  40222d:	89 e5                	mov    %esp,%ebp
  40222f:	83 ec 18             	sub    $0x18,%esp
	uint8_t letter;
	uint8_t check;
	uint8_t scancode;

	scancode = inb(KB_PORT);			//get the info from the keyboard_handler
  402232:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  402239:	e8 da ff ff ff       	call   402218 <inb>
  40223e:	88 45 ff             	mov    %al,0xffffffff(%ebp)
	check = scancode >> 7;				//use check to see if the key is pressed or realesed
  402241:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  402245:	c0 e8 07             	shr    $0x7,%al
  402248:	88 45 fe             	mov    %al,0xfffffffe(%ebp)

	/*Check to see if it is a key we do not want to implement*/
	if(scan2Let(scancode)==0xFF) {
  40224b:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  40224f:	89 04 24             	mov    %eax,(%esp)
  402252:	e8 69 06 00 00       	call   4028c0 <scan2Let>
  402257:	3c ff                	cmp    $0xff,%al
  402259:	0f 84 49 05 00 00    	je     4027a8 <keyboard_handler+0x57c>
	}
	/*Set up wether the caps is on or off*/
	else if((scancode==CAPS)&&(scan2Let(scancode)==0x00)){
  40225f:	80 7d ff 3a          	cmpb   $0x3a,0xffffffff(%ebp)
  402263:	75 21                	jne    402286 <keyboard_handler+0x5a>
  402265:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  402269:	89 04 24             	mov    %eax,(%esp)
  40226c:	e8 4f 06 00 00       	call   4028c0 <scan2Let>
  402271:	84 c0                	test   %al,%al
  402273:	75 11                	jne    402286 <keyboard_handler+0x5a>
		setCaps(0x01);
  402275:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  40227c:	e8 5b 06 00 00       	call   4028dc <setCaps>
  402281:	e9 22 05 00 00       	jmp    4027a8 <keyboard_handler+0x57c>
	}
	else if((scancode==CAPS)&&(scan2Let(scancode)==0x01)){
  402286:	80 7d ff 3a          	cmpb   $0x3a,0xffffffff(%ebp)
  40228a:	75 21                	jne    4022ad <keyboard_handler+0x81>
  40228c:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  402290:	89 04 24             	mov    %eax,(%esp)
  402293:	e8 28 06 00 00       	call   4028c0 <scan2Let>
  402298:	3c 01                	cmp    $0x1,%al
  40229a:	75 11                	jne    4022ad <keyboard_handler+0x81>
		setCaps(0x00);
  40229c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  4022a3:	e8 34 06 00 00       	call   4028dc <setCaps>
  4022a8:	e9 fb 04 00 00       	jmp    4027a8 <keyboard_handler+0x57c>
	}
	/*See if the user is trying to clear the screen*/
	else if(scancode==CNTRL){
  4022ad:	80 7d ff 1d          	cmpb   $0x1d,0xffffffff(%ebp)
  4022b1:	75 4f                	jne    402302 <keyboard_handler+0xd6>
		/*Wait until another key is pressed or control key is released*/
		while(!(inb(KB_STAT)&MAKE)){
  4022b3:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
  4022ba:	e8 59 ff ff ff       	call   402218 <inb>
  4022bf:	83 e0 01             	and    $0x1,%eax
  4022c2:	85 c0                	test   %eax,%eax
  4022c4:	74 ed                	je     4022b3 <keyboard_handler+0x87>
		}
		/*Check if the key is l then clear the screen if it is*/
		if(inb(KB_PORT)==CLR){
  4022c6:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  4022cd:	e8 46 ff ff ff       	call   402218 <inb>
  4022d2:	83 f8 26             	cmp    $0x26,%eax
  4022d5:	0f 85 cd 04 00 00    	jne    4027a8 <keyboard_handler+0x57c>
			/*wait until control key released to clear screen*/
			while(inb(KB_PORT)!=0x9D){
  4022db:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  4022e2:	e8 31 ff ff ff       	call   402218 <inb>
  4022e7:	3d 9d 00 00 00       	cmp    $0x9d,%eax
  4022ec:	75 ed                	jne    4022db <keyboard_handler+0xaf>
			}
			clear();					//clear the video mem
  4022ee:	e8 01 06 00 00       	call   4028f4 <clear>
			clearbuf();					//clear the terminal buffer
  4022f3:	e8 ed 1a 00 00       	call   403de5 <clearbuf>
			/*try to put cursor in top left corner*/
			updatecursor();
  4022f8:	e8 8e 10 00 00       	call   40338b <updatecursor>
  4022fd:	e9 a6 04 00 00       	jmp    4027a8 <keyboard_handler+0x57c>
		}
	}
	else if(scancode==BKSP) {
  402302:	80 7d ff 0e          	cmpb   $0xe,0xffffffff(%ebp)
  402306:	75 14                	jne    40231c <keyboard_handler+0xf0>
		backspace();
  402308:	e8 40 06 00 00       	call   40294d <backspace>
		backspacebuf();
  40230d:	e8 02 1b 00 00       	call   403e14 <backspacebuf>
		updatecursor();
  402312:	e8 74 10 00 00       	call   40338b <updatecursor>
  402317:	e9 8c 04 00 00       	jmp    4027a8 <keyboard_handler+0x57c>
	}
	/*if special key not pressed print out the key being pressed*/
	else if(!(check&MAKE)){
  40231c:	0f b6 45 fe          	movzbl 0xfffffffe(%ebp),%eax
  402320:	83 e0 01             	and    $0x1,%eax
  402323:	85 c0                	test   %eax,%eax
  402325:	0f 85 7d 04 00 00    	jne    4027a8 <keyboard_handler+0x57c>
		/*Checks to see if caps lock is off*/
		if(!scan2Let(CAPS)){
  40232b:	c7 04 24 3a 00 00 00 	movl   $0x3a,(%esp)
  402332:	e8 89 05 00 00       	call   4028c0 <scan2Let>
  402337:	84 c0                	test   %al,%al
  402339:	0f 85 10 02 00 00    	jne    40254f <keyboard_handler+0x323>
			if(scan2Let(scancode)==LSHFT){
  40233f:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  402343:	89 04 24             	mov    %eax,(%esp)
  402346:	e8 75 05 00 00       	call   4028c0 <scan2Let>
  40234b:	3c 80                	cmp    $0x80,%al
  40234d:	0f 85 d4 00 00 00    	jne    402427 <keyboard_handler+0x1fb>
				while(inb(KB_PORT)!=LUSHFT){
  402353:	e9 b3 00 00 00       	jmp    40240b <keyboard_handler+0x1df>
					while(!(inb(KB_STAT)&MAKE)){
  402358:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
  40235f:	e8 b4 fe ff ff       	call   402218 <inb>
  402364:	83 e0 01             	and    $0x1,%eax
  402367:	85 c0                	test   %eax,%eax
  402369:	74 ed                	je     402358 <keyboard_handler+0x12c>
					}
					scancode = inb(KB_PORT);
  40236b:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  402372:	e8 a1 fe ff ff       	call   402218 <inb>
  402377:	88 45 ff             	mov    %al,0xffffffff(%ebp)
					if(scancode==LUSHFT) break;
  40237a:	80 7d ff aa          	cmpb   $0xaa,0xffffffff(%ebp)
  40237e:	0f 84 24 04 00 00    	je     4027a8 <keyboard_handler+0x57c>
					letter = scan2Let(scancode);
  402384:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  402388:	89 04 24             	mov    %eax,(%esp)
  40238b:	e8 30 05 00 00       	call   4028c0 <scan2Let>
  402390:	88 45 fd             	mov    %al,0xfffffffd(%ebp)
					if(scancode<SCANLIMIT){
  402393:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  402397:	84 c0                	test   %al,%al
  402399:	78 70                	js     40240b <keyboard_handler+0x1df>
						if((letter>LOWERLET)&&(letter<UPPERLET)){
  40239b:	80 7d fd 60          	cmpb   $0x60,0xfffffffd(%ebp)
  40239f:	76 36                	jbe    4023d7 <keyboard_handler+0x1ab>
  4023a1:	80 7d fd 7a          	cmpb   $0x7a,0xfffffffd(%ebp)
  4023a5:	77 30                	ja     4023d7 <keyboard_handler+0x1ab>
							printf("%c", letter-CAPCHANGE);
  4023a7:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  4023ab:	83 e8 20             	sub    $0x20,%eax
  4023ae:	89 44 24 04          	mov    %eax,0x4(%esp)
  4023b2:	c7 04 24 58 42 40 00 	movl   $0x404258,(%esp)
  4023b9:	e8 ef 06 00 00       	call   402aad <printf>
							updatecursor();
  4023be:	e8 c8 0f 00 00       	call   40338b <updatecursor>
							insert(letter-CAPCHANGE);
  4023c3:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  4023c7:	83 e8 20             	sub    $0x20,%eax
  4023ca:	0f b6 c0             	movzbl %al,%eax
  4023cd:	89 04 24             	mov    %eax,(%esp)
  4023d0:	e8 db 19 00 00       	call   403db0 <insert>
  4023d5:	eb 34                	jmp    40240b <keyboard_handler+0x1df>
						}
						else {
							letter = getShift(letter);
  4023d7:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  4023db:	89 04 24             	mov    %eax,(%esp)
  4023de:	e8 d3 03 00 00       	call   4027b6 <getShift>
  4023e3:	88 45 fd             	mov    %al,0xfffffffd(%ebp)
							printf("%c", letter);
  4023e6:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  4023ea:	89 44 24 04          	mov    %eax,0x4(%esp)
  4023ee:	c7 04 24 58 42 40 00 	movl   $0x404258,(%esp)
  4023f5:	e8 b3 06 00 00       	call   402aad <printf>
							updatecursor();
  4023fa:	e8 8c 0f 00 00       	call   40338b <updatecursor>
							insert(letter);
  4023ff:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  402403:	89 04 24             	mov    %eax,(%esp)
  402406:	e8 a5 19 00 00       	call   403db0 <insert>
  40240b:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  402412:	e8 01 fe ff ff       	call   402218 <inb>
  402417:	3d aa 00 00 00       	cmp    $0xaa,%eax
  40241c:	0f 85 36 ff ff ff    	jne    402358 <keyboard_handler+0x12c>
  402422:	e9 81 03 00 00       	jmp    4027a8 <keyboard_handler+0x57c>
						}
					}
				}
			}
			else if(scan2Let(scancode)==RSHFT){
  402427:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  40242b:	89 04 24             	mov    %eax,(%esp)
  40242e:	e8 8d 04 00 00       	call   4028c0 <scan2Let>
  402433:	3c 81                	cmp    $0x81,%al
  402435:	0f 85 d4 00 00 00    	jne    40250f <keyboard_handler+0x2e3>
				//printf("%x", scancode);
				while(inb(KB_PORT)!=RUSHFT){
  40243b:	e9 b3 00 00 00       	jmp    4024f3 <keyboard_handler+0x2c7>
					while(!(inb(KB_STAT)&MAKE)){
  402440:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
  402447:	e8 cc fd ff ff       	call   402218 <inb>
  40244c:	83 e0 01             	and    $0x1,%eax
  40244f:	85 c0                	test   %eax,%eax
  402451:	74 ed                	je     402440 <keyboard_handler+0x214>
					}
					scancode = inb(KB_PORT);
  402453:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  40245a:	e8 b9 fd ff ff       	call   402218 <inb>
  40245f:	88 45 ff             	mov    %al,0xffffffff(%ebp)
					if(scancode==RUSHFT) break;
  402462:	80 7d ff b6          	cmpb   $0xb6,0xffffffff(%ebp)
  402466:	0f 84 3c 03 00 00    	je     4027a8 <keyboard_handler+0x57c>
					letter = scan2Let(scancode);
  40246c:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  402470:	89 04 24             	mov    %eax,(%esp)
  402473:	e8 48 04 00 00       	call   4028c0 <scan2Let>
  402478:	88 45 fd             	mov    %al,0xfffffffd(%ebp)
					if(scancode<SCANLIMIT){
  40247b:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  40247f:	84 c0                	test   %al,%al
  402481:	78 70                	js     4024f3 <keyboard_handler+0x2c7>
						if((letter>LOWERLET)&&(letter<UPPERLET)){
  402483:	80 7d fd 60          	cmpb   $0x60,0xfffffffd(%ebp)
  402487:	76 36                	jbe    4024bf <keyboard_handler+0x293>
  402489:	80 7d fd 7a          	cmpb   $0x7a,0xfffffffd(%ebp)
  40248d:	77 30                	ja     4024bf <keyboard_handler+0x293>
							printf("%c", letter-CAPCHANGE);
  40248f:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  402493:	83 e8 20             	sub    $0x20,%eax
  402496:	89 44 24 04          	mov    %eax,0x4(%esp)
  40249a:	c7 04 24 58 42 40 00 	movl   $0x404258,(%esp)
  4024a1:	e8 07 06 00 00       	call   402aad <printf>
							updatecursor();
  4024a6:	e8 e0 0e 00 00       	call   40338b <updatecursor>
							insert(letter-CAPCHANGE);
  4024ab:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  4024af:	83 e8 20             	sub    $0x20,%eax
  4024b2:	0f b6 c0             	movzbl %al,%eax
  4024b5:	89 04 24             	mov    %eax,(%esp)
  4024b8:	e8 f3 18 00 00       	call   403db0 <insert>
  4024bd:	eb 34                	jmp    4024f3 <keyboard_handler+0x2c7>
						}
						else {
							letter = getShift(letter);
  4024bf:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  4024c3:	89 04 24             	mov    %eax,(%esp)
  4024c6:	e8 eb 02 00 00       	call   4027b6 <getShift>
  4024cb:	88 45 fd             	mov    %al,0xfffffffd(%ebp)
							printf("%c", letter);
  4024ce:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  4024d2:	89 44 24 04          	mov    %eax,0x4(%esp)
  4024d6:	c7 04 24 58 42 40 00 	movl   $0x404258,(%esp)
  4024dd:	e8 cb 05 00 00       	call   402aad <printf>
							updatecursor();
  4024e2:	e8 a4 0e 00 00       	call   40338b <updatecursor>
							insert(letter);
  4024e7:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  4024eb:	89 04 24             	mov    %eax,(%esp)
  4024ee:	e8 bd 18 00 00       	call   403db0 <insert>
  4024f3:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  4024fa:	e8 19 fd ff ff       	call   402218 <inb>
  4024ff:	3d b6 00 00 00       	cmp    $0xb6,%eax
  402504:	0f 85 36 ff ff ff    	jne    402440 <keyboard_handler+0x214>
  40250a:	e9 99 02 00 00       	jmp    4027a8 <keyboard_handler+0x57c>
						}
					}
				}
			}
			else {
				printf("%c", scan2Let(scancode));		//print the character if it is being pressed
  40250f:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  402513:	89 04 24             	mov    %eax,(%esp)
  402516:	e8 a5 03 00 00       	call   4028c0 <scan2Let>
  40251b:	0f b6 c0             	movzbl %al,%eax
  40251e:	89 44 24 04          	mov    %eax,0x4(%esp)
  402522:	c7 04 24 58 42 40 00 	movl   $0x404258,(%esp)
  402529:	e8 7f 05 00 00       	call   402aad <printf>
				updatecursor();
  40252e:	e8 58 0e 00 00       	call   40338b <updatecursor>
				insert(scan2Let(scancode));
  402533:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  402537:	89 04 24             	mov    %eax,(%esp)
  40253a:	e8 81 03 00 00       	call   4028c0 <scan2Let>
  40253f:	0f b6 c0             	movzbl %al,%eax
  402542:	89 04 24             	mov    %eax,(%esp)
  402545:	e8 66 18 00 00       	call   403db0 <insert>
  40254a:	e9 59 02 00 00       	jmp    4027a8 <keyboard_handler+0x57c>
			}
		}
		else if(scan2Let(CAPS)){
  40254f:	c7 04 24 3a 00 00 00 	movl   $0x3a,(%esp)
  402556:	e8 65 03 00 00       	call   4028c0 <scan2Let>
  40255b:	84 c0                	test   %al,%al
  40255d:	0f 84 45 02 00 00    	je     4027a8 <keyboard_handler+0x57c>
			if(scan2Let(scancode)==LSHFT){
  402563:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  402567:	89 04 24             	mov    %eax,(%esp)
  40256a:	e8 51 03 00 00       	call   4028c0 <scan2Let>
  40256f:	3c 80                	cmp    $0x80,%al
  402571:	0f 85 d8 00 00 00    	jne    40264f <keyboard_handler+0x423>
				while(inb(KB_PORT)!=LUSHFT){
  402577:	e9 b7 00 00 00       	jmp    402633 <keyboard_handler+0x407>
					while(!(inb(KB_STAT)&MAKE)){
  40257c:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
  402583:	e8 90 fc ff ff       	call   402218 <inb>
  402588:	83 e0 01             	and    $0x1,%eax
  40258b:	85 c0                	test   %eax,%eax
  40258d:	74 ed                	je     40257c <keyboard_handler+0x350>
					}
					if(inb(KB_PORT)==LUSHFT) break;
  40258f:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  402596:	e8 7d fc ff ff       	call   402218 <inb>
  40259b:	3d aa 00 00 00       	cmp    $0xaa,%eax
  4025a0:	0f 84 02 02 00 00    	je     4027a8 <keyboard_handler+0x57c>
					scancode = inb(KB_PORT);
  4025a6:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  4025ad:	e8 66 fc ff ff       	call   402218 <inb>
  4025b2:	88 45 ff             	mov    %al,0xffffffff(%ebp)
					letter = scan2Let(scancode);
  4025b5:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  4025b9:	89 04 24             	mov    %eax,(%esp)
  4025bc:	e8 ff 02 00 00       	call   4028c0 <scan2Let>
  4025c1:	88 45 fd             	mov    %al,0xfffffffd(%ebp)
					if(scancode<SCANLIMIT){
  4025c4:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  4025c8:	84 c0                	test   %al,%al
  4025ca:	78 67                	js     402633 <keyboard_handler+0x407>
						if((letter>LOWERLET)&&(letter<UPPERLET)){
  4025cc:	80 7d fd 60          	cmpb   $0x60,0xfffffffd(%ebp)
  4025d0:	76 2d                	jbe    4025ff <keyboard_handler+0x3d3>
  4025d2:	80 7d fd 7a          	cmpb   $0x7a,0xfffffffd(%ebp)
  4025d6:	77 27                	ja     4025ff <keyboard_handler+0x3d3>
							printf("%c", letter);
  4025d8:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  4025dc:	89 44 24 04          	mov    %eax,0x4(%esp)
  4025e0:	c7 04 24 58 42 40 00 	movl   $0x404258,(%esp)
  4025e7:	e8 c1 04 00 00       	call   402aad <printf>
							updatecursor();
  4025ec:	e8 9a 0d 00 00       	call   40338b <updatecursor>
							insert(letter);
  4025f1:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  4025f5:	89 04 24             	mov    %eax,(%esp)
  4025f8:	e8 b3 17 00 00       	call   403db0 <insert>
  4025fd:	eb 34                	jmp    402633 <keyboard_handler+0x407>
						}
						else {
							letter = getShift(letter);
  4025ff:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  402603:	89 04 24             	mov    %eax,(%esp)
  402606:	e8 ab 01 00 00       	call   4027b6 <getShift>
  40260b:	88 45 fd             	mov    %al,0xfffffffd(%ebp)
							printf("%c", letter);
  40260e:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  402612:	89 44 24 04          	mov    %eax,0x4(%esp)
  402616:	c7 04 24 58 42 40 00 	movl   $0x404258,(%esp)
  40261d:	e8 8b 04 00 00       	call   402aad <printf>
							updatecursor();
  402622:	e8 64 0d 00 00       	call   40338b <updatecursor>
							insert(letter);
  402627:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  40262b:	89 04 24             	mov    %eax,(%esp)
  40262e:	e8 7d 17 00 00       	call   403db0 <insert>
  402633:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  40263a:	e8 d9 fb ff ff       	call   402218 <inb>
  40263f:	3d aa 00 00 00       	cmp    $0xaa,%eax
  402644:	0f 85 32 ff ff ff    	jne    40257c <keyboard_handler+0x350>
  40264a:	e9 59 01 00 00       	jmp    4027a8 <keyboard_handler+0x57c>
						}
					}
				}
			}
			else if(scan2Let(scancode)==RSHFT){
  40264f:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  402653:	89 04 24             	mov    %eax,(%esp)
  402656:	e8 65 02 00 00       	call   4028c0 <scan2Let>
  40265b:	3c 81                	cmp    $0x81,%al
  40265d:	0f 85 d5 00 00 00    	jne    402738 <keyboard_handler+0x50c>
				//printf("%x", scancode);
				while(inb(KB_PORT)!=RUSHFT){
  402663:	e9 b7 00 00 00       	jmp    40271f <keyboard_handler+0x4f3>
					while(!(inb(KB_STAT)&MAKE)){
  402668:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
  40266f:	e8 a4 fb ff ff       	call   402218 <inb>
  402674:	83 e0 01             	and    $0x1,%eax
  402677:	85 c0                	test   %eax,%eax
  402679:	74 ed                	je     402668 <keyboard_handler+0x43c>
					}
					if(inb(KB_PORT)==RUSHFT) break;
  40267b:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  402682:	e8 91 fb ff ff       	call   402218 <inb>
  402687:	3d b6 00 00 00       	cmp    $0xb6,%eax
  40268c:	0f 84 16 01 00 00    	je     4027a8 <keyboard_handler+0x57c>
					scancode = inb(KB_PORT);
  402692:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  402699:	e8 7a fb ff ff       	call   402218 <inb>
  40269e:	88 45 ff             	mov    %al,0xffffffff(%ebp)
					letter = scan2Let(scancode);
  4026a1:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  4026a5:	89 04 24             	mov    %eax,(%esp)
  4026a8:	e8 13 02 00 00       	call   4028c0 <scan2Let>
  4026ad:	88 45 fd             	mov    %al,0xfffffffd(%ebp)
					if(scancode<SCANLIMIT){
  4026b0:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  4026b4:	84 c0                	test   %al,%al
  4026b6:	78 67                	js     40271f <keyboard_handler+0x4f3>
						if((letter>LOWERLET)&&(letter<UPPERLET)){
  4026b8:	80 7d fd 60          	cmpb   $0x60,0xfffffffd(%ebp)
  4026bc:	76 2d                	jbe    4026eb <keyboard_handler+0x4bf>
  4026be:	80 7d fd 7a          	cmpb   $0x7a,0xfffffffd(%ebp)
  4026c2:	77 27                	ja     4026eb <keyboard_handler+0x4bf>
							printf("%c", letter);
  4026c4:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  4026c8:	89 44 24 04          	mov    %eax,0x4(%esp)
  4026cc:	c7 04 24 58 42 40 00 	movl   $0x404258,(%esp)
  4026d3:	e8 d5 03 00 00       	call   402aad <printf>
							updatecursor();
  4026d8:	e8 ae 0c 00 00       	call   40338b <updatecursor>
							insert(letter);
  4026dd:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  4026e1:	89 04 24             	mov    %eax,(%esp)
  4026e4:	e8 c7 16 00 00       	call   403db0 <insert>
  4026e9:	eb 34                	jmp    40271f <keyboard_handler+0x4f3>
						}
						else {
							letter = getShift(letter);
  4026eb:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  4026ef:	89 04 24             	mov    %eax,(%esp)
  4026f2:	e8 bf 00 00 00       	call   4027b6 <getShift>
  4026f7:	88 45 fd             	mov    %al,0xfffffffd(%ebp)
							printf("%c", letter);
  4026fa:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  4026fe:	89 44 24 04          	mov    %eax,0x4(%esp)
  402702:	c7 04 24 58 42 40 00 	movl   $0x404258,(%esp)
  402709:	e8 9f 03 00 00       	call   402aad <printf>
							updatecursor();
  40270e:	e8 78 0c 00 00       	call   40338b <updatecursor>
							insert(letter);
  402713:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  402717:	89 04 24             	mov    %eax,(%esp)
  40271a:	e8 91 16 00 00       	call   403db0 <insert>
  40271f:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  402726:	e8 ed fa ff ff       	call   402218 <inb>
  40272b:	3d b6 00 00 00       	cmp    $0xb6,%eax
  402730:	0f 85 32 ff ff ff    	jne    402668 <keyboard_handler+0x43c>
  402736:	eb 70                	jmp    4027a8 <keyboard_handler+0x57c>
						}
					}
				}
			}
			else
			{
				letter = scan2Let(scancode);
  402738:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  40273c:	89 04 24             	mov    %eax,(%esp)
  40273f:	e8 7c 01 00 00       	call   4028c0 <scan2Let>
  402744:	88 45 fd             	mov    %al,0xfffffffd(%ebp)
				if((letter>LOWERLET)&&(letter<UPPERLET)){
  402747:	80 7d fd 60          	cmpb   $0x60,0xfffffffd(%ebp)
  40274b:	76 36                	jbe    402783 <keyboard_handler+0x557>
  40274d:	80 7d fd 7a          	cmpb   $0x7a,0xfffffffd(%ebp)
  402751:	77 30                	ja     402783 <keyboard_handler+0x557>
			 		printf("%c", letter-CAPCHANGE);		//print the character if it is being pressed
  402753:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  402757:	83 e8 20             	sub    $0x20,%eax
  40275a:	89 44 24 04          	mov    %eax,0x4(%esp)
  40275e:	c7 04 24 58 42 40 00 	movl   $0x404258,(%esp)
  402765:	e8 43 03 00 00       	call   402aad <printf>
					updatecursor();
  40276a:	e8 1c 0c 00 00       	call   40338b <updatecursor>
					insert(letter-CAPCHANGE);
  40276f:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  402773:	83 e8 20             	sub    $0x20,%eax
  402776:	0f b6 c0             	movzbl %al,%eax
  402779:	89 04 24             	mov    %eax,(%esp)
  40277c:	e8 2f 16 00 00       	call   403db0 <insert>
  402781:	eb 25                	jmp    4027a8 <keyboard_handler+0x57c>
				}
				else {
					printf("%c", letter);
  402783:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  402787:	89 44 24 04          	mov    %eax,0x4(%esp)
  40278b:	c7 04 24 58 42 40 00 	movl   $0x404258,(%esp)
  402792:	e8 16 03 00 00       	call   402aad <printf>
					updatecursor();
  402797:	e8 ef 0b 00 00       	call   40338b <updatecursor>
					insert(letter);
  40279c:	0f b6 45 fd          	movzbl 0xfffffffd(%ebp),%eax
  4027a0:	89 04 24             	mov    %eax,(%esp)
  4027a3:	e8 08 16 00 00       	call   403db0 <insert>
				}
			}
		}
	}
	send_eoi(KB_IR_LINE);					//must send eoi to PIC when done
  4027a8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  4027af:	e8 49 ee ff ff       	call   4015fd <send_eoi>
}
  4027b4:	c9                   	leave  
  4027b5:	c3                   	ret    

004027b6 <getShift>:

uint8_t
/*Get the shifted keys for non alphabet keys(could not find an easy way to convert from one to the other)*/
getShift(uint8_t letter)
{
  4027b6:	55                   	push   %ebp
  4027b7:	89 e5                	mov    %esp,%ebp
  4027b9:	83 ec 0c             	sub    $0xc,%esp
  4027bc:	8b 45 08             	mov    0x8(%ebp),%eax
  4027bf:	88 45 fc             	mov    %al,0xfffffffc(%ebp)
	switch (letter) {
  4027c2:	0f b6 45 fc          	movzbl 0xfffffffc(%ebp),%eax
  4027c6:	83 e8 27             	sub    $0x27,%eax
  4027c9:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  4027cc:	83 7d f4 39          	cmpl   $0x39,0xfffffff4(%ebp)
  4027d0:	0f 87 de 00 00 00    	ja     4028b4 <getShift+0xfe>
  4027d6:	8b 55 f4             	mov    0xfffffff4(%ebp),%edx
  4027d9:	8b 04 95 5c 42 40 00 	mov    0x40425c(,%edx,4),%eax
  4027e0:	ff e0                	jmp    *%eax
		case '`':
			return '~';
  4027e2:	c7 45 f8 7e 00 00 00 	movl   $0x7e,0xfffffff8(%ebp)
  4027e9:	e9 cd 00 00 00       	jmp    4028bb <getShift+0x105>
		case '1':
			return '!';
  4027ee:	c7 45 f8 21 00 00 00 	movl   $0x21,0xfffffff8(%ebp)
  4027f5:	e9 c1 00 00 00       	jmp    4028bb <getShift+0x105>
		case '2':
			return '@';
  4027fa:	c7 45 f8 40 00 00 00 	movl   $0x40,0xfffffff8(%ebp)
  402801:	e9 b5 00 00 00       	jmp    4028bb <getShift+0x105>
		case '3':
			return '#';
  402806:	c7 45 f8 23 00 00 00 	movl   $0x23,0xfffffff8(%ebp)
  40280d:	e9 a9 00 00 00       	jmp    4028bb <getShift+0x105>
		case '4':
			return '$';
  402812:	c7 45 f8 24 00 00 00 	movl   $0x24,0xfffffff8(%ebp)
  402819:	e9 9d 00 00 00       	jmp    4028bb <getShift+0x105>
		case '5':
			return '%';
  40281e:	c7 45 f8 25 00 00 00 	movl   $0x25,0xfffffff8(%ebp)
  402825:	e9 91 00 00 00       	jmp    4028bb <getShift+0x105>
		case '6':
			return '^';
  40282a:	c7 45 f8 5e 00 00 00 	movl   $0x5e,0xfffffff8(%ebp)
  402831:	e9 85 00 00 00       	jmp    4028bb <getShift+0x105>
		case '7':
			return '&';
  402836:	c7 45 f8 26 00 00 00 	movl   $0x26,0xfffffff8(%ebp)
  40283d:	eb 7c                	jmp    4028bb <getShift+0x105>
		case '8':
			return '*';
  40283f:	c7 45 f8 2a 00 00 00 	movl   $0x2a,0xfffffff8(%ebp)
  402846:	eb 73                	jmp    4028bb <getShift+0x105>
		case '9':
			return '(';
  402848:	c7 45 f8 28 00 00 00 	movl   $0x28,0xfffffff8(%ebp)
  40284f:	eb 6a                	jmp    4028bb <getShift+0x105>
		case '0':
			return ')';
  402851:	c7 45 f8 29 00 00 00 	movl   $0x29,0xfffffff8(%ebp)
  402858:	eb 61                	jmp    4028bb <getShift+0x105>
		case '-':
			return '_';
  40285a:	c7 45 f8 5f 00 00 00 	movl   $0x5f,0xfffffff8(%ebp)
  402861:	eb 58                	jmp    4028bb <getShift+0x105>
		case '=':
			return '+';
  402863:	c7 45 f8 2b 00 00 00 	movl   $0x2b,0xfffffff8(%ebp)
  40286a:	eb 4f                	jmp    4028bb <getShift+0x105>
		case '[':
			return '{';
  40286c:	c7 45 f8 7b 00 00 00 	movl   $0x7b,0xfffffff8(%ebp)
  402873:	eb 46                	jmp    4028bb <getShift+0x105>
		case ']':
			return '}';
  402875:	c7 45 f8 7d 00 00 00 	movl   $0x7d,0xfffffff8(%ebp)
  40287c:	eb 3d                	jmp    4028bb <getShift+0x105>
		case 0x5C:
			return '|';
  40287e:	c7 45 f8 7c 00 00 00 	movl   $0x7c,0xfffffff8(%ebp)
  402885:	eb 34                	jmp    4028bb <getShift+0x105>
		case ';':
			return ':';
  402887:	c7 45 f8 3a 00 00 00 	movl   $0x3a,0xfffffff8(%ebp)
  40288e:	eb 2b                	jmp    4028bb <getShift+0x105>
		case 0x27:
			return '"';
  402890:	c7 45 f8 22 00 00 00 	movl   $0x22,0xfffffff8(%ebp)
  402897:	eb 22                	jmp    4028bb <getShift+0x105>
		case ',':
			return '<';
  402899:	c7 45 f8 3c 00 00 00 	movl   $0x3c,0xfffffff8(%ebp)
  4028a0:	eb 19                	jmp    4028bb <getShift+0x105>
		case '.':
			return '>';
  4028a2:	c7 45 f8 3e 00 00 00 	movl   $0x3e,0xfffffff8(%ebp)
  4028a9:	eb 10                	jmp    4028bb <getShift+0x105>
		case '/':
			return '?';
  4028ab:	c7 45 f8 3f 00 00 00 	movl   $0x3f,0xfffffff8(%ebp)
  4028b2:	eb 07                	jmp    4028bb <getShift+0x105>
		default:
			return -1;
  4028b4:	c7 45 f8 ff 00 00 00 	movl   $0xff,0xfffffff8(%ebp)
  4028bb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
	}
}
  4028be:	c9                   	leave  
  4028bf:	c3                   	ret    

004028c0 <scan2Let>:


uint8_t
scan2Let(uint8_t scancode)
{
  4028c0:	55                   	push   %ebp
  4028c1:	89 e5                	mov    %esp,%ebp
  4028c3:	83 ec 04             	sub    $0x4,%esp
  4028c6:	8b 45 08             	mov    0x8(%ebp),%eax
  4028c9:	88 45 fc             	mov    %al,0xfffffffc(%ebp)
	return getChar[scancode];
  4028cc:	0f b6 45 fc          	movzbl 0xfffffffc(%ebp),%eax
  4028d0:	0f b6 80 40 50 40 00 	movzbl 0x405040(%eax),%eax
  4028d7:	0f b6 c0             	movzbl %al,%eax
}
  4028da:	c9                   	leave  
  4028db:	c3                   	ret    

004028dc <setCaps>:

void
setCaps(uint8_t set)
{
  4028dc:	55                   	push   %ebp
  4028dd:	89 e5                	mov    %esp,%ebp
  4028df:	83 ec 04             	sub    $0x4,%esp
  4028e2:	8b 45 08             	mov    0x8(%ebp),%eax
  4028e5:	88 45 fc             	mov    %al,0xfffffffc(%ebp)
	getChar[CAPS] = set;
  4028e8:	0f b6 45 fc          	movzbl 0xfffffffc(%ebp),%eax
  4028ec:	a2 7a 50 40 00       	mov    %al,0x40507a
}
  4028f1:	c9                   	leave  
  4028f2:	c3                   	ret    
  4028f3:	90                   	nop    

004028f4 <clear>:
*/

void
clear(void)
{
  4028f4:	55                   	push   %ebp
  4028f5:	89 e5                	mov    %esp,%ebp
  4028f7:	83 ec 10             	sub    $0x10,%esp
    int32_t i;
    for(i=0; i<NUM_ROWS*NUM_COLS; i++) {
  4028fa:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  402901:	eb 2b                	jmp    40292e <clear+0x3a>
        *(uint8_t *)(video_mem + (i << 1)) = ' ';
  402903:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  402906:	01 c0                	add    %eax,%eax
  402908:	89 c2                	mov    %eax,%edx
  40290a:	a1 c0 50 40 00       	mov    0x4050c0,%eax
  40290f:	8d 04 02             	lea    (%edx,%eax,1),%eax
  402912:	c6 00 20             	movb   $0x20,(%eax)
        *(uint8_t *)(video_mem + (i << 1) + 1) = ATTRIB;
  402915:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  402918:	01 c0                	add    %eax,%eax
  40291a:	89 c2                	mov    %eax,%edx
  40291c:	a1 c0 50 40 00       	mov    0x4050c0,%eax
  402921:	8d 04 02             	lea    (%edx,%eax,1),%eax
  402924:	83 c0 01             	add    $0x1,%eax
  402927:	c6 00 07             	movb   $0x7,(%eax)
  40292a:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  40292e:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,0xfffffffc(%ebp)
  402935:	7e cc                	jle    402903 <clear+0xf>
    }
	screen_y = 0;
  402937:	c7 05 04 d0 40 00 00 	movl   $0x0,0x40d004
  40293e:	00 00 00 
	screen_x = 0;
  402941:	c7 05 00 d0 40 00 00 	movl   $0x0,0x40d000
  402948:	00 00 00 
}
  40294b:	c9                   	leave  
  40294c:	c3                   	ret    

0040294d <backspace>:

void
backspace(void) {
  40294d:	55                   	push   %ebp
  40294e:	89 e5                	mov    %esp,%ebp
  402950:	53                   	push   %ebx
  402951:	83 ec 0c             	sub    $0xc,%esp
	if(screen_y>0) {
  402954:	a1 04 d0 40 00       	mov    0x40d004,%eax
  402959:	85 c0                	test   %eax,%eax
  40295b:	0f 8e d2 00 00 00    	jle    402a33 <backspace+0xe6>
		if(screen_x==0) {
  402961:	a1 00 d0 40 00       	mov    0x40d000,%eax
  402966:	85 c0                	test   %eax,%eax
  402968:	75 1c                	jne    402986 <backspace+0x39>
			screen_x = 79;
  40296a:	c7 05 00 d0 40 00 4f 	movl   $0x4f,0x40d000
  402971:	00 00 00 
			screen_y--;
  402974:	a1 04 d0 40 00       	mov    0x40d004,%eax
  402979:	83 e8 01             	sub    $0x1,%eax
  40297c:	a3 04 d0 40 00       	mov    %eax,0x40d004
  402981:	e9 cc 00 00 00       	jmp    402a52 <backspace+0x105>
		}
		else{
			screen_x--;
  402986:	a1 00 d0 40 00       	mov    0x40d000,%eax
  40298b:	83 e8 01             	sub    $0x1,%eax
  40298e:	a3 00 d0 40 00       	mov    %eax,0x40d000
			screen_x %= NUM_COLS;
  402993:	8b 0d 00 d0 40 00    	mov    0x40d000,%ecx
  402999:	c7 45 f0 67 66 66 66 	movl   $0x66666667,0xfffffff0(%ebp)
  4029a0:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  4029a3:	f7 e9                	imul   %ecx
  4029a5:	c1 fa 05             	sar    $0x5,%edx
  4029a8:	89 c8                	mov    %ecx,%eax
  4029aa:	c1 f8 1f             	sar    $0x1f,%eax
  4029ad:	89 d3                	mov    %edx,%ebx
  4029af:	29 c3                	sub    %eax,%ebx
  4029b1:	89 5d f4             	mov    %ebx,0xfffffff4(%ebp)
  4029b4:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  4029b7:	c1 e0 02             	shl    $0x2,%eax
  4029ba:	03 45 f4             	add    0xfffffff4(%ebp),%eax
  4029bd:	c1 e0 04             	shl    $0x4,%eax
  4029c0:	89 ca                	mov    %ecx,%edx
  4029c2:	29 c2                	sub    %eax,%edx
  4029c4:	89 55 f4             	mov    %edx,0xfffffff4(%ebp)
  4029c7:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
  4029ca:	89 1d 00 d0 40 00    	mov    %ebx,0x40d000
			screen_y = (screen_y + (screen_x / NUM_COLS)) % NUM_ROWS;
  4029d0:	8b 0d 00 d0 40 00    	mov    0x40d000,%ecx
  4029d6:	c7 45 f0 67 66 66 66 	movl   $0x66666667,0xfffffff0(%ebp)
  4029dd:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  4029e0:	f7 e9                	imul   %ecx
  4029e2:	c1 fa 05             	sar    $0x5,%edx
  4029e5:	89 c8                	mov    %ecx,%eax
  4029e7:	c1 f8 1f             	sar    $0x1f,%eax
  4029ea:	29 c2                	sub    %eax,%edx
  4029ec:	a1 04 d0 40 00       	mov    0x40d004,%eax
  4029f1:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  4029f4:	c7 45 f0 1f 85 eb 51 	movl   $0x51eb851f,0xfffffff0(%ebp)
  4029fb:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  4029fe:	f7 e9                	imul   %ecx
  402a00:	c1 fa 03             	sar    $0x3,%edx
  402a03:	89 c8                	mov    %ecx,%eax
  402a05:	c1 f8 1f             	sar    $0x1f,%eax
  402a08:	89 d3                	mov    %edx,%ebx
  402a0a:	29 c3                	sub    %eax,%ebx
  402a0c:	89 5d f8             	mov    %ebx,0xfffffff8(%ebp)
  402a0f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  402a12:	c1 e0 02             	shl    $0x2,%eax
  402a15:	03 45 f8             	add    0xfffffff8(%ebp),%eax
  402a18:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  402a1f:	01 d0                	add    %edx,%eax
  402a21:	89 ca                	mov    %ecx,%edx
  402a23:	29 c2                	sub    %eax,%edx
  402a25:	89 55 f8             	mov    %edx,0xfffffff8(%ebp)
  402a28:	8b 5d f8             	mov    0xfffffff8(%ebp),%ebx
  402a2b:	89 1d 04 d0 40 00    	mov    %ebx,0x40d004
  402a31:	eb 1f                	jmp    402a52 <backspace+0x105>
		}
	}
	else if(screen_y==0){
  402a33:	a1 04 d0 40 00       	mov    0x40d004,%eax
  402a38:	85 c0                	test   %eax,%eax
  402a3a:	75 16                	jne    402a52 <backspace+0x105>
		if(screen_x>0) screen_x--;
  402a3c:	a1 00 d0 40 00       	mov    0x40d000,%eax
  402a41:	85 c0                	test   %eax,%eax
  402a43:	7e 0d                	jle    402a52 <backspace+0x105>
  402a45:	a1 00 d0 40 00       	mov    0x40d000,%eax
  402a4a:	83 e8 01             	sub    $0x1,%eax
  402a4d:	a3 00 d0 40 00       	mov    %eax,0x40d000
	}
	*(uint8_t *)(video_mem + ((NUM_COLS*screen_y + screen_x) << 1)) = ' ';
  402a52:	8b 15 04 d0 40 00    	mov    0x40d004,%edx
  402a58:	89 d0                	mov    %edx,%eax
  402a5a:	c1 e0 02             	shl    $0x2,%eax
  402a5d:	01 d0                	add    %edx,%eax
  402a5f:	c1 e0 04             	shl    $0x4,%eax
  402a62:	89 c2                	mov    %eax,%edx
  402a64:	a1 00 d0 40 00       	mov    0x40d000,%eax
  402a69:	8d 04 02             	lea    (%edx,%eax,1),%eax
  402a6c:	01 c0                	add    %eax,%eax
  402a6e:	89 c2                	mov    %eax,%edx
  402a70:	a1 c0 50 40 00       	mov    0x4050c0,%eax
  402a75:	8d 04 02             	lea    (%edx,%eax,1),%eax
  402a78:	c6 00 20             	movb   $0x20,(%eax)
	*(uint8_t *)(video_mem + ((NUM_COLS*screen_y + screen_x) << 1) + 1) = ATTRIB;
  402a7b:	8b 15 04 d0 40 00    	mov    0x40d004,%edx
  402a81:	89 d0                	mov    %edx,%eax
  402a83:	c1 e0 02             	shl    $0x2,%eax
  402a86:	01 d0                	add    %edx,%eax
  402a88:	c1 e0 04             	shl    $0x4,%eax
  402a8b:	89 c2                	mov    %eax,%edx
  402a8d:	a1 00 d0 40 00       	mov    0x40d000,%eax
  402a92:	8d 04 02             	lea    (%edx,%eax,1),%eax
  402a95:	01 c0                	add    %eax,%eax
  402a97:	89 c2                	mov    %eax,%edx
  402a99:	a1 c0 50 40 00       	mov    0x4050c0,%eax
  402a9e:	8d 04 02             	lea    (%edx,%eax,1),%eax
  402aa1:	83 c0 01             	add    $0x1,%eax
  402aa4:	c6 00 07             	movb   $0x7,(%eax)
}
  402aa7:	83 c4 0c             	add    $0xc,%esp
  402aaa:	5b                   	pop    %ebx
  402aab:	5d                   	pop    %ebp
  402aac:	c3                   	ret    

00402aad <printf>:

/* Standard printf().
 * Only supports the following format strings:
 * %%  - print a literal '%' character
 * %x  - print a number in hexadecimal
 * %u  - print a number as an unsigned integer
 * %d  - print a number as a signed integer
 * %c  - print a character
 * %s  - print a string
 * %#x - print a number in 32-bit aligned hexadecimal, i.e.
 *       print 8 hexadecimal digits, zero-padded on the left.
 *       For example, the hex number "E" would be printed as
 *       "0000000E".
 *       Note: This is slightly different than the libc specification
 *       for the "#" modifier (this implementation doesn't add a "0x" at
 *       the beginning), but I think it's more flexible this way.
 *       Also note: %x is the only conversion specifier that can use
 *       the "#" modifier to alter output.
 * */
int32_t
printf(int8_t *format, ...)
{
  402aad:	55                   	push   %ebp
  402aae:	89 e5                	mov    %esp,%ebp
  402ab0:	83 ec 78             	sub    $0x78,%esp
	/* Pointer to the format string */
	int8_t* buf = format;
  402ab3:	8b 45 08             	mov    0x8(%ebp),%eax
  402ab6:	89 45 e8             	mov    %eax,0xffffffe8(%ebp)

	/* Stack pointer for the other parameters */
	int32_t* esp = (void *)&format;
  402ab9:	8d 45 08             	lea    0x8(%ebp),%eax
  402abc:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
	esp++;
  402abf:	83 45 ec 04          	addl   $0x4,0xffffffec(%ebp)

	while(*buf != '\0') {
  402ac3:	e9 f2 01 00 00       	jmp    402cba <printf+0x20d>
		switch(*buf) {
  402ac8:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  402acb:	0f b6 00             	movzbl (%eax),%eax
  402ace:	0f be c0             	movsbl %al,%eax
  402ad1:	83 f8 25             	cmp    $0x25,%eax
  402ad4:	74 05                	je     402adb <printf+0x2e>
  402ad6:	e9 ca 01 00 00       	jmp    402ca5 <printf+0x1f8>
			case '%':
				{
					int32_t alternate = 0;
  402adb:	c7 45 f0 00 00 00 00 	movl   $0x0,0xfffffff0(%ebp)
					buf++;
  402ae2:	83 45 e8 01          	addl   $0x1,0xffffffe8(%ebp)

format_char_switch:
					/* Conversion specifiers */
					switch(*buf) {
  402ae6:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  402ae9:	0f b6 00             	movzbl (%eax),%eax
  402aec:	0f be c0             	movsbl %al,%eax
  402aef:	89 45 9c             	mov    %eax,0xffffff9c(%ebp)
  402af2:	83 7d 9c 64          	cmpl   $0x64,0xffffff9c(%ebp)
  402af6:	0f 84 22 01 00 00    	je     402c1e <printf+0x171>
  402afc:	83 7d 9c 64          	cmpl   $0x64,0xffffff9c(%ebp)
  402b00:	7f 1b                	jg     402b1d <printf+0x70>
  402b02:	83 7d 9c 25          	cmpl   $0x25,0xffffff9c(%ebp)
  402b06:	74 34                	je     402b3c <printf+0x8f>
  402b08:	83 7d 9c 63          	cmpl   $0x63,0xffffff9c(%ebp)
  402b0c:	0f 84 6a 01 00 00    	je     402c7c <printf+0x1cf>
  402b12:	83 7d 9c 23          	cmpl   $0x23,0xffffff9c(%ebp)
  402b16:	74 35                	je     402b4d <printf+0xa0>
  402b18:	e9 99 01 00 00       	jmp    402cb6 <printf+0x209>
  402b1d:	83 7d 9c 75          	cmpl   $0x75,0xffffff9c(%ebp)
  402b21:	0f 84 c7 00 00 00    	je     402bee <printf+0x141>
  402b27:	83 7d 9c 78          	cmpl   $0x78,0xffffff9c(%ebp)
  402b2b:	74 2d                	je     402b5a <printf+0xad>
  402b2d:	83 7d 9c 73          	cmpl   $0x73,0xffffff9c(%ebp)
  402b31:	0f 84 5b 01 00 00    	je     402c92 <printf+0x1e5>
  402b37:	e9 7a 01 00 00       	jmp    402cb6 <printf+0x209>
						/* Print a literal '%' character */
						case '%':
							putc('%');
  402b3c:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  402b43:	e8 c7 01 00 00       	call   402d0f <putc>
							break;
  402b48:	e9 69 01 00 00       	jmp    402cb6 <printf+0x209>

						/* Use alternate formatting */
						case '#':
							alternate = 1;
  402b4d:	c7 45 f0 01 00 00 00 	movl   $0x1,0xfffffff0(%ebp)
							buf++;
  402b54:	83 45 e8 01          	addl   $0x1,0xffffffe8(%ebp)
							/* Yes, I know gotos are bad.  This is the
							 * most elegant and general way to do this,
							 * IMHO. */
							goto format_char_switch;
  402b58:	eb 8c                	jmp    402ae6 <printf+0x39>

						/* Print a number in hexadecimal form */
						case 'x':
							{
								int8_t conv_buf[64];
								if(alternate == 0) {
  402b5a:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  402b5e:	75 29                	jne    402b89 <printf+0xdc>
									itoa(*((uint32_t *)esp), conv_buf, 16);
  402b60:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  402b63:	8b 10                	mov    (%eax),%edx
  402b65:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  402b6c:	00 
  402b6d:	8d 45 a8             	lea    0xffffffa8(%ebp),%eax
  402b70:	89 44 24 04          	mov    %eax,0x4(%esp)
  402b74:	89 14 24             	mov    %edx,(%esp)
  402b77:	e8 ff 02 00 00       	call   402e7b <itoa>
									puts(conv_buf);
  402b7c:	8d 45 a8             	lea    0xffffffa8(%ebp),%eax
  402b7f:	89 04 24             	mov    %eax,(%esp)
  402b82:	e8 4f 01 00 00       	call   402cd6 <puts>
  402b87:	eb 5c                	jmp    402be5 <printf+0x138>
								} else {
									int32_t starting_index;
									int32_t i;
									itoa(*((uint32_t *)esp), &conv_buf[8], 16);
  402b89:	8d 45 a8             	lea    0xffffffa8(%ebp),%eax
  402b8c:	8d 50 08             	lea    0x8(%eax),%edx
  402b8f:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  402b92:	8b 00                	mov    (%eax),%eax
  402b94:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  402b9b:	00 
  402b9c:	89 54 24 04          	mov    %edx,0x4(%esp)
  402ba0:	89 04 24             	mov    %eax,(%esp)
  402ba3:	e8 d3 02 00 00       	call   402e7b <itoa>
									i = starting_index = strlen(&conv_buf[8]);
  402ba8:	8d 45 a8             	lea    0xffffffa8(%ebp),%eax
  402bab:	83 c0 08             	add    $0x8,%eax
  402bae:	89 04 24             	mov    %eax,(%esp)
  402bb1:	e8 a5 03 00 00       	call   402f5b <strlen>
  402bb6:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
  402bb9:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  402bbc:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
									while(i < 8) {
  402bbf:	eb 0c                	jmp    402bcd <printf+0x120>
										conv_buf[i] = '0';
  402bc1:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  402bc4:	c6 44 05 a8 30       	movb   $0x30,0xffffffa8(%ebp,%eax,1)
										i++;
  402bc9:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  402bcd:	83 7d f8 07          	cmpl   $0x7,0xfffffff8(%ebp)
  402bd1:	7e ee                	jle    402bc1 <printf+0x114>
									}
									puts(&conv_buf[starting_index]);
  402bd3:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  402bd6:	89 c2                	mov    %eax,%edx
  402bd8:	8d 45 a8             	lea    0xffffffa8(%ebp),%eax
  402bdb:	01 d0                	add    %edx,%eax
  402bdd:	89 04 24             	mov    %eax,(%esp)
  402be0:	e8 f1 00 00 00       	call   402cd6 <puts>
								}
								esp++;
  402be5:	83 45 ec 04          	addl   $0x4,0xffffffec(%ebp)
							}
							break;
  402be9:	e9 c8 00 00 00       	jmp    402cb6 <printf+0x209>

						/* Print a number in unsigned int form */
						case 'u':
							{
								int8_t conv_buf[36];
								itoa(*((uint32_t *)esp), conv_buf, 10);
  402bee:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  402bf1:	8b 10                	mov    (%eax),%edx
  402bf3:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
  402bfa:	00 
  402bfb:	8d 45 a8             	lea    0xffffffa8(%ebp),%eax
  402bfe:	89 44 24 04          	mov    %eax,0x4(%esp)
  402c02:	89 14 24             	mov    %edx,(%esp)
  402c05:	e8 71 02 00 00       	call   402e7b <itoa>
								puts(conv_buf);
  402c0a:	8d 45 a8             	lea    0xffffffa8(%ebp),%eax
  402c0d:	89 04 24             	mov    %eax,(%esp)
  402c10:	e8 c1 00 00 00       	call   402cd6 <puts>
								esp++;
  402c15:	83 45 ec 04          	addl   $0x4,0xffffffec(%ebp)
							}
							break;
  402c19:	e9 98 00 00 00       	jmp    402cb6 <printf+0x209>

						/* Print a number in signed int form */
						case 'd':
							{
								int8_t conv_buf[36];
								int32_t value = *((int32_t *)esp);
  402c1e:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  402c21:	8b 00                	mov    (%eax),%eax
  402c23:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
								if(value < 0) {
  402c26:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  402c2a:	79 25                	jns    402c51 <printf+0x1a4>
									conv_buf[0] = '-';
  402c2c:	c6 45 a8 2d          	movb   $0x2d,0xffffffa8(%ebp)
									itoa(-value, &conv_buf[1], 10);
  402c30:	8d 45 a8             	lea    0xffffffa8(%ebp),%eax
  402c33:	8d 50 01             	lea    0x1(%eax),%edx
  402c36:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  402c39:	f7 d8                	neg    %eax
  402c3b:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
  402c42:	00 
  402c43:	89 54 24 04          	mov    %edx,0x4(%esp)
  402c47:	89 04 24             	mov    %eax,(%esp)
  402c4a:	e8 2c 02 00 00       	call   402e7b <itoa>
  402c4f:	eb 1a                	jmp    402c6b <printf+0x1be>
								} else {
									itoa(value, conv_buf, 10);
  402c51:	8b 55 fc             	mov    0xfffffffc(%ebp),%edx
  402c54:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
  402c5b:	00 
  402c5c:	8d 45 a8             	lea    0xffffffa8(%ebp),%eax
  402c5f:	89 44 24 04          	mov    %eax,0x4(%esp)
  402c63:	89 14 24             	mov    %edx,(%esp)
  402c66:	e8 10 02 00 00       	call   402e7b <itoa>
								}
								puts(conv_buf);
  402c6b:	8d 45 a8             	lea    0xffffffa8(%ebp),%eax
  402c6e:	89 04 24             	mov    %eax,(%esp)
  402c71:	e8 60 00 00 00       	call   402cd6 <puts>
								esp++;
  402c76:	83 45 ec 04          	addl   $0x4,0xffffffec(%ebp)
							}
							break;
  402c7a:	eb 3a                	jmp    402cb6 <printf+0x209>

						/* Print a single character */
						case 'c':
							putc( (uint8_t) *((int32_t *)esp) );
  402c7c:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  402c7f:	8b 00                	mov    (%eax),%eax
  402c81:	0f b6 c0             	movzbl %al,%eax
  402c84:	89 04 24             	mov    %eax,(%esp)
  402c87:	e8 83 00 00 00       	call   402d0f <putc>
							esp++;
  402c8c:	83 45 ec 04          	addl   $0x4,0xffffffec(%ebp)
							break;
  402c90:	eb 24                	jmp    402cb6 <printf+0x209>

						/* Print a NULL-terminated string */
						case 's':
							puts( *((int8_t **)esp) );
  402c92:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  402c95:	8b 00                	mov    (%eax),%eax
  402c97:	89 04 24             	mov    %eax,(%esp)
  402c9a:	e8 37 00 00 00       	call   402cd6 <puts>
							esp++;
  402c9f:	83 45 ec 04          	addl   $0x4,0xffffffec(%ebp)
							break;

						default:
							break;
					}

				}
				break;
  402ca3:	eb 11                	jmp    402cb6 <printf+0x209>

			default:
				putc(*buf);
  402ca5:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  402ca8:	0f b6 00             	movzbl (%eax),%eax
  402cab:	0f b6 c0             	movzbl %al,%eax
  402cae:	89 04 24             	mov    %eax,(%esp)
  402cb1:	e8 59 00 00 00       	call   402d0f <putc>
				break;
		}
		buf++;
  402cb6:	83 45 e8 01          	addl   $0x1,0xffffffe8(%ebp)
  402cba:	8b 45 e8             	mov    0xffffffe8(%ebp),%eax
  402cbd:	0f b6 00             	movzbl (%eax),%eax
  402cc0:	84 c0                	test   %al,%al
  402cc2:	0f 85 00 fe ff ff    	jne    402ac8 <printf+0x1b>
	}

	return (buf - format);
  402cc8:	8b 55 e8             	mov    0xffffffe8(%ebp),%edx
  402ccb:	8b 45 08             	mov    0x8(%ebp),%eax
  402cce:	89 d1                	mov    %edx,%ecx
  402cd0:	29 c1                	sub    %eax,%ecx
  402cd2:	89 c8                	mov    %ecx,%eax
}
  402cd4:	c9                   	leave  
  402cd5:	c3                   	ret    

00402cd6 <puts>:

/*
* int32_t puts(int8_t* s);
*   Inputs: int_8* s = pointer to a string of characters
*   Return Value: Number of bytes written
*	Function: Output a string to the console
*/

int32_t
puts(int8_t* s)
{
  402cd6:	55                   	push   %ebp
  402cd7:	89 e5                	mov    %esp,%ebp
  402cd9:	83 ec 08             	sub    $0x8,%esp
	register int32_t index = 0;
  402cdc:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
	while(s[index] != '\0') {
  402ce3:	eb 18                	jmp    402cfd <puts+0x27>
		putc(s[index]);
  402ce5:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  402ce8:	03 45 08             	add    0x8(%ebp),%eax
  402ceb:	0f b6 00             	movzbl (%eax),%eax
  402cee:	0f b6 c0             	movzbl %al,%eax
  402cf1:	89 04 24             	mov    %eax,(%esp)
  402cf4:	e8 16 00 00 00       	call   402d0f <putc>
		index++;
  402cf9:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  402cfd:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  402d00:	03 45 08             	add    0x8(%ebp),%eax
  402d03:	0f b6 00             	movzbl (%eax),%eax
  402d06:	84 c0                	test   %al,%al
  402d08:	75 db                	jne    402ce5 <puts+0xf>
	}

	return index;
  402d0a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  402d0d:	c9                   	leave  
  402d0e:	c3                   	ret    

00402d0f <putc>:

/*
* void putc(uint8_t c);
*   Inputs: uint_8* c = character to print
*   Return Value: void
*	Function: Output a character to the console
*/

void
putc(uint8_t c)
{
  402d0f:	55                   	push   %ebp
  402d10:	89 e5                	mov    %esp,%ebp
  402d12:	53                   	push   %ebx
  402d13:	83 ec 14             	sub    $0x14,%esp
  402d16:	8b 45 08             	mov    0x8(%ebp),%eax
  402d19:	88 45 f8             	mov    %al,0xfffffff8(%ebp)
    if(c == '\n' || c == '\r') {
  402d1c:	80 7d f8 0a          	cmpb   $0xa,0xfffffff8(%ebp)
  402d20:	74 06                	je     402d28 <putc+0x19>
  402d22:	80 7d f8 0d          	cmpb   $0xd,0xfffffff8(%ebp)
  402d26:	75 2d                	jne    402d55 <putc+0x46>
        if(screen_y==(NUM_ROWS-1)){
  402d28:	a1 04 d0 40 00       	mov    0x40d004,%eax
  402d2d:	83 f8 18             	cmp    $0x18,%eax
  402d30:	75 07                	jne    402d39 <putc+0x2a>
			tScroll();
  402d32:	e8 e1 0f 00 00       	call   403d18 <tScroll>
  402d37:	eb 0d                	jmp    402d46 <putc+0x37>
		}
		else screen_y++;
  402d39:	a1 04 d0 40 00       	mov    0x40d004,%eax
  402d3e:	83 c0 01             	add    $0x1,%eax
  402d41:	a3 04 d0 40 00       	mov    %eax,0x40d004
        screen_x=0;
  402d46:	c7 05 00 d0 40 00 00 	movl   $0x0,0x40d000
  402d4d:	00 00 00 
  402d50:	e9 20 01 00 00       	jmp    402e75 <putc+0x166>
    } else {
        *(uint8_t *)(video_mem + ((NUM_COLS*screen_y + screen_x) << 1)) = c;
  402d55:	8b 15 04 d0 40 00    	mov    0x40d004,%edx
  402d5b:	89 d0                	mov    %edx,%eax
  402d5d:	c1 e0 02             	shl    $0x2,%eax
  402d60:	01 d0                	add    %edx,%eax
  402d62:	c1 e0 04             	shl    $0x4,%eax
  402d65:	89 c2                	mov    %eax,%edx
  402d67:	a1 00 d0 40 00       	mov    0x40d000,%eax
  402d6c:	8d 04 02             	lea    (%edx,%eax,1),%eax
  402d6f:	01 c0                	add    %eax,%eax
  402d71:	89 c2                	mov    %eax,%edx
  402d73:	a1 c0 50 40 00       	mov    0x4050c0,%eax
  402d78:	8d 04 02             	lea    (%edx,%eax,1),%eax
  402d7b:	89 c2                	mov    %eax,%edx
  402d7d:	0f b6 45 f8          	movzbl 0xfffffff8(%ebp),%eax
  402d81:	88 02                	mov    %al,(%edx)
        *(uint8_t *)(video_mem + ((NUM_COLS*screen_y + screen_x) << 1) + 1) = ATTRIB;
  402d83:	8b 15 04 d0 40 00    	mov    0x40d004,%edx
  402d89:	89 d0                	mov    %edx,%eax
  402d8b:	c1 e0 02             	shl    $0x2,%eax
  402d8e:	01 d0                	add    %edx,%eax
  402d90:	c1 e0 04             	shl    $0x4,%eax
  402d93:	89 c2                	mov    %eax,%edx
  402d95:	a1 00 d0 40 00       	mov    0x40d000,%eax
  402d9a:	8d 04 02             	lea    (%edx,%eax,1),%eax
  402d9d:	01 c0                	add    %eax,%eax
  402d9f:	89 c2                	mov    %eax,%edx
  402da1:	a1 c0 50 40 00       	mov    0x4050c0,%eax
  402da6:	8d 04 02             	lea    (%edx,%eax,1),%eax
  402da9:	83 c0 01             	add    $0x1,%eax
  402dac:	c6 00 07             	movb   $0x7,(%eax)
        screen_x++;
  402daf:	a1 00 d0 40 00       	mov    0x40d000,%eax
  402db4:	83 c0 01             	add    $0x1,%eax
  402db7:	a3 00 d0 40 00       	mov    %eax,0x40d000
		if(screen_y==(NUM_ROWS-1)&&screen_x==NUM_COLS){
  402dbc:	a1 04 d0 40 00       	mov    0x40d004,%eax
  402dc1:	83 f8 18             	cmp    $0x18,%eax
  402dc4:	75 11                	jne    402dd7 <putc+0xc8>
  402dc6:	a1 00 d0 40 00       	mov    0x40d000,%eax
  402dcb:	83 f8 50             	cmp    $0x50,%eax
  402dce:	75 07                	jne    402dd7 <putc+0xc8>
			tScroll();
  402dd0:	e8 43 0f 00 00       	call   403d18 <tScroll>
  402dd5:	eb 61                	jmp    402e38 <putc+0x129>
		}
		else screen_y = (screen_y + (screen_x / NUM_COLS)) % NUM_ROWS;
  402dd7:	8b 0d 00 d0 40 00    	mov    0x40d000,%ecx
  402ddd:	c7 45 ec 67 66 66 66 	movl   $0x66666667,0xffffffec(%ebp)
  402de4:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  402de7:	f7 e9                	imul   %ecx
  402de9:	c1 fa 05             	sar    $0x5,%edx
  402dec:	89 c8                	mov    %ecx,%eax
  402dee:	c1 f8 1f             	sar    $0x1f,%eax
  402df1:	29 c2                	sub    %eax,%edx
  402df3:	a1 04 d0 40 00       	mov    0x40d004,%eax
  402df8:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  402dfb:	c7 45 ec 1f 85 eb 51 	movl   $0x51eb851f,0xffffffec(%ebp)
  402e02:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  402e05:	f7 e9                	imul   %ecx
  402e07:	c1 fa 03             	sar    $0x3,%edx
  402e0a:	89 c8                	mov    %ecx,%eax
  402e0c:	c1 f8 1f             	sar    $0x1f,%eax
  402e0f:	89 d3                	mov    %edx,%ebx
  402e11:	29 c3                	sub    %eax,%ebx
  402e13:	89 5d f0             	mov    %ebx,0xfffffff0(%ebp)
  402e16:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  402e19:	c1 e0 02             	shl    $0x2,%eax
  402e1c:	03 45 f0             	add    0xfffffff0(%ebp),%eax
  402e1f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  402e26:	01 d0                	add    %edx,%eax
  402e28:	89 ca                	mov    %ecx,%edx
  402e2a:	29 c2                	sub    %eax,%edx
  402e2c:	89 55 f0             	mov    %edx,0xfffffff0(%ebp)
  402e2f:	8b 5d f0             	mov    0xfffffff0(%ebp),%ebx
  402e32:	89 1d 04 d0 40 00    	mov    %ebx,0x40d004
        screen_x %= NUM_COLS;
  402e38:	8b 0d 00 d0 40 00    	mov    0x40d000,%ecx
  402e3e:	c7 45 ec 67 66 66 66 	movl   $0x66666667,0xffffffec(%ebp)
  402e45:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
  402e48:	f7 e9                	imul   %ecx
  402e4a:	c1 fa 05             	sar    $0x5,%edx
  402e4d:	89 c8                	mov    %ecx,%eax
  402e4f:	c1 f8 1f             	sar    $0x1f,%eax
  402e52:	89 d3                	mov    %edx,%ebx
  402e54:	29 c3                	sub    %eax,%ebx
  402e56:	89 5d f4             	mov    %ebx,0xfffffff4(%ebp)
  402e59:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  402e5c:	c1 e0 02             	shl    $0x2,%eax
  402e5f:	03 45 f4             	add    0xfffffff4(%ebp),%eax
  402e62:	c1 e0 04             	shl    $0x4,%eax
  402e65:	89 ca                	mov    %ecx,%edx
  402e67:	29 c2                	sub    %eax,%edx
  402e69:	89 55 f4             	mov    %edx,0xfffffff4(%ebp)
  402e6c:	8b 5d f4             	mov    0xfffffff4(%ebp),%ebx
  402e6f:	89 1d 00 d0 40 00    	mov    %ebx,0x40d000
    }
}
  402e75:	83 c4 14             	add    $0x14,%esp
  402e78:	5b                   	pop    %ebx
  402e79:	5d                   	pop    %ebp
  402e7a:	c3                   	ret    

00402e7b <itoa>:

/*
* int8_t* itoa(uint32_t value, int8_t* buf, int32_t radix);
*   Inputs: uint32_t value = number to convert
*			int8_t* buf = allocated buffer to place string in
*			int32_t radix = base system. hex, oct, dec, etc.
*   Return Value: number of bytes written
*	Function: Convert a number to its ASCII representation, with base "radix"
*/

int8_t*
itoa(uint32_t value, int8_t* buf, int32_t radix)
{
  402e7b:	55                   	push   %ebp
  402e7c:	89 e5                	mov    %esp,%ebp
  402e7e:	83 ec 18             	sub    $0x18,%esp
	static int8_t lookup[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";

	int8_t *newbuf = buf;
  402e81:	8b 45 0c             	mov    0xc(%ebp),%eax
  402e84:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
	int32_t i;
	uint32_t newval = value;
  402e87:	8b 45 08             	mov    0x8(%ebp),%eax
  402e8a:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

	/* Special case for zero */
	if(value == 0) {
  402e8d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  402e91:	75 50                	jne    402ee3 <itoa+0x68>
		buf[0]='0';
  402e93:	8b 45 0c             	mov    0xc(%ebp),%eax
  402e96:	c6 00 30             	movb   $0x30,(%eax)
		buf[1]='\0';
  402e99:	8b 45 0c             	mov    0xc(%ebp),%eax
  402e9c:	83 c0 01             	add    $0x1,%eax
  402e9f:	c6 00 00             	movb   $0x0,(%eax)
		return buf;
  402ea2:	8b 45 0c             	mov    0xc(%ebp),%eax
  402ea5:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  402ea8:	eb 53                	jmp    402efd <itoa+0x82>
	}

	/* Go through the number one place value at a time, and add the
	 * correct digit to "newbuf".  We actually add characters to the
	 * ASCII string from lowest place value to highest, which is the
	 * opposite of how the number should be printed.  We'll reverse the
	 * characters later. */
	while(newval > 0) {
		i = newval % radix;
  402eaa:	8b 55 10             	mov    0x10(%ebp),%edx
  402ead:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  402eb0:	89 d1                	mov    %edx,%ecx
  402eb2:	ba 00 00 00 00       	mov    $0x0,%edx
  402eb7:	f7 f1                	div    %ecx
  402eb9:	89 d0                	mov    %edx,%eax
  402ebb:	89 45 f8             	mov    %eax,0xfffffff8(%ebp)
		*newbuf = lookup[i];
  402ebe:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  402ec1:	0f b6 90 e0 50 40 00 	movzbl 0x4050e0(%eax),%edx
  402ec8:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  402ecb:	88 10                	mov    %dl,(%eax)
		newbuf++;
  402ecd:	83 45 f4 01          	addl   $0x1,0xfffffff4(%ebp)
		newval /= radix;
  402ed1:	8b 55 10             	mov    0x10(%ebp),%edx
  402ed4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  402ed7:	89 d1                	mov    %edx,%ecx
  402ed9:	ba 00 00 00 00       	mov    $0x0,%edx
  402ede:	f7 f1                	div    %ecx
  402ee0:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  402ee3:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  402ee7:	75 c1                	jne    402eaa <itoa+0x2f>
	}

	/* Add a terminating NULL */
	*newbuf = '\0';
  402ee9:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  402eec:	c6 00 00             	movb   $0x0,(%eax)

	/* Reverse the string and return */
	return strrev(buf);
  402eef:	8b 45 0c             	mov    0xc(%ebp),%eax
  402ef2:	89 04 24             	mov    %eax,(%esp)
  402ef5:	e8 08 00 00 00       	call   402f02 <strrev>
  402efa:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  402efd:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  402f00:	c9                   	leave  
  402f01:	c3                   	ret    

00402f02 <strrev>:

/*
* int8_t* strrev(int8_t* s);
*   Inputs: int8_t* s = string to reverse
*   Return Value: reversed string
*	Function: reverses a string s
*/

int8_t*
strrev(int8_t* s)
{
  402f02:	55                   	push   %ebp
  402f03:	89 e5                	mov    %esp,%ebp
  402f05:	83 ec 18             	sub    $0x18,%esp
	register int8_t tmp;
	register int32_t beg=0;
  402f08:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
	register int32_t end=strlen(s) - 1;
  402f0f:	8b 45 08             	mov    0x8(%ebp),%eax
  402f12:	89 04 24             	mov    %eax,(%esp)
  402f15:	e8 41 00 00 00       	call   402f5b <strlen>
  402f1a:	83 e8 01             	sub    $0x1,%eax
  402f1d:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)

	while(beg < end) {
  402f20:	eb 2c                	jmp    402f4e <strrev+0x4c>
		tmp = s[end];
  402f22:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  402f25:	03 45 08             	add    0x8(%ebp),%eax
  402f28:	0f b6 08             	movzbl (%eax),%ecx
		s[end] = s[beg];
  402f2b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  402f2e:	89 c2                	mov    %eax,%edx
  402f30:	03 55 08             	add    0x8(%ebp),%edx
  402f33:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  402f36:	03 45 08             	add    0x8(%ebp),%eax
  402f39:	0f b6 00             	movzbl (%eax),%eax
  402f3c:	88 02                	mov    %al,(%edx)
		s[beg] = tmp;
  402f3e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  402f41:	03 45 08             	add    0x8(%ebp),%eax
  402f44:	88 08                	mov    %cl,(%eax)
		beg++;
  402f46:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
		end--;
  402f4a:	83 6d fc 01          	subl   $0x1,0xfffffffc(%ebp)
  402f4e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  402f51:	39 45 f8             	cmp    %eax,0xfffffff8(%ebp)
  402f54:	7c cc                	jl     402f22 <strrev+0x20>
	}

	return s;
  402f56:	8b 45 08             	mov    0x8(%ebp),%eax
}
  402f59:	c9                   	leave  
  402f5a:	c3                   	ret    

00402f5b <strlen>:

/*
* uint32_t strlen(const int8_t* s);
*   Inputs: const int8_t* s = string to take length of
*   Return Value: length of string s
*	Function: return length of string s
*/

uint32_t
strlen(const int8_t* s)
{
  402f5b:	55                   	push   %ebp
  402f5c:	89 e5                	mov    %esp,%ebp
  402f5e:	83 ec 04             	sub    $0x4,%esp
	register uint32_t len = 0;
  402f61:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
	while(s[len] != '\0')
  402f68:	eb 04                	jmp    402f6e <strlen+0x13>
		len++;
  402f6a:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  402f6e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  402f71:	03 45 08             	add    0x8(%ebp),%eax
  402f74:	0f b6 00             	movzbl (%eax),%eax
  402f77:	84 c0                	test   %al,%al
  402f79:	75 ef                	jne    402f6a <strlen+0xf>

	return len;
  402f7b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  402f7e:	c9                   	leave  
  402f7f:	c3                   	ret    

00402f80 <memset>:

/*
* void* memset(void* s, int32_t c, uint32_t n);
*   Inputs: void* s = pointer to memory
*			int32_t c = value to set memory to
*			uint32_t n = number of bytes to set
*   Return Value: new string
*	Function: set n consecutive bytes of pointer s to value c
*/

void*
memset(void* s, int32_t c, uint32_t n)
{
  402f80:	55                   	push   %ebp
  402f81:	89 e5                	mov    %esp,%ebp
  402f83:	57                   	push   %edi
	c &= 0xFF;
  402f84:	81 65 0c ff 00 00 00 	andl   $0xff,0xc(%ebp)
	asm volatile("                  \n\
  402f8b:	8b 45 0c             	mov    0xc(%ebp),%eax
  402f8e:	89 c2                	mov    %eax,%edx
  402f90:	c1 e2 18             	shl    $0x18,%edx
  402f93:	8b 45 0c             	mov    0xc(%ebp),%eax
  402f96:	c1 e0 10             	shl    $0x10,%eax
  402f99:	09 c2                	or     %eax,%edx
  402f9b:	8b 45 0c             	mov    0xc(%ebp),%eax
  402f9e:	c1 e0 08             	shl    $0x8,%eax
  402fa1:	09 d0                	or     %edx,%eax
  402fa3:	0b 45 0c             	or     0xc(%ebp),%eax
  402fa6:	8b 7d 08             	mov    0x8(%ebp),%edi
  402fa9:	8b 4d 10             	mov    0x10(%ebp),%ecx

00402fac <.memset_top>:
  402fac:	85 c9                	test   %ecx,%ecx
  402fae:	74 30                	je     402fe0 <.memset_done>
  402fb0:	f7 c7 03 00 00 00    	test   $0x3,%edi
  402fb6:	74 0a                	je     402fc2 <.memset_aligned>
  402fb8:	88 07                	mov    %al,(%edi)
  402fba:	83 c7 01             	add    $0x1,%edi
  402fbd:	83 e9 01             	sub    $0x1,%ecx
  402fc0:	eb ea                	jmp    402fac <.memset_top>

00402fc2 <.memset_aligned>:
  402fc2:	66 8c da             	movw   %ds,%dx
  402fc5:	8e c2                	movl   %edx,%es
  402fc7:	89 ca                	mov    %ecx,%edx
  402fc9:	c1 e9 02             	shr    $0x2,%ecx
  402fcc:	83 e2 03             	and    $0x3,%edx
  402fcf:	fc                   	cld    
  402fd0:	f3 ab                	rep stos %eax,%es:(%edi)

00402fd2 <.memset_bottom>:
  402fd2:	85 d2                	test   %edx,%edx
  402fd4:	74 0a                	je     402fe0 <.memset_done>
  402fd6:	88 07                	mov    %al,(%edi)
  402fd8:	83 c7 01             	add    $0x1,%edi
  402fdb:	83 ea 01             	sub    $0x1,%edx
  402fde:	eb f2                	jmp    402fd2 <.memset_bottom>

00402fe0 <.memset_done>:
			.memset_top:            \n\
			testl   %%ecx, %%ecx    \n\
			jz      .memset_done    \n\
			testl   $0x3, %%edi     \n\
			jz      .memset_aligned \n\
			movb    %%al, (%%edi)   \n\
			addl    $1, %%edi       \n\
			subl    $1, %%ecx       \n\
			jmp     .memset_top     \n\
			.memset_aligned:        \n\
			movw    %%ds, %%dx      \n\
			movw    %%dx, %%es      \n\
			movl    %%ecx, %%edx    \n\
			shrl    $2, %%ecx       \n\
			andl    $0x3, %%edx     \n\
			cld                     \n\
			rep     stosl           \n\
			.memset_bottom:         \n\
			testl   %%edx, %%edx    \n\
			jz      .memset_done    \n\
			movb    %%al, (%%edi)   \n\
			addl    $1, %%edi       \n\
			subl    $1, %%edx       \n\
			jmp     .memset_bottom  \n\
			.memset_done:           \n\
			"
			:
			: "a"(c << 24 | c << 16 | c << 8 | c), "D"(s), "c"(n)
			: "edx", "memory", "cc"
			);

	return s;
  402fe0:	8b 45 08             	mov    0x8(%ebp),%eax
}
  402fe3:	5f                   	pop    %edi
  402fe4:	5d                   	pop    %ebp
  402fe5:	c3                   	ret    

00402fe6 <memset_word>:

/*
* void* memset_word(void* s, int32_t c, uint32_t n);
*   Inputs: void* s = pointer to memory
*			int32_t c = value to set memory to
*			uint32_t n = number of bytes to set
*   Return Value: new string
*	Function: set lower 16 bits of n consecutive memory locations of pointer s to value c
*/

/* Optimized memset_word */
void*
memset_word(void* s, int32_t c, uint32_t n)
{
  402fe6:	55                   	push   %ebp
  402fe7:	89 e5                	mov    %esp,%ebp
  402fe9:	57                   	push   %edi
	asm volatile("                  \n\
  402fea:	8b 45 0c             	mov    0xc(%ebp),%eax
  402fed:	8b 7d 08             	mov    0x8(%ebp),%edi
  402ff0:	8b 4d 10             	mov    0x10(%ebp),%ecx
  402ff3:	66 8c da             	movw   %ds,%dx
  402ff6:	8e c2                	movl   %edx,%es
  402ff8:	fc                   	cld    
  402ff9:	f3 66 ab             	rep stos %ax,%es:(%edi)
			movw    %%ds, %%dx      \n\
			movw    %%dx, %%es      \n\
			cld                     \n\
			rep     stosw           \n\
			"
			:
			: "a"(c), "D"(s), "c"(n)
			: "edx", "memory", "cc"
			);

	return s;
  402ffc:	8b 45 08             	mov    0x8(%ebp),%eax
}
  402fff:	5f                   	pop    %edi
  403000:	5d                   	pop    %ebp
  403001:	c3                   	ret    

00403002 <memset_dword>:

/*
* void* memset_dword(void* s, int32_t c, uint32_t n);
*   Inputs: void* s = pointer to memory
*			int32_t c = value to set memory to
*			uint32_t n = number of bytes to set
*   Return Value: new string
*	Function: set n consecutive memory locations of pointer s to value c
*/

void*
memset_dword(void* s, int32_t c, uint32_t n)
{
  403002:	55                   	push   %ebp
  403003:	89 e5                	mov    %esp,%ebp
  403005:	57                   	push   %edi
	asm volatile("                  \n\
  403006:	8b 45 0c             	mov    0xc(%ebp),%eax
  403009:	8b 7d 08             	mov    0x8(%ebp),%edi
  40300c:	8b 4d 10             	mov    0x10(%ebp),%ecx
  40300f:	66 8c da             	movw   %ds,%dx
  403012:	8e c2                	movl   %edx,%es
  403014:	fc                   	cld    
  403015:	f3 ab                	rep stos %eax,%es:(%edi)
			movw    %%ds, %%dx      \n\
			movw    %%dx, %%es      \n\
			cld                     \n\
			rep     stosl           \n\
			"
			:
			: "a"(c), "D"(s), "c"(n)
			: "edx", "memory", "cc"
			);

	return s;
  403017:	8b 45 08             	mov    0x8(%ebp),%eax
}
  40301a:	5f                   	pop    %edi
  40301b:	5d                   	pop    %ebp
  40301c:	c3                   	ret    

0040301d <memcpy>:

/*
* void* memcpy(void* dest, const void* src, uint32_t n);
*   Inputs: void* dest = destination of copy
*			const void* src = source of copy
*			uint32_t n = number of byets to copy
*   Return Value: pointer to dest
*	Function: copy n bytes of src to dest
*/

void*
memcpy(void* dest, const void* src, uint32_t n)
{
  40301d:	55                   	push   %ebp
  40301e:	89 e5                	mov    %esp,%ebp
  403020:	57                   	push   %edi
  403021:	56                   	push   %esi
	asm volatile("                  \n\
  403022:	8b 75 0c             	mov    0xc(%ebp),%esi
  403025:	8b 7d 08             	mov    0x8(%ebp),%edi
  403028:	8b 4d 10             	mov    0x10(%ebp),%ecx

0040302b <.memcpy_top>:
  40302b:	85 c9                	test   %ecx,%ecx
  40302d:	74 3a                	je     403069 <.memcpy_done>
  40302f:	f7 c7 03 00 00 00    	test   $0x3,%edi
  403035:	74 0f                	je     403046 <.memcpy_aligned>
  403037:	8a 06                	mov    (%esi),%al
  403039:	88 07                	mov    %al,(%edi)
  40303b:	83 c7 01             	add    $0x1,%edi
  40303e:	83 c6 01             	add    $0x1,%esi
  403041:	83 e9 01             	sub    $0x1,%ecx
  403044:	eb e5                	jmp    40302b <.memcpy_top>

00403046 <.memcpy_aligned>:
  403046:	66 8c da             	movw   %ds,%dx
  403049:	8e c2                	movl   %edx,%es
  40304b:	89 ca                	mov    %ecx,%edx
  40304d:	c1 e9 02             	shr    $0x2,%ecx
  403050:	83 e2 03             	and    $0x3,%edx
  403053:	fc                   	cld    
  403054:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

00403056 <.memcpy_bottom>:
  403056:	85 d2                	test   %edx,%edx
  403058:	74 0f                	je     403069 <.memcpy_done>
  40305a:	8a 06                	mov    (%esi),%al
  40305c:	88 07                	mov    %al,(%edi)
  40305e:	83 c7 01             	add    $0x1,%edi
  403061:	83 c6 01             	add    $0x1,%esi
  403064:	83 ea 01             	sub    $0x1,%edx
  403067:	eb ed                	jmp    403056 <.memcpy_bottom>

00403069 <.memcpy_done>:
			.memcpy_top:            \n\
			testl   %%ecx, %%ecx    \n\
			jz      .memcpy_done    \n\
			testl   $0x3, %%edi     \n\
			jz      .memcpy_aligned \n\
			movb    (%%esi), %%al   \n\
			movb    %%al, (%%edi)   \n\
			addl    $1, %%edi       \n\
			addl    $1, %%esi       \n\
			subl    $1, %%ecx       \n\
			jmp     .memcpy_top     \n\
			.memcpy_aligned:        \n\
			movw    %%ds, %%dx      \n\
			movw    %%dx, %%es      \n\
			movl    %%ecx, %%edx    \n\
			shrl    $2, %%ecx       \n\
			andl    $0x3, %%edx     \n\
			cld                     \n\
			rep     movsl           \n\
			.memcpy_bottom:         \n\
			testl   %%edx, %%edx    \n\
			jz      .memcpy_done    \n\
			movb    (%%esi), %%al   \n\
			movb    %%al, (%%edi)   \n\
			addl    $1, %%edi       \n\
			addl    $1, %%esi       \n\
			subl    $1, %%edx       \n\
			jmp     .memcpy_bottom  \n\
			.memcpy_done:           \n\
			"
			:
			: "S"(src), "D"(dest), "c"(n)
			: "eax", "edx", "memory", "cc"
			);

	return dest;
  403069:	8b 45 08             	mov    0x8(%ebp),%eax
}
  40306c:	5e                   	pop    %esi
  40306d:	5f                   	pop    %edi
  40306e:	5d                   	pop    %ebp
  40306f:	c3                   	ret    

00403070 <memmove>:

/*
* void* memmove(void* dest, const void* src, uint32_t n);
*   Inputs: void* dest = destination of move
*			const void* src = source of move
*			uint32_t n = number of byets to move
*   Return Value: pointer to dest
*	Function: move n bytes of src to dest
*/

/* Optimized memmove (used for overlapping memory areas) */
void*
memmove(void* dest, const void* src, uint32_t n)
{
  403070:	55                   	push   %ebp
  403071:	89 e5                	mov    %esp,%ebp
  403073:	57                   	push   %edi
  403074:	56                   	push   %esi
	asm volatile("                  \n\
  403075:	8b 7d 08             	mov    0x8(%ebp),%edi
  403078:	8b 75 0c             	mov    0xc(%ebp),%esi
  40307b:	8b 4d 10             	mov    0x10(%ebp),%ecx
  40307e:	66 8c da             	movw   %ds,%dx
  403081:	8e c2                	movl   %edx,%es
  403083:	fc                   	cld    
  403084:	39 fe                	cmp    %edi,%esi
  403086:	73 09                	jae    403091 <.memmove_go>
  403088:	8d 74 0e ff          	lea    0xffffffff(%esi,%ecx,1),%esi
  40308c:	8d 7c 0f ff          	lea    0xffffffff(%edi,%ecx,1),%edi
  403090:	fd                   	std    

00403091 <.memmove_go>:
  403091:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
			movw    %%ds, %%dx      \n\
			movw    %%dx, %%es      \n\
			cld                     \n\
			cmp     %%edi, %%esi    \n\
			jae     .memmove_go     \n\
			leal    -1(%%esi, %%ecx), %%esi    \n\
			leal    -1(%%edi, %%ecx), %%edi    \n\
			std                     \n\
			.memmove_go:            \n\
			rep     movsb           \n\
			"
			:
			: "D"(dest), "S"(src), "c"(n)
			: "edx", "memory", "cc"
			);

	return dest;
  403093:	8b 45 08             	mov    0x8(%ebp),%eax
}
  403096:	5e                   	pop    %esi
  403097:	5f                   	pop    %edi
  403098:	5d                   	pop    %ebp
  403099:	c3                   	ret    

0040309a <strncmp>:

/*
* int32_t strncmp(const int8_t* s1, const int8_t* s2, uint32_t n)
*   Inputs: const int8_t* s1 = first string to compare
*			const int8_t* s2 = second string to compare
*			uint32_t n = number of bytes to compare
*	Return Value: A zero value indicates that the characters compared
*					in both strings form the same string.
*				A value greater than zero indicates that the first
*					character that does not match has a greater value
*					in str1 than in str2; And a value less than zero
*					indicates the opposite.
*	Function: compares string 1 and string 2 for equality
*/

int32_t
strncmp(const int8_t* s1, const int8_t* s2, uint32_t n)
{
  40309a:	55                   	push   %ebp
  40309b:	89 e5                	mov    %esp,%ebp
  40309d:	83 ec 14             	sub    $0x14,%esp
	int32_t i;
	for(i=0; i<n; i++) {
  4030a0:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  4030a7:	eb 48                	jmp    4030f1 <strncmp+0x57>
		if( (s1[i] != s2[i]) ||
  4030a9:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  4030ac:	03 45 08             	add    0x8(%ebp),%eax
  4030af:	0f b6 10             	movzbl (%eax),%edx
  4030b2:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  4030b5:	03 45 0c             	add    0xc(%ebp),%eax
  4030b8:	0f b6 00             	movzbl (%eax),%eax
  4030bb:	38 c2                	cmp    %al,%dl
  4030bd:	75 0d                	jne    4030cc <strncmp+0x32>
  4030bf:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  4030c2:	03 45 08             	add    0x8(%ebp),%eax
  4030c5:	0f b6 00             	movzbl (%eax),%eax
  4030c8:	84 c0                	test   %al,%al
  4030ca:	75 21                	jne    4030ed <strncmp+0x53>
				(s1[i] == '\0') /* || s2[i] == '\0' */ ) {

			/* The s2[i] == '\0' is unnecessary because of the short-circuit
			 * semantics of 'if' expressions in C.  If the first expression
			 * (s1[i] != s2[i]) evaluates to false, that is, if s1[i] ==
			 * s2[i], then we only need to test either s1[i] or s2[i] for
			 * '\0', since we know they are equal. */

			return s1[i] - s2[i];
  4030cc:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  4030cf:	03 45 08             	add    0x8(%ebp),%eax
  4030d2:	0f b6 00             	movzbl (%eax),%eax
  4030d5:	0f be d0             	movsbl %al,%edx
  4030d8:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  4030db:	03 45 0c             	add    0xc(%ebp),%eax
  4030de:	0f b6 00             	movzbl (%eax),%eax
  4030e1:	0f be c0             	movsbl %al,%eax
  4030e4:	89 d1                	mov    %edx,%ecx
  4030e6:	29 c1                	sub    %eax,%ecx
  4030e8:	89 4d ec             	mov    %ecx,0xffffffec(%ebp)
  4030eb:	eb 13                	jmp    403100 <strncmp+0x66>
  4030ed:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  4030f1:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  4030f4:	3b 45 10             	cmp    0x10(%ebp),%eax
  4030f7:	72 b0                	jb     4030a9 <strncmp+0xf>
		}
	}
	return 0;
  4030f9:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  403100:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
}
  403103:	c9                   	leave  
  403104:	c3                   	ret    

00403105 <strcpy>:

/*
* int8_t* strcpy(int8_t* dest, const int8_t* src)
*   Inputs: int8_t* dest = destination string of copy
*			const int8_t* src = source string of copy
*   Return Value: pointer to dest
*	Function: copy the source string into the destination string
*/

int8_t*
strcpy(int8_t* dest, const int8_t* src)
{
  403105:	55                   	push   %ebp
  403106:	89 e5                	mov    %esp,%ebp
  403108:	83 ec 10             	sub    $0x10,%esp
	int32_t i=0;
  40310b:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
	while(src[i] != '\0') {
  403112:	eb 17                	jmp    40312b <strcpy+0x26>
		dest[i] = src[i];
  403114:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  403117:	89 c2                	mov    %eax,%edx
  403119:	03 55 08             	add    0x8(%ebp),%edx
  40311c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  40311f:	03 45 0c             	add    0xc(%ebp),%eax
  403122:	0f b6 00             	movzbl (%eax),%eax
  403125:	88 02                	mov    %al,(%edx)
		i++;
  403127:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  40312b:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  40312e:	03 45 0c             	add    0xc(%ebp),%eax
  403131:	0f b6 00             	movzbl (%eax),%eax
  403134:	84 c0                	test   %al,%al
  403136:	75 dc                	jne    403114 <strcpy+0xf>
	}

	dest[i] = '\0';
  403138:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  40313b:	03 45 08             	add    0x8(%ebp),%eax
  40313e:	c6 00 00             	movb   $0x0,(%eax)
	return dest;
  403141:	8b 45 08             	mov    0x8(%ebp),%eax
}
  403144:	c9                   	leave  
  403145:	c3                   	ret    

00403146 <strncpy>:

/*
* int8_t* strcpy(int8_t* dest, const int8_t* src, uint32_t n)
*   Inputs: int8_t* dest = destination string of copy
*			const int8_t* src = source string of copy
*			uint32_t n = number of bytes to copy
*   Return Value: pointer to dest
*	Function: copy n bytes of the source string into the destination string
*/

int8_t*
strncpy(int8_t* dest, const int8_t* src, uint32_t n)
{
  403146:	55                   	push   %ebp
  403147:	89 e5                	mov    %esp,%ebp
  403149:	83 ec 10             	sub    $0x10,%esp
	int32_t i=0;
  40314c:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
	while(src[i] != '\0' && i < n) {
  403153:	eb 17                	jmp    40316c <strncpy+0x26>
		dest[i] = src[i];
  403155:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  403158:	89 c2                	mov    %eax,%edx
  40315a:	03 55 08             	add    0x8(%ebp),%edx
  40315d:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  403160:	03 45 0c             	add    0xc(%ebp),%eax
  403163:	0f b6 00             	movzbl (%eax),%eax
  403166:	88 02                	mov    %al,(%edx)
		i++;
  403168:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  40316c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  40316f:	03 45 0c             	add    0xc(%ebp),%eax
  403172:	0f b6 00             	movzbl (%eax),%eax
  403175:	84 c0                	test   %al,%al
  403177:	74 17                	je     403190 <strncpy+0x4a>
  403179:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  40317c:	3b 45 10             	cmp    0x10(%ebp),%eax
  40317f:	72 d4                	jb     403155 <strncpy+0xf>
	}

	while(i < n) {
  403181:	eb 0d                	jmp    403190 <strncpy+0x4a>
		dest[i] = '\0';
  403183:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  403186:	03 45 08             	add    0x8(%ebp),%eax
  403189:	c6 00 00             	movb   $0x0,(%eax)
		i++;
  40318c:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  403190:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  403193:	3b 45 10             	cmp    0x10(%ebp),%eax
  403196:	72 eb                	jb     403183 <strncpy+0x3d>
	}

	return dest;
  403198:	8b 45 08             	mov    0x8(%ebp),%eax
}
  40319b:	c9                   	leave  
  40319c:	c3                   	ret    

0040319d <print_exceptions>:

/*print exceptions */

void
print_exceptions(unsigned int num)
{
  40319d:	55                   	push   %ebp
  40319e:	89 e5                	mov    %esp,%ebp
  4031a0:	83 ec 08             	sub    $0x8,%esp
	clear();
  4031a3:	e8 4c f7 ff ff       	call   4028f4 <clear>
	switch(num){
  4031a8:	83 7d 08 13          	cmpl   $0x13,0x8(%ebp)
  4031ac:	0f 87 c4 01 00 00    	ja     403376 <print_exceptions+0x1d9>
  4031b2:	8b 45 08             	mov    0x8(%ebp),%eax
  4031b5:	c1 e0 02             	shl    $0x2,%eax
  4031b8:	8b 80 c0 46 40 00    	mov    0x4046c0(%eax),%eax
  4031be:	ff e0                	jmp    *%eax

		case 0: printf("exceptions %d is called: divide-by-zero\n", num);
  4031c0:	8b 45 08             	mov    0x8(%ebp),%eax
  4031c3:	89 44 24 04          	mov    %eax,0x4(%esp)
  4031c7:	c7 04 24 44 43 40 00 	movl   $0x404344,(%esp)
  4031ce:	e8 da f8 ff ff       	call   402aad <printf>
			break;
  4031d3:	e9 b1 01 00 00       	jmp    403389 <print_exceptions+0x1ec>
		case 1: printf("exceptions %d is called: debug\n", num);
  4031d8:	8b 45 08             	mov    0x8(%ebp),%eax
  4031db:	89 44 24 04          	mov    %eax,0x4(%esp)
  4031df:	c7 04 24 70 43 40 00 	movl   $0x404370,(%esp)
  4031e6:	e8 c2 f8 ff ff       	call   402aad <printf>
			break;
  4031eb:	e9 99 01 00 00       	jmp    403389 <print_exceptions+0x1ec>
		case 2: printf("exceptions %d is called: NMI\n", num);
  4031f0:	8b 45 08             	mov    0x8(%ebp),%eax
  4031f3:	89 44 24 04          	mov    %eax,0x4(%esp)
  4031f7:	c7 04 24 90 43 40 00 	movl   $0x404390,(%esp)
  4031fe:	e8 aa f8 ff ff       	call   402aad <printf>
			break;
  403203:	e9 81 01 00 00       	jmp    403389 <print_exceptions+0x1ec>
		case 3: printf("exceptions %d is called: breakpoint\n", num);
  403208:	8b 45 08             	mov    0x8(%ebp),%eax
  40320b:	89 44 24 04          	mov    %eax,0x4(%esp)
  40320f:	c7 04 24 b0 43 40 00 	movl   $0x4043b0,(%esp)
  403216:	e8 92 f8 ff ff       	call   402aad <printf>
			break;
  40321b:	e9 69 01 00 00       	jmp    403389 <print_exceptions+0x1ec>
		case 4: printf("exceptions %d is called: overflow\n", num);
  403220:	8b 45 08             	mov    0x8(%ebp),%eax
  403223:	89 44 24 04          	mov    %eax,0x4(%esp)
  403227:	c7 04 24 d8 43 40 00 	movl   $0x4043d8,(%esp)
  40322e:	e8 7a f8 ff ff       	call   402aad <printf>
			break;
  403233:	e9 51 01 00 00       	jmp    403389 <print_exceptions+0x1ec>
		case 5: printf("exceptions %d is called: bound range exceeded\n", num);
  403238:	8b 45 08             	mov    0x8(%ebp),%eax
  40323b:	89 44 24 04          	mov    %eax,0x4(%esp)
  40323f:	c7 04 24 fc 43 40 00 	movl   $0x4043fc,(%esp)
  403246:	e8 62 f8 ff ff       	call   402aad <printf>
			break;
  40324b:	e9 39 01 00 00       	jmp    403389 <print_exceptions+0x1ec>
		case 6: printf("exceptions %d is called: invalid opcode\n", num);
  403250:	8b 45 08             	mov    0x8(%ebp),%eax
  403253:	89 44 24 04          	mov    %eax,0x4(%esp)
  403257:	c7 04 24 2c 44 40 00 	movl   $0x40442c,(%esp)
  40325e:	e8 4a f8 ff ff       	call   402aad <printf>
			break;
  403263:	e9 21 01 00 00       	jmp    403389 <print_exceptions+0x1ec>
		case 7: printf("exceptions %d is called: device not availble\n", num);
  403268:	8b 45 08             	mov    0x8(%ebp),%eax
  40326b:	89 44 24 04          	mov    %eax,0x4(%esp)
  40326f:	c7 04 24 58 44 40 00 	movl   $0x404458,(%esp)
  403276:	e8 32 f8 ff ff       	call   402aad <printf>
			break;
  40327b:	e9 09 01 00 00       	jmp    403389 <print_exceptions+0x1ec>
		case 8: printf("exceptions %d is called: double fault\n", num);
  403280:	8b 45 08             	mov    0x8(%ebp),%eax
  403283:	89 44 24 04          	mov    %eax,0x4(%esp)
  403287:	c7 04 24 88 44 40 00 	movl   $0x404488,(%esp)
  40328e:	e8 1a f8 ff ff       	call   402aad <printf>
			break;
  403293:	e9 f1 00 00 00       	jmp    403389 <print_exceptions+0x1ec>
		case 9: printf("exceptions %d is called: coproccssor segment overrun\n", num);
  403298:	8b 45 08             	mov    0x8(%ebp),%eax
  40329b:	89 44 24 04          	mov    %eax,0x4(%esp)
  40329f:	c7 04 24 b0 44 40 00 	movl   $0x4044b0,(%esp)
  4032a6:	e8 02 f8 ff ff       	call   402aad <printf>
			break;
  4032ab:	e9 d9 00 00 00       	jmp    403389 <print_exceptions+0x1ec>
		case 10: printf("exceptions %d is called: invalid tss\n", num);
  4032b0:	8b 45 08             	mov    0x8(%ebp),%eax
  4032b3:	89 44 24 04          	mov    %eax,0x4(%esp)
  4032b7:	c7 04 24 e8 44 40 00 	movl   $0x4044e8,(%esp)
  4032be:	e8 ea f7 ff ff       	call   402aad <printf>
			break;
  4032c3:	e9 c1 00 00 00       	jmp    403389 <print_exceptions+0x1ec>
		case 11: printf("exceptions %d is called: segment not present\n", num);
  4032c8:	8b 45 08             	mov    0x8(%ebp),%eax
  4032cb:	89 44 24 04          	mov    %eax,0x4(%esp)
  4032cf:	c7 04 24 10 45 40 00 	movl   $0x404510,(%esp)
  4032d6:	e8 d2 f7 ff ff       	call   402aad <printf>
			break;
  4032db:	e9 a9 00 00 00       	jmp    403389 <print_exceptions+0x1ec>
		case 12: printf("exceptions %d is called: stack segment falut\n", num);
  4032e0:	8b 45 08             	mov    0x8(%ebp),%eax
  4032e3:	89 44 24 04          	mov    %eax,0x4(%esp)
  4032e7:	c7 04 24 40 45 40 00 	movl   $0x404540,(%esp)
  4032ee:	e8 ba f7 ff ff       	call   402aad <printf>
			break;
  4032f3:	e9 91 00 00 00       	jmp    403389 <print_exceptions+0x1ec>
		case 13: printf("exceptions %d is called: general protection fault\n", num);
  4032f8:	8b 45 08             	mov    0x8(%ebp),%eax
  4032fb:	89 44 24 04          	mov    %eax,0x4(%esp)
  4032ff:	c7 04 24 70 45 40 00 	movl   $0x404570,(%esp)
  403306:	e8 a2 f7 ff ff       	call   402aad <printf>
			break;
  40330b:	eb 7c                	jmp    403389 <print_exceptions+0x1ec>
		case 14: printf("exceptions %d is called: page_fault\n", num);
  40330d:	8b 45 08             	mov    0x8(%ebp),%eax
  403310:	89 44 24 04          	mov    %eax,0x4(%esp)
  403314:	c7 04 24 a4 45 40 00 	movl   $0x4045a4,(%esp)
  40331b:	e8 8d f7 ff ff       	call   402aad <printf>
			break;
  403320:	eb 67                	jmp    403389 <print_exceptions+0x1ec>
		case 16: printf("exceptions %d is called: x87 floating point exception\n", num);
  403322:	8b 45 08             	mov    0x8(%ebp),%eax
  403325:	89 44 24 04          	mov    %eax,0x4(%esp)
  403329:	c7 04 24 cc 45 40 00 	movl   $0x4045cc,(%esp)
  403330:	e8 78 f7 ff ff       	call   402aad <printf>
			break;
  403335:	eb 52                	jmp    403389 <print_exceptions+0x1ec>
		case 17: printf("exceptions %d is called: alignment check\n", num);
  403337:	8b 45 08             	mov    0x8(%ebp),%eax
  40333a:	89 44 24 04          	mov    %eax,0x4(%esp)
  40333e:	c7 04 24 04 46 40 00 	movl   $0x404604,(%esp)
  403345:	e8 63 f7 ff ff       	call   402aad <printf>
			break;
  40334a:	eb 3d                	jmp    403389 <print_exceptions+0x1ec>
		case 18: printf("exceptions %d is called: machine check\n", num);
  40334c:	8b 45 08             	mov    0x8(%ebp),%eax
  40334f:	89 44 24 04          	mov    %eax,0x4(%esp)
  403353:	c7 04 24 30 46 40 00 	movl   $0x404630,(%esp)
  40335a:	e8 4e f7 ff ff       	call   402aad <printf>
			break;
  40335f:	eb 28                	jmp    403389 <print_exceptions+0x1ec>
		case 19: printf("exceptions %d is called: SIMD floating point exceptions\n", num);
  403361:	8b 45 08             	mov    0x8(%ebp),%eax
  403364:	89 44 24 04          	mov    %eax,0x4(%esp)
  403368:	c7 04 24 58 46 40 00 	movl   $0x404658,(%esp)
  40336f:	e8 39 f7 ff ff       	call   402aad <printf>
			break;
  403374:	eb 13                	jmp    403389 <print_exceptions+0x1ec>
		default:
			printf("exceptions %d is called: reserved fault\n", num);
  403376:	8b 45 08             	mov    0x8(%ebp),%eax
  403379:	89 44 24 04          	mov    %eax,0x4(%esp)
  40337d:	c7 04 24 94 46 40 00 	movl   $0x404694,(%esp)
  403384:	e8 24 f7 ff ff       	call   402aad <printf>
			break;
	}

}
  403389:	c9                   	leave  
  40338a:	c3                   	ret    

0040338b <updatecursor>:

void
updatecursor(void)
{
  40338b:	55                   	push   %ebp
  40338c:	89 e5                	mov    %esp,%ebp
  40338e:	83 ec 10             	sub    $0x10,%esp
	uint16_t position = (screen_y*80) + screen_x;
  403391:	8b 15 04 d0 40 00    	mov    0x40d004,%edx
  403397:	89 d0                	mov    %edx,%eax
  403399:	c1 e0 02             	shl    $0x2,%eax
  40339c:	01 d0                	add    %edx,%eax
  40339e:	c1 e0 04             	shl    $0x4,%eax
  4033a1:	89 c2                	mov    %eax,%edx
  4033a3:	a1 00 d0 40 00       	mov    0x40d000,%eax
  4033a8:	8d 04 02             	lea    (%edx,%eax,1),%eax
  4033ab:	66 89 45 fe          	mov    %ax,0xfffffffe(%ebp)
	//outw(0x03D4, 0x0011);
	// cursor LOW port to vga INDEX register
	outb(0x0F, 0x3D4);
  4033af:	ba d4 03 00 00       	mov    $0x3d4,%edx
  4033b4:	b8 0f 00 00 00       	mov    $0xf,%eax
  4033b9:	ee                   	out    %al,(%dx)
	outb((uint8_t)position, 0x3D5);
  4033ba:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  4033be:	ba d5 03 00 00       	mov    $0x3d5,%edx
  4033c3:	ee                   	out    %al,(%dx)
	// cursor HIGH port to vga INDEX register
	outb(0x0E, 0x3D4);
  4033c4:	ba d4 03 00 00       	mov    $0x3d4,%edx
  4033c9:	b8 0e 00 00 00       	mov    $0xe,%eax
  4033ce:	ee                   	out    %al,(%dx)
	outb((uint8_t)(position>>8),0x3D5);
  4033cf:	0f b7 45 fe          	movzwl 0xfffffffe(%ebp),%eax
  4033d3:	66 c1 e8 08          	shr    $0x8,%ax
  4033d7:	ba d5 03 00 00       	mov    $0x3d5,%edx
  4033dc:	ee                   	out    %al,(%dx)
	//cursor_asm(screen_x, screen_y);
}
  4033dd:	c9                   	leave  
  4033de:	c3                   	ret    

004033df <test_interrupts>:

/*
* void test_interrupts(void)
*   Inputs: void
*   Return Value: void
*	Function: increments video memory. To be used to test rtc
*/

void
test_interrupts(void)
{
  4033df:	55                   	push   %ebp
  4033e0:	89 e5                	mov    %esp,%ebp
  4033e2:	83 ec 10             	sub    $0x10,%esp
	int32_t i;
	for (i=0; i < NUM_ROWS*NUM_COLS; i++) {
  4033e5:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  4033ec:	eb 1a                	jmp    403408 <test_interrupts+0x29>
		video_mem[i<<1]++;
  4033ee:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  4033f1:	01 c0                	add    %eax,%eax
  4033f3:	89 c2                	mov    %eax,%edx
  4033f5:	a1 c0 50 40 00       	mov    0x4050c0,%eax
  4033fa:	01 c2                	add    %eax,%edx
  4033fc:	0f b6 02             	movzbl (%edx),%eax
  4033ff:	83 c0 01             	add    $0x1,%eax
  403402:	88 02                	mov    %al,(%edx)
  403404:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  403408:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,0xfffffffc(%ebp)
  40340f:	7e dd                	jle    4033ee <test_interrupts+0xf>
	}
}
  403411:	c9                   	leave  
  403412:	c3                   	ret    
  403413:	90                   	nop    

00403414 <rtc_init>:
*	Function: Initializes the RTC
*/
void
rtc_init(void)
{
  403414:	55                   	push   %ebp
  403415:	89 e5                	mov    %esp,%ebp
  403417:	83 ec 18             	sub    $0x18,%esp
	uint8_t curReg;
	// uint32_t flags;
	// cli_and_save(flags);
	cli();
  40341a:	fa                   	cli    
	/*Process to turn on interrupts while disabling NMI*/
	outb(REGB_NONMI, RTC_PORT);		//must set the register we want to read from on
  40341b:	ba 70 00 00 00       	mov    $0x70,%edx
  403420:	b8 8b 00 00 00       	mov    $0x8b,%eax
  403425:	ee                   	out    %al,(%dx)
	curReg = inb(PORT_DATA);			//get the registers original state
  403426:	c7 04 24 71 00 00 00 	movl   $0x71,(%esp)
  40342d:	e8 44 00 00 00       	call   403476 <inb>
  403432:	88 45 ff             	mov    %al,0xffffffff(%ebp)
	outb(REGB_NONMI, RTC_PORT);		//when you read from this port it resets the register to D so have to set it back to B
  403435:	ba 70 00 00 00       	mov    $0x70,%edx
  40343a:	b8 8b 00 00 00       	mov    $0x8b,%eax
  40343f:	ee                   	out    %al,(%dx)
	outb((curReg|RTC_ENABLE),PORT_DATA);	//set the register with PIE set to RTC_ENABLE interrupts
  403440:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  403444:	83 c8 40             	or     $0x40,%eax
  403447:	0f b6 c0             	movzbl %al,%eax
  40344a:	ba 71 00 00 00       	mov    $0x71,%edx
  40344f:	ee                   	out    %al,(%dx)

	/*Must RTC_ENABLE the interrupt line on the PIC*/
	enable_irq(IR_LINE);
  403450:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  403457:	e8 9b e0 ff ff       	call   4014f7 <enable_irq>
	/* re-enable the slave pic's pin */
	enable_irq(2);
  40345c:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  403463:	e8 8f e0 ff ff       	call   4014f7 <enable_irq>

	/*Turn the NMI back on*/
	outb(NMI_ON, RTC_PORT);
  403468:	ba 70 00 00 00       	mov    $0x70,%edx
  40346d:	b8 7f 00 00 00       	mov    $0x7f,%eax
  403472:	ee                   	out    %al,(%dx)

	sti();
  403473:	fb                   	sti    
	// restore_flags(flags);
}
  403474:	c9                   	leave  
  403475:	c3                   	ret    

00403476 <inb>:
/* Port read functions */
/* Inb reads a byte and returns its value as a zero-extended 32-bit
 * unsigned int */
static inline uint32_t inb(port)
{
  403476:	55                   	push   %ebp
  403477:	89 e5                	mov    %esp,%ebp
  403479:	83 ec 10             	sub    $0x10,%esp
	uint32_t val;
	asm volatile("xorl %0, %0\n \
  40347c:	8b 55 08             	mov    0x8(%ebp),%edx
  40347f:	31 c0                	xor    %eax,%eax
  403481:	ec                   	in     (%dx),%al
  403482:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
			inb   (%w1), %b0"
			: "=a"(val)
			: "d"(port)
			: "memory" );
	return val;
  403485:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  403488:	c9                   	leave  
  403489:	c3                   	ret    

0040348a <rtc_handler>:

/*
* void rtc_handler(void)
*   Inputs: void
*   Return Value: void
*	Function: prints string and executes test_interrupts function when there is
*	an interrupt from the RTC
*/
void
rtc_handler(void)
{
  40348a:	55                   	push   %ebp
  40348b:	89 e5                	mov    %esp,%ebp
  40348d:	83 ec 08             	sub    $0x8,%esp
	/* DEBUG */
	rtc_interrupt_count++;
  403490:	a1 0c d0 40 00       	mov    0x40d00c,%eax
  403495:	83 c0 01             	add    $0x1,%eax
  403498:	a3 0c d0 40 00       	mov    %eax,0x40d00c
	// printf("received!\n");

	outb(REGC, RTC_PORT);
  40349d:	ba 70 00 00 00       	mov    $0x70,%edx
  4034a2:	b8 0c 00 00 00       	mov    $0xc,%eax
  4034a7:	ee                   	out    %al,(%dx)
	inb(PORT_DATA);
  4034a8:	c7 04 24 71 00 00 00 	movl   $0x71,(%esp)
  4034af:	e8 c2 ff ff ff       	call   403476 <inb>
	send_eoi(IR_LINE);
  4034b4:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  4034bb:	e8 3d e1 ff ff       	call   4015fd <send_eoi>
	rtc_interrupt_happened = 1;
  4034c0:	c7 05 08 d0 40 00 01 	movl   $0x1,0x40d008
  4034c7:	00 00 00 
}
  4034ca:	c9                   	leave  
  4034cb:	c3                   	ret    

004034cc <rtc_read>:

/*
* int32_t rtc_read (void)
*   Inputs: none
*   Return Value: int32_t (0 if success)
*	Function: returns 0 after an rtc interrupt is handled by rtc_handler
*/
int32_t
rtc_read (int32_t fd, void* buf, int32_t nbytes)
{
  4034cc:	55                   	push   %ebp
  4034cd:	89 e5                	mov    %esp,%ebp
  4034cf:	83 ec 08             	sub    $0x8,%esp
	/* DEBUG */
	printf("rtc_read: waiting for interrupt #%u...", rtc_interrupt_count);
  4034d2:	a1 0c d0 40 00       	mov    0x40d00c,%eax
  4034d7:	89 44 24 04          	mov    %eax,0x4(%esp)
  4034db:	c7 04 24 10 47 40 00 	movl   $0x404710,(%esp)
  4034e2:	e8 c6 f5 ff ff       	call   402aad <printf>

	/* set flag and wait for it to be changed by rtc_handler, then return */
	cli();
  4034e7:	fa                   	cli    
	rtc_interrupt_happened = 0;
  4034e8:	c7 05 08 d0 40 00 00 	movl   $0x0,0x40d008
  4034ef:	00 00 00 
	sti();
  4034f2:	fb                   	sti    
	while (!rtc_interrupt_happened) {}
  4034f3:	a1 08 d0 40 00       	mov    0x40d008,%eax
  4034f8:	85 c0                	test   %eax,%eax
  4034fa:	74 f7                	je     4034f3 <rtc_read+0x27>

	return 0;
  4034fc:	b8 00 00 00 00       	mov    $0x0,%eax
}
  403501:	c9                   	leave  
  403502:	c3                   	ret    

00403503 <rtc_write>:

/*
* int32_t rtc_write (int32_t freq)
*   Inputs: freq (frequency that the rtc chip will send interrupts at)
*   Return Value: int32_t (0 if success, -1 if failure)
*	Function: sets the new rtc frequency
*/
int32_t
rtc_write (int32_t fd, const void* buf, int32_t nbytes)
{
  403503:	55                   	push   %ebp
  403504:	89 e5                	mov    %esp,%ebp
  403506:	83 ec 28             	sub    $0x28,%esp
	int32_t freq = nbytes;
  403509:	8b 45 10             	mov    0x10(%ebp),%eax
  40350c:	89 45 f0             	mov    %eax,0xfffffff0(%ebp)
	/* DEBUG */
	printf("rtc_write: attempting to set rtc frequency to %u hz\n", freq);
  40350f:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  403512:	89 44 24 04          	mov    %eax,0x4(%esp)
  403516:	c7 04 24 38 47 40 00 	movl   $0x404738,(%esp)
  40351d:	e8 8b f5 ff ff       	call   402aad <printf>

	/* check if freq is a power of 2 */
	int32_t tmp = freq;
  403522:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  403525:	89 45 f4             	mov    %eax,0xfffffff4(%ebp)
	while ((tmp > 1) && (tmp % 2 == 0)) {
  403528:	eb 03                	jmp    40352d <rtc_write+0x2a>
		tmp = tmp >> 1;
  40352a:	d1 7d f4             	sarl   0xfffffff4(%ebp)
  40352d:	83 7d f4 01          	cmpl   $0x1,0xfffffff4(%ebp)
  403531:	7e 0a                	jle    40353d <rtc_write+0x3a>
  403533:	8b 45 f4             	mov    0xfffffff4(%ebp),%eax
  403536:	83 e0 01             	and    $0x1,%eax
  403539:	85 c0                	test   %eax,%eax
  40353b:	74 ed                	je     40352a <rtc_write+0x27>
	}

	if (tmp != 1) {
  40353d:	83 7d f4 01          	cmpl   $0x1,0xfffffff4(%ebp)
  403541:	74 18                	je     40355b <rtc_write+0x58>
		/* DEBUG */
		printf("rtc_write: ERROR - new frequency not a power of 2\n");
  403543:	c7 04 24 70 47 40 00 	movl   $0x404770,(%esp)
  40354a:	e8 5e f5 ff ff       	call   402aad <printf>
		return -1;
  40354f:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  403556:	e9 ef 00 00 00       	jmp    40364a <rtc_write+0x147>
	}

	/* check if freq is outside of valid range */
	if (freq > RTC_PRGM_MAX_FREQ || freq <= 0) {
  40355b:	81 7d f0 00 04 00 00 	cmpl   $0x400,0xfffffff0(%ebp)
  403562:	7f 06                	jg     40356a <rtc_write+0x67>
  403564:	83 7d f0 00          	cmpl   $0x0,0xfffffff0(%ebp)
  403568:	7f 18                	jg     403582 <rtc_write+0x7f>
		/* DEBUG */
		printf("rtc_write: ERROR - frequency power of 2 but not in valid range\n");
  40356a:	c7 04 24 a4 47 40 00 	movl   $0x4047a4,(%esp)
  403571:	e8 37 f5 ff ff       	call   402aad <printf>
		return -1;
  403576:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  40357d:	e9 c8 00 00 00       	jmp    40364a <rtc_write+0x147>
	}

	/* calculate rate based on freq */
	int32_t rate = 1;
  403582:	c7 45 f8 01 00 00 00 	movl   $0x1,0xfffffff8(%ebp)
	while ((RTC_DEFAULT_FREQ >> (rate - 1)) != freq) {
  403589:	eb 04                	jmp    40358f <rtc_write+0x8c>
		rate++;
  40358b:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  40358f:	8b 4d f8             	mov    0xfffffff8(%ebp),%ecx
  403592:	83 e9 01             	sub    $0x1,%ecx
  403595:	b8 00 80 00 00       	mov    $0x8000,%eax
  40359a:	d3 f8                	sar    %cl,%eax
  40359c:	3b 45 f0             	cmp    0xfffffff0(%ebp),%eax
  40359f:	75 ea                	jne    40358b <rtc_write+0x88>
	}

	/* is rate in the valid range, since rate must fit in 4 bytes */
	if (rate < RTC_RATE_LOW || rate > RTC_RATE_HIGH) {
  4035a1:	83 7d f8 05          	cmpl   $0x5,0xfffffff8(%ebp)
  4035a5:	7e 06                	jle    4035ad <rtc_write+0xaa>
  4035a7:	83 7d f8 0f          	cmpl   $0xf,0xfffffff8(%ebp)
  4035ab:	7e 18                	jle    4035c5 <rtc_write+0xc2>
		/* DEBUG */
		printf("rtc_write: ERROR - new rate out of range\n");
  4035ad:	c7 04 24 e4 47 40 00 	movl   $0x4047e4,(%esp)
  4035b4:	e8 f4 f4 ff ff       	call   402aad <printf>
		return -1;
  4035b9:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,0xffffffec(%ebp)
  4035c0:	e9 85 00 00 00       	jmp    40364a <rtc_write+0x147>
	}


	/* DEBUG */
	printf("rtc_write: set rtc frequency to %u hz\n", freq);
  4035c5:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  4035c8:	89 44 24 04          	mov    %eax,0x4(%esp)
  4035cc:	c7 04 24 10 48 40 00 	movl   $0x404810,(%esp)
  4035d3:	e8 d5 f4 ff ff       	call   402aad <printf>

	rtc_cur_freq = freq;
  4035d8:	8b 45 f0             	mov    0xfffffff0(%ebp),%eax
  4035db:	a3 cc d0 40 00       	mov    %eax,0x40d0cc

	/* disable all interrupts */
	cli();
  4035e0:	fa                   	cli    
	outb(REGB_NONMI, RTC_PORT);
  4035e1:	ba 70 00 00 00       	mov    $0x70,%edx
  4035e6:	b8 8b 00 00 00       	mov    $0x8b,%eax
  4035eb:	ee                   	out    %al,(%dx)

	rtc_interrupt_count = 0;
  4035ec:	c7 05 0c d0 40 00 00 	movl   $0x0,0x40d00c
  4035f3:	00 00 00 
	/* modify the A register to set the new rate */

	/* set index to REGA */
	outb(REGA, RTC_PORT);
  4035f6:	ba 70 00 00 00       	mov    $0x70,%edx
  4035fb:	b8 8a 00 00 00       	mov    $0x8a,%eax
  403600:	ee                   	out    %al,(%dx)
	/* get previous value of REGA */
	char reg_prev = inb(PORT_DATA);
  403601:	c7 04 24 71 00 00 00 	movl   $0x71,(%esp)
  403608:	e8 69 fe ff ff       	call   403476 <inb>
  40360d:	88 45 ff             	mov    %al,0xffffffff(%ebp)
	/* reset index to REGA */
	outb(REGA, RTC_PORT);
  403610:	ba 70 00 00 00       	mov    $0x70,%edx
  403615:	b8 8a 00 00 00       	mov    $0x8a,%eax
  40361a:	ee                   	out    %al,(%dx)
	/* write rate to the bottom 4 bits */
	reg_prev = (reg_prev & 0xF0) | rate;
  40361b:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  403620:	89 c2                	mov    %eax,%edx
  403622:	22 55 ff             	and    0xffffffff(%ebp),%dl
  403625:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  403628:	09 d0                	or     %edx,%eax
  40362a:	88 45 ff             	mov    %al,0xffffffff(%ebp)
	outb(reg_prev, PORT_DATA);
  40362d:	ba 71 00 00 00       	mov    $0x71,%edx
  403632:	0f b6 45 ff          	movzbl 0xffffffff(%ebp),%eax
  403636:	ee                   	out    %al,(%dx)

	/* enable all interrupts */
	outb(NMI_ON, RTC_PORT);
  403637:	ba 70 00 00 00       	mov    $0x70,%edx
  40363c:	b8 7f 00 00 00       	mov    $0x7f,%eax
  403641:	ee                   	out    %al,(%dx)
	sti();
  403642:	fb                   	sti    

	return 0;
  403643:	c7 45 ec 00 00 00 00 	movl   $0x0,0xffffffec(%ebp)
  40364a:	8b 45 ec             	mov    0xffffffec(%ebp),%eax

}
  40364d:	c9                   	leave  
  40364e:	c3                   	ret    

0040364f <rtc_open>:

/*
* int32_t rtc_open (const uint8_t * filename)
*   Inputs: filename
*   Return Value: int32_t (0 if success, -1 if failure)
*	Function: initializes the rtc
*/
int32_t
rtc_open (const uint8_t * filename)
{
  40364f:	55                   	push   %ebp
  403650:	89 e5                	mov    %esp,%ebp
  403652:	83 ec 18             	sub    $0x18,%esp
	return rtc_write(0, 0, 2);
  403655:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  40365c:	00 
  40365d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  403664:	00 
  403665:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  40366c:	e8 92 fe ff ff       	call   403503 <rtc_write>
}
  403671:	c9                   	leave  
  403672:	c3                   	ret    

00403673 <rtc_close>:

/*
* int32_t rtc_close (int32_t fd)
*   Inputs: fd, the file descriptor
*   Return Value: int32_t (0 if success, -1 if failure)
*	Function: closes the rtc
*/
int32_t
rtc_close (int32_t fd)
{
  403673:	55                   	push   %ebp
  403674:	89 e5                	mov    %esp,%ebp
	return 0;
  403676:	b8 00 00 00 00       	mov    $0x0,%eax
}
  40367b:	5d                   	pop    %ebp
  40367c:	c3                   	ret    

0040367d <rtc_wait>:

/*
* void rtc_wait (uint32_t seconds, uint32_t print)
*   Inputs: seconds: number of seconds to wait
*			print: 0 to not print the debug statement(s), 1 if yes
*   Return Value: none
*	Function: uses rtc interrupts to wait for an integer number of seconds
*/
void
rtc_wait (uint32_t seconds, uint32_t print)
{
  40367d:	55                   	push   %ebp
  40367e:	89 e5                	mov    %esp,%ebp
  403680:	83 ec 28             	sub    $0x28,%esp
	/* DEBUG */
	if (print) {
  403683:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  403687:	74 13                	je     40369c <rtc_wait+0x1f>
		printf("rtc_wait: waiting for %u seconds...\n", seconds);
  403689:	8b 45 08             	mov    0x8(%ebp),%eax
  40368c:	89 44 24 04          	mov    %eax,0x4(%esp)
  403690:	c7 04 24 38 48 40 00 	movl   $0x404838,(%esp)
  403697:	e8 11 f4 ff ff       	call   402aad <printf>
	}

	cli();
  40369c:	fa                   	cli    
	rtc_interrupt_count = 0;
  40369d:	c7 05 0c d0 40 00 00 	movl   $0x0,0x40d00c
  4036a4:	00 00 00 
	sti();
  4036a7:	fb                   	sti    
	uint32_t ticks = seconds * rtc_cur_freq;
  4036a8:	a1 cc d0 40 00       	mov    0x40d0cc,%eax
  4036ad:	89 c2                	mov    %eax,%edx
  4036af:	8b 45 08             	mov    0x8(%ebp),%eax
  4036b2:	0f af c2             	imul   %edx,%eax
  4036b5:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	while (ticks) {
  4036b8:	eb 20                	jmp    4036da <rtc_wait+0x5d>
		rtc_read(0,0,0);
  4036ba:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  4036c1:	00 
  4036c2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  4036c9:	00 
  4036ca:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  4036d1:	e8 f6 fd ff ff       	call   4034cc <rtc_read>
		ticks--;
  4036d6:	83 6d fc 01          	subl   $0x1,0xfffffffc(%ebp)
  4036da:	83 7d fc 00          	cmpl   $0x0,0xfffffffc(%ebp)
  4036de:	75 da                	jne    4036ba <rtc_wait+0x3d>
	}

}
  4036e0:	c9                   	leave  
  4036e1:	c3                   	ret    
  4036e2:	90                   	nop    
  4036e3:	90                   	nop    

004036e4 <sys_open>:
#include "lib.h"

extern pcb_t * pcb;

int32_t sys_open(const uint8_t* filename){
  4036e4:	55                   	push   %ebp
  4036e5:	89 e5                	mov    %esp,%ebp
  4036e7:	53                   	push   %ebx
  4036e8:	83 ec 64             	sub    $0x64,%esp
	int i = 2;
  4036eb:	c7 45 f8 02 00 00 00 	movl   $0x2,0xfffffff8(%ebp)
	while(pcb->file_array[i].flags & OPEN){
  4036f2:	eb 16                	jmp    40370a <sys_open+0x26>
		if (i >= MAX_OPEN_FILES - 1){
  4036f4:	83 7d f8 06          	cmpl   $0x6,0xfffffff8(%ebp)
  4036f8:	7e 0c                	jle    403706 <sys_open+0x22>
			return -1;
  4036fa:	c7 45 a4 ff ff ff ff 	movl   $0xffffffff,0xffffffa4(%ebp)
  403701:	e9 78 04 00 00       	jmp    403b7e <sys_open+0x49a>
		}
		i++;
  403706:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  40370a:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  403710:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  403713:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  40371a:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  403721:	29 d0                	sub    %edx,%eax
  403723:	01 c8                	add    %ecx,%eax
  403725:	83 c0 10             	add    $0x10,%eax
  403728:	8b 40 08             	mov    0x8(%eax),%eax
  40372b:	83 e0 10             	and    $0x10,%eax
  40372e:	85 c0                	test   %eax,%eax
  403730:	75 c2                	jne    4036f4 <sys_open+0x10>
	}

	dentry_t open_file;
	if (read_dentry_by_name(filename, &open_file) == -1)		//check if valid filename
  403732:	8d 45 b8             	lea    0xffffffb8(%ebp),%eax
  403735:	89 44 24 04          	mov    %eax,0x4(%esp)
  403739:	8b 45 08             	mov    0x8(%ebp),%eax
  40373c:	89 04 24             	mov    %eax,(%esp)
  40373f:	e8 18 d8 ff ff       	call   400f5c <read_dentry_by_name>
  403744:	83 f8 ff             	cmp    $0xffffffff,%eax
  403747:	75 0c                	jne    403755 <sys_open+0x71>
	{
		// printf("read_dentry_by_name failed!\n");
		return -1;
  403749:	c7 45 a4 ff ff ff ff 	movl   $0xffffffff,0xffffffa4(%ebp)
  403750:	e9 29 04 00 00       	jmp    403b7e <sys_open+0x49a>
	}

	if (strncmp((int8_t*)filename, (int8_t*)"terminal", 8) == 0)
  403755:	8b 45 08             	mov    0x8(%ebp),%eax
  403758:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  40375f:	00 
  403760:	c7 44 24 04 5d 48 40 	movl   $0x40485d,0x4(%esp)
  403767:	00 
  403768:	89 04 24             	mov    %eax,(%esp)
  40376b:	e8 2a f9 ff ff       	call   40309a <strncmp>
  403770:	85 c0                	test   %eax,%eax
  403772:	75 07                	jne    40377b <sys_open+0x97>
		open_file.file_type = TYPE_TERM;
  403774:	c7 45 d8 04 00 00 00 	movl   $0x4,0xffffffd8(%ebp)

	switch (open_file.file_type){			//check if it is a regular file type
  40377b:	8b 45 d8             	mov    0xffffffd8(%ebp),%eax
  40377e:	89 45 a8             	mov    %eax,0xffffffa8(%ebp)
  403781:	83 7d a8 01          	cmpl   $0x1,0xffffffa8(%ebp)
  403785:	74 2e                	je     4037b5 <sys_open+0xd1>
  403787:	83 7d a8 01          	cmpl   $0x1,0xffffffa8(%ebp)
  40378b:	7f 0f                	jg     40379c <sys_open+0xb8>
  40378d:	83 7d a8 00          	cmpl   $0x0,0xffffffa8(%ebp)
  403791:	0f 84 ff 01 00 00    	je     403996 <sys_open+0x2b2>
  403797:	e9 dc 03 00 00       	jmp    403b78 <sys_open+0x494>
  40379c:	83 7d a8 02          	cmpl   $0x2,0xffffffa8(%ebp)
  4037a0:	0f 84 00 01 00 00    	je     4038a6 <sys_open+0x1c2>
  4037a6:	83 7d a8 04          	cmpl   $0x4,0xffffffa8(%ebp)
  4037aa:	0f 84 d7 02 00 00    	je     403a87 <sys_open+0x3a3>
  4037b0:	e9 c3 03 00 00       	jmp    403b78 <sys_open+0x494>
		case TYPE_DIR:
		{
			pcb->file_array[i].fops_table.open = dir_open;
  4037b5:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  4037bb:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  4037be:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  4037c5:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  4037cc:	29 d0                	sub    %edx,%eax
  4037ce:	c7 04 08 19 13 40 00 	movl   $0x401319,(%eax,%ecx,1)
			pcb->file_array[i].fops_table.read = dir_read;
  4037d5:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  4037db:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  4037de:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  4037e5:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  4037ec:	29 d0                	sub    %edx,%eax
  4037ee:	c7 44 08 04 23 13 40 	movl   $0x401323,0x4(%eax,%ecx,1)
  4037f5:	00 
			pcb->file_array[i].fops_table.write = dir_write;
  4037f6:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  4037fc:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  4037ff:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  403806:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  40380d:	29 d0                	sub    %edx,%eax
  40380f:	c7 44 08 08 4a 14 40 	movl   $0x40144a,0x8(%eax,%ecx,1)
  403816:	00 
			pcb->file_array[i].fops_table.close = dir_close;
  403817:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  40381d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  403820:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  403827:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  40382e:	29 d0                	sub    %edx,%eax
  403830:	c7 44 08 0c 54 14 40 	movl   $0x401454,0xc(%eax,%ecx,1)
  403837:	00 
			pcb->file_array[i].inode = DIR_INODE;
  403838:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  40383e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  403841:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  403848:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  40384f:	29 d0                	sub    %edx,%eax
  403851:	01 c8                	add    %ecx,%eax
  403853:	83 c0 10             	add    $0x10,%eax
  403856:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			pcb->file_array[i].file_position = DIR_POS;
  40385c:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  403862:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  403865:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  40386c:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  403873:	29 d0                	sub    %edx,%eax
  403875:	01 c8                	add    %ecx,%eax
  403877:	83 c0 10             	add    $0x10,%eax
  40387a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
			pcb->file_array[i].flags = OPEN & TYPE_DIR;
  403881:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  403887:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  40388a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  403891:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  403898:	29 d0                	sub    %edx,%eax
  40389a:	01 c8                	add    %ecx,%eax
  40389c:	83 c0 10             	add    $0x10,%eax
  40389f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		}
		case TYPE_FILE:
		{
			pcb->file_array[i].fops_table.open = reg_file_open;
  4038a6:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  4038ac:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  4038af:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  4038b6:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  4038bd:	29 d0                	sub    %edx,%eax
  4038bf:	c7 04 08 00 12 40 00 	movl   $0x401200,(%eax,%ecx,1)
			pcb->file_array[i].fops_table.read = reg_file_read;
  4038c6:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  4038cc:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  4038cf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  4038d6:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  4038dd:	29 d0                	sub    %edx,%eax
  4038df:	c7 44 08 04 0a 12 40 	movl   $0x40120a,0x4(%eax,%ecx,1)
  4038e6:	00 
			pcb->file_array[i].fops_table.write = reg_file_write;
  4038e7:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  4038ed:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  4038f0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  4038f7:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  4038fe:	29 d0                	sub    %edx,%eax
  403900:	c7 44 08 08 05 13 40 	movl   $0x401305,0x8(%eax,%ecx,1)
  403907:	00 
			pcb->file_array[i].fops_table.close = reg_file_close;
  403908:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  40390e:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  403911:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  403918:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  40391f:	29 d0                	sub    %edx,%eax
  403921:	c7 44 08 0c 0f 13 40 	movl   $0x40130f,0xc(%eax,%ecx,1)
  403928:	00 
			pcb->file_array[i].inode = open_file.inode_num;		//update file system struct with proper values
  403929:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  40392f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  403932:	8b 5d dc             	mov    0xffffffdc(%ebp),%ebx
  403935:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  40393c:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  403943:	29 d0                	sub    %edx,%eax
  403945:	01 c8                	add    %ecx,%eax
  403947:	83 c0 10             	add    $0x10,%eax
  40394a:	89 18                	mov    %ebx,(%eax)
			pcb->file_array[i].file_position = FILE_POS;
  40394c:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  403952:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  403955:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  40395c:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  403963:	29 d0                	sub    %edx,%eax
  403965:	01 c8                	add    %ecx,%eax
  403967:	83 c0 10             	add    $0x10,%eax
  40396a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
			pcb->file_array[i].flags = OPEN & TYPE_FILE;
  403971:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  403977:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  40397a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  403981:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  403988:	29 d0                	sub    %edx,%eax
  40398a:	01 c8                	add    %ecx,%eax
  40398c:	83 c0 10             	add    $0x10,%eax
  40398f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		}
		case TYPE_RTC:
		{			
			pcb->file_array[i].fops_table.open = rtc_open;
  403996:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  40399c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  40399f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  4039a6:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  4039ad:	29 d0                	sub    %edx,%eax
  4039af:	c7 04 08 4f 36 40 00 	movl   $0x40364f,(%eax,%ecx,1)
			pcb->file_array[i].fops_table.read = rtc_read;
  4039b6:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  4039bc:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  4039bf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  4039c6:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  4039cd:	29 d0                	sub    %edx,%eax
  4039cf:	c7 44 08 04 cc 34 40 	movl   $0x4034cc,0x4(%eax,%ecx,1)
  4039d6:	00 
			pcb->file_array[i].fops_table.write = rtc_write;
  4039d7:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  4039dd:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  4039e0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  4039e7:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  4039ee:	29 d0                	sub    %edx,%eax
  4039f0:	c7 44 08 08 03 35 40 	movl   $0x403503,0x8(%eax,%ecx,1)
  4039f7:	00 
			pcb->file_array[i].fops_table.close = rtc_close;
  4039f8:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  4039fe:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  403a01:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  403a08:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  403a0f:	29 d0                	sub    %edx,%eax
  403a11:	c7 44 08 0c 73 36 40 	movl   $0x403673,0xc(%eax,%ecx,1)
  403a18:	00 
			pcb->file_array[i].inode = 0;
  403a19:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  403a1f:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  403a22:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  403a29:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  403a30:	29 d0                	sub    %edx,%eax
  403a32:	01 c8                	add    %ecx,%eax
  403a34:	83 c0 10             	add    $0x10,%eax
  403a37:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			pcb->file_array[i].file_position = 0;
  403a3d:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  403a43:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  403a46:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  403a4d:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  403a54:	29 d0                	sub    %edx,%eax
  403a56:	01 c8                	add    %ecx,%eax
  403a58:	83 c0 10             	add    $0x10,%eax
  403a5b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
			pcb->file_array[i].flags = OPEN & TYPE_RTC;
  403a62:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  403a68:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  403a6b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  403a72:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  403a79:	29 d0                	sub    %edx,%eax
  403a7b:	01 c8                	add    %ecx,%eax
  403a7d:	83 c0 10             	add    $0x10,%eax
  403a80:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		}
		case TYPE_TERM:
		{
			pcb->file_array[i].fops_table.open = tOpen;
  403a87:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  403a8d:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  403a90:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  403a97:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  403a9e:	29 d0                	sub    %edx,%eax
  403aa0:	c7 04 08 54 3f 40 00 	movl   $0x403f54,(%eax,%ecx,1)
			pcb->file_array[i].fops_table.read = tRead;
  403aa7:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  403aad:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  403ab0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  403ab7:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  403abe:	29 d0                	sub    %edx,%eax
  403ac0:	c7 44 08 04 3b 3e 40 	movl   $0x403e3b,0x4(%eax,%ecx,1)
  403ac7:	00 
			pcb->file_array[i].fops_table.write = tWrite;
  403ac8:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  403ace:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  403ad1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  403ad8:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  403adf:	29 d0                	sub    %edx,%eax
  403ae1:	c7 44 08 08 0f 3f 40 	movl   $0x403f0f,0x8(%eax,%ecx,1)
  403ae8:	00 
			pcb->file_array[i].fops_table.close = tClose;
  403ae9:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  403aef:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  403af2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  403af9:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  403b00:	29 d0                	sub    %edx,%eax
  403b02:	c7 44 08 0c 63 3f 40 	movl   $0x403f63,0xc(%eax,%ecx,1)
  403b09:	00 
			pcb->file_array[i].inode = 0;
  403b0a:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  403b10:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  403b13:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  403b1a:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  403b21:	29 d0                	sub    %edx,%eax
  403b23:	01 c8                	add    %ecx,%eax
  403b25:	83 c0 10             	add    $0x10,%eax
  403b28:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			pcb->file_array[i].file_position = 0;
  403b2e:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  403b34:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  403b37:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  403b3e:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  403b45:	29 d0                	sub    %edx,%eax
  403b47:	01 c8                	add    %ecx,%eax
  403b49:	83 c0 10             	add    $0x10,%eax
  403b4c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
			pcb->file_array[i].flags = OPEN & TYPE_TERM;
  403b53:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  403b59:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  403b5c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  403b63:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  403b6a:	29 d0                	sub    %edx,%eax
  403b6c:	01 c8                	add    %ecx,%eax
  403b6e:	83 c0 10             	add    $0x10,%eax
  403b71:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		}
	}
	return i;
  403b78:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  403b7b:	89 45 a4             	mov    %eax,0xffffffa4(%ebp)
  403b7e:	8b 45 a4             	mov    0xffffffa4(%ebp),%eax
}
  403b81:	83 c4 64             	add    $0x64,%esp
  403b84:	5b                   	pop    %ebx
  403b85:	5d                   	pop    %ebp
  403b86:	c3                   	ret    

00403b87 <sys_read>:

int32_t sys_read (int32_t fd, void* buf, int32_t nbytes){
  403b87:	55                   	push   %ebp
  403b88:	89 e5                	mov    %esp,%ebp
  403b8a:	83 ec 18             	sub    $0x18,%esp
	if (fd >= 0 && fd < 8){
  403b8d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  403b91:	78 66                	js     403bf9 <sys_read+0x72>
  403b93:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
  403b97:	7f 60                	jg     403bf9 <sys_read+0x72>
		if (pcb->file_array[fd].flags & OPEN)
  403b99:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  403b9f:	8b 45 08             	mov    0x8(%ebp),%eax
  403ba2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  403ba9:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  403bb0:	29 d0                	sub    %edx,%eax
  403bb2:	01 c8                	add    %ecx,%eax
  403bb4:	83 c0 10             	add    $0x10,%eax
  403bb7:	8b 40 08             	mov    0x8(%eax),%eax
  403bba:	83 e0 10             	and    $0x10,%eax
  403bbd:	85 c0                	test   %eax,%eax
  403bbf:	74 38                	je     403bf9 <sys_read+0x72>
		{
			return pcb->file_array[fd].fops_table.read(fd, buf, nbytes);
  403bc1:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  403bc7:	8b 45 08             	mov    0x8(%ebp),%eax
  403bca:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  403bd1:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  403bd8:	29 d0                	sub    %edx,%eax
  403bda:	8b 54 08 04          	mov    0x4(%eax,%ecx,1),%edx
  403bde:	8b 45 10             	mov    0x10(%ebp),%eax
  403be1:	89 44 24 08          	mov    %eax,0x8(%esp)
  403be5:	8b 45 0c             	mov    0xc(%ebp),%eax
  403be8:	89 44 24 04          	mov    %eax,0x4(%esp)
  403bec:	8b 45 08             	mov    0x8(%ebp),%eax
  403bef:	89 04 24             	mov    %eax,(%esp)
  403bf2:	ff d2                	call   *%edx
  403bf4:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  403bf7:	eb 07                	jmp    403c00 <sys_read+0x79>
		}
	}
	return -1;
  403bf9:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,0xfffffffc(%ebp)
  403c00:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  403c03:	c9                   	leave  
  403c04:	c3                   	ret    

00403c05 <sys_write>:

int32_t sys_write (int32_t fd, const void* buf, int32_t nbytes){
  403c05:	55                   	push   %ebp
  403c06:	89 e5                	mov    %esp,%ebp
  403c08:	83 ec 18             	sub    $0x18,%esp
	if (fd >= 0 && fd < 8){
  403c0b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  403c0f:	78 66                	js     403c77 <sys_write+0x72>
  403c11:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
  403c15:	7f 60                	jg     403c77 <sys_write+0x72>
		if (pcb->file_array[fd].flags & OPEN)
  403c17:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  403c1d:	8b 45 08             	mov    0x8(%ebp),%eax
  403c20:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  403c27:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  403c2e:	29 d0                	sub    %edx,%eax
  403c30:	01 c8                	add    %ecx,%eax
  403c32:	83 c0 10             	add    $0x10,%eax
  403c35:	8b 40 08             	mov    0x8(%eax),%eax
  403c38:	83 e0 10             	and    $0x10,%eax
  403c3b:	85 c0                	test   %eax,%eax
  403c3d:	74 38                	je     403c77 <sys_write+0x72>
		{
			return pcb->file_array[fd].fops_table.write(fd, buf, nbytes);
  403c3f:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  403c45:	8b 45 08             	mov    0x8(%ebp),%eax
  403c48:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  403c4f:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  403c56:	29 d0                	sub    %edx,%eax
  403c58:	8b 54 08 08          	mov    0x8(%eax,%ecx,1),%edx
  403c5c:	8b 45 10             	mov    0x10(%ebp),%eax
  403c5f:	89 44 24 08          	mov    %eax,0x8(%esp)
  403c63:	8b 45 0c             	mov    0xc(%ebp),%eax
  403c66:	89 44 24 04          	mov    %eax,0x4(%esp)
  403c6a:	8b 45 08             	mov    0x8(%ebp),%eax
  403c6d:	89 04 24             	mov    %eax,(%esp)
  403c70:	ff d2                	call   *%edx
  403c72:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  403c75:	eb 07                	jmp    403c7e <sys_write+0x79>
		}
	}
	return -1;
  403c77:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,0xfffffffc(%ebp)
  403c7e:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  403c81:	c9                   	leave  
  403c82:	c3                   	ret    

00403c83 <sys_close>:

int32_t sys_close (int32_t fd){
  403c83:	55                   	push   %ebp
  403c84:	89 e5                	mov    %esp,%ebp
  403c86:	83 ec 08             	sub    $0x8,%esp
	if (fd >= 2 && fd < 8){
  403c89:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
  403c8d:	7e 7d                	jle    403d0c <sys_close+0x89>
  403c8f:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
  403c93:	7f 77                	jg     403d0c <sys_close+0x89>
		if (pcb->file_array[fd].flags & OPEN)
  403c95:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  403c9b:	8b 45 08             	mov    0x8(%ebp),%eax
  403c9e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  403ca5:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  403cac:	29 d0                	sub    %edx,%eax
  403cae:	01 c8                	add    %ecx,%eax
  403cb0:	83 c0 10             	add    $0x10,%eax
  403cb3:	8b 40 08             	mov    0x8(%eax),%eax
  403cb6:	83 e0 10             	and    $0x10,%eax
  403cb9:	85 c0                	test   %eax,%eax
  403cbb:	74 4f                	je     403d0c <sys_close+0x89>
		{
			pcb->file_array[fd].flags = CLOSE;
  403cbd:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  403cc3:	8b 45 08             	mov    0x8(%ebp),%eax
  403cc6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  403ccd:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  403cd4:	29 d0                	sub    %edx,%eax
  403cd6:	01 c8                	add    %ecx,%eax
  403cd8:	83 c0 10             	add    $0x10,%eax
  403cdb:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
			return pcb->file_array[fd].fops_table.close(fd);
  403ce2:	8b 0d c0 d0 40 00    	mov    0x40d0c0,%ecx
  403ce8:	8b 45 08             	mov    0x8(%ebp),%eax
  403ceb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  403cf2:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
  403cf9:	29 d0                	sub    %edx,%eax
  403cfb:	8b 54 08 0c          	mov    0xc(%eax,%ecx,1),%edx
  403cff:	8b 45 08             	mov    0x8(%ebp),%eax
  403d02:	89 04 24             	mov    %eax,(%esp)
  403d05:	ff d2                	call   *%edx
  403d07:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
  403d0a:	eb 07                	jmp    403d13 <sys_close+0x90>
		}
	}
	return -1;
  403d0c:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,0xfffffffc(%ebp)
  403d13:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  403d16:	c9                   	leave  
  403d17:	c3                   	ret    

00403d18 <tScroll>:
//	static int finished = 1;

void
tScroll(void)
{
  403d18:	55                   	push   %ebp
  403d19:	89 e5                	mov    %esp,%ebp
  403d1b:	83 ec 10             	sub    $0x10,%esp
	int i;
	for(i = 0; i < (NUM_ROWS-1)*NUM_COLS; i++){
  403d1e:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  403d25:	eb 41                	jmp    403d68 <tScroll+0x50>
		*(uint8_t *)(video_mem + (i << 1)) = *(uint8_t *)(video_mem + ((i + NUM_COLS) << 1));
  403d27:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  403d2a:	01 c0                	add    %eax,%eax
  403d2c:	89 c2                	mov    %eax,%edx
  403d2e:	a1 08 51 40 00       	mov    0x405108,%eax
  403d33:	8d 04 02             	lea    (%edx,%eax,1),%eax
  403d36:	89 c1                	mov    %eax,%ecx
  403d38:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  403d3b:	83 c0 50             	add    $0x50,%eax
  403d3e:	01 c0                	add    %eax,%eax
  403d40:	89 c2                	mov    %eax,%edx
  403d42:	a1 08 51 40 00       	mov    0x405108,%eax
  403d47:	8d 04 02             	lea    (%edx,%eax,1),%eax
  403d4a:	0f b6 00             	movzbl (%eax),%eax
  403d4d:	88 01                	mov    %al,(%ecx)
	    *(uint8_t *)(video_mem + (i << 1) + 1) = ATTRIB;
  403d4f:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  403d52:	01 c0                	add    %eax,%eax
  403d54:	89 c2                	mov    %eax,%edx
  403d56:	a1 08 51 40 00       	mov    0x405108,%eax
  403d5b:	8d 04 02             	lea    (%edx,%eax,1),%eax
  403d5e:	83 c0 01             	add    $0x1,%eax
  403d61:	c6 00 07             	movb   $0x7,(%eax)
  403d64:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  403d68:	81 7d fc 7f 07 00 00 	cmpl   $0x77f,0xfffffffc(%ebp)
  403d6f:	7e b6                	jle    403d27 <tScroll+0xf>
	}
	for(i=(NUM_ROWS-1)*NUM_COLS; i<NUM_ROWS*NUM_COLS; i++){
  403d71:	c7 45 fc 80 07 00 00 	movl   $0x780,0xfffffffc(%ebp)
  403d78:	eb 2b                	jmp    403da5 <tScroll+0x8d>
		*(uint8_t *)(video_mem + (i << 1)) = ' ';
  403d7a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  403d7d:	01 c0                	add    %eax,%eax
  403d7f:	89 c2                	mov    %eax,%edx
  403d81:	a1 08 51 40 00       	mov    0x405108,%eax
  403d86:	8d 04 02             	lea    (%edx,%eax,1),%eax
  403d89:	c6 00 20             	movb   $0x20,(%eax)
	    *(uint8_t *)(video_mem + (i << 1) + 1) = ATTRIB;
  403d8c:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  403d8f:	01 c0                	add    %eax,%eax
  403d91:	89 c2                	mov    %eax,%edx
  403d93:	a1 08 51 40 00       	mov    0x405108,%eax
  403d98:	8d 04 02             	lea    (%edx,%eax,1),%eax
  403d9b:	83 c0 01             	add    $0x1,%eax
  403d9e:	c6 00 07             	movb   $0x7,(%eax)
  403da1:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  403da5:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,0xfffffffc(%ebp)
  403dac:	7e cc                	jle    403d7a <tScroll+0x62>
	}
}
  403dae:	c9                   	leave  
  403daf:	c3                   	ret    

00403db0 <insert>:

void
insert(uint8_t letter)
{
  403db0:	55                   	push   %ebp
  403db1:	89 e5                	mov    %esp,%ebp
  403db3:	83 ec 04             	sub    $0x4,%esp
  403db6:	8b 45 08             	mov    0x8(%ebp),%eax
  403db9:	88 45 fc             	mov    %al,0xfffffffc(%ebp)
	if(idx>127) return;
  403dbc:	a1 20 d0 40 00       	mov    0x40d020,%eax
  403dc1:	83 f8 7f             	cmp    $0x7f,%eax
  403dc4:	7f 1d                	jg     403de3 <insert+0x33>
	tbuf[idx] = letter;
  403dc6:	8b 15 20 d0 40 00    	mov    0x40d020,%edx
  403dcc:	0f b6 45 fc          	movzbl 0xfffffffc(%ebp),%eax
  403dd0:	88 82 40 d0 40 00    	mov    %al,0x40d040(%edx)
	idx++;
  403dd6:	a1 20 d0 40 00       	mov    0x40d020,%eax
  403ddb:	83 c0 01             	add    $0x1,%eax
  403dde:	a3 20 d0 40 00       	mov    %eax,0x40d020
}
  403de3:	c9                   	leave  
  403de4:	c3                   	ret    

00403de5 <clearbuf>:

void
clearbuf(void)
{
  403de5:	55                   	push   %ebp
  403de6:	89 e5                	mov    %esp,%ebp
  403de8:	83 ec 10             	sub    $0x10,%esp
	int i;
	for(i=0; i<BUFSIZE; i++){
  403deb:	c7 45 fc 00 00 00 00 	movl   $0x0,0xfffffffc(%ebp)
  403df2:	eb 0e                	jmp    403e02 <clearbuf+0x1d>
		tbuf[i] = 0;
  403df4:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
  403df7:	c6 80 40 d0 40 00 00 	movb   $0x0,0x40d040(%eax)
  403dfe:	83 45 fc 01          	addl   $0x1,0xfffffffc(%ebp)
  403e02:	83 7d fc 7f          	cmpl   $0x7f,0xfffffffc(%ebp)
  403e06:	7e ec                	jle    403df4 <clearbuf+0xf>
	}
	idx = 0;
  403e08:	c7 05 20 d0 40 00 00 	movl   $0x0,0x40d020
  403e0f:	00 00 00 
}
  403e12:	c9                   	leave  
  403e13:	c3                   	ret    

00403e14 <backspacebuf>:

void
backspacebuf(void) {
  403e14:	55                   	push   %ebp
  403e15:	89 e5                	mov    %esp,%ebp
	tbuf[idx] = 0;
  403e17:	a1 20 d0 40 00       	mov    0x40d020,%eax
  403e1c:	c6 80 40 d0 40 00 00 	movb   $0x0,0x40d040(%eax)
	if(idx > 0) idx--;
  403e23:	a1 20 d0 40 00       	mov    0x40d020,%eax
  403e28:	85 c0                	test   %eax,%eax
  403e2a:	7e 0d                	jle    403e39 <backspacebuf+0x25>
  403e2c:	a1 20 d0 40 00       	mov    0x40d020,%eax
  403e31:	83 e8 01             	sub    $0x1,%eax
  403e34:	a3 20 d0 40 00       	mov    %eax,0x40d020
}
  403e39:	5d                   	pop    %ebp
  403e3a:	c3                   	ret    

00403e3b <tRead>:

int32_t
tRead(int32_t fd, void* buf, int32_t nbytes)
{
  403e3b:	55                   	push   %ebp
  403e3c:	89 e5                	mov    %esp,%ebp
  403e3e:	83 ec 28             	sub    $0x28,%esp
	/*if(!finished){
		int i;
		if((tmpidx-(nbytes*startcopy))<nbytes){
			for(i=nbytes*startcopy; i<tmpidx; i++){
				buf[i] = tbuf[i];
			}
			finished = 0x01;
			startcopy = 0;
			return tmpidx-(nbytes*startcopy);
		}
		else{
			for(i=nbytes*startcopy; i<(nbytes*startcopy)+nbytes; i++){
				buf[i] = tbuf[i];
			}
			startcopy++;
			return nbytes;
		}
	}
	else{*/
		clearbuf();
  403e41:	e8 9f ff ff ff       	call   403de5 <clearbuf>
		uint8_t scancode;
		while(idx<BUFSIZE){
  403e46:	eb 13                	jmp    403e5b <tRead+0x20>
			if(tbuf[idx-1]=='\n') break;
  403e48:	a1 20 d0 40 00       	mov    0x40d020,%eax
  403e4d:	83 e8 01             	sub    $0x1,%eax
  403e50:	0f b6 80 40 d0 40 00 	movzbl 0x40d040(%eax),%eax
  403e57:	3c 0a                	cmp    $0xa,%al
  403e59:	74 0a                	je     403e65 <tRead+0x2a>
  403e5b:	a1 20 d0 40 00       	mov    0x40d020,%eax
  403e60:	83 f8 7f             	cmp    $0x7f,%eax
  403e63:	7e e3                	jle    403e48 <tRead+0xd>
		}
		cli();
  403e65:	fa                   	cli    
		while(idx>=BUFSIZE){
  403e66:	eb 28                	jmp    403e90 <tRead+0x55>
			while(!(inb(KB_STAT)&MAKE)){
  403e68:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
  403e6f:	e8 87 00 00 00       	call   403efb <inb>
  403e74:	83 e0 01             	and    $0x1,%eax
  403e77:	85 c0                	test   %eax,%eax
  403e79:	74 ed                	je     403e68 <tRead+0x2d>
			}
			scancode = inb(KB_PORT);
  403e7b:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  403e82:	e8 74 00 00 00       	call   403efb <inb>
  403e87:	88 45 ff             	mov    %al,0xffffffff(%ebp)
			if(scancode==0x1C) break;
  403e8a:	80 7d ff 1c          	cmpb   $0x1c,0xffffffff(%ebp)
  403e8e:	74 0a                	je     403e9a <tRead+0x5f>
  403e90:	a1 20 d0 40 00       	mov    0x40d020,%eax
  403e95:	83 f8 7f             	cmp    $0x7f,%eax
  403e98:	7f ce                	jg     403e68 <tRead+0x2d>
		}
		if(nbytes<=idx){
  403e9a:	a1 20 d0 40 00       	mov    0x40d020,%eax
  403e9f:	39 45 10             	cmp    %eax,0x10(%ebp)
  403ea2:	7f 28                	jg     403ecc <tRead+0x91>
			strncpy(buf, tbuf, nbytes);
  403ea4:	8b 45 10             	mov    0x10(%ebp),%eax
  403ea7:	8b 55 0c             	mov    0xc(%ebp),%edx
  403eaa:	89 44 24 08          	mov    %eax,0x8(%esp)
  403eae:	c7 44 24 04 40 d0 40 	movl   $0x40d040,0x4(%esp)
  403eb5:	00 
  403eb6:	89 14 24             	mov    %edx,(%esp)
  403eb9:	e8 88 f2 ff ff       	call   403146 <strncpy>
			clearbuf();
  403ebe:	e8 22 ff ff ff       	call   403de5 <clearbuf>
			//startcopy++;
			//finished = 0x00;
			//tmpidx = idx;
			sti();
  403ec3:	fb                   	sti    
			return nbytes;
  403ec4:	8b 45 10             	mov    0x10(%ebp),%eax
  403ec7:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  403eca:	eb 2a                	jmp    403ef6 <tRead+0xbb>
		}
		else{
			strncpy(buf, tbuf,idx);
  403ecc:	a1 20 d0 40 00       	mov    0x40d020,%eax
  403ed1:	8b 55 0c             	mov    0xc(%ebp),%edx
  403ed4:	89 44 24 08          	mov    %eax,0x8(%esp)
  403ed8:	c7 44 24 04 40 d0 40 	movl   $0x40d040,0x4(%esp)
  403edf:	00 
  403ee0:	89 14 24             	mov    %edx,(%esp)
  403ee3:	e8 5e f2 ff ff       	call   403146 <strncpy>
			clearbuf();
  403ee8:	e8 f8 fe ff ff       	call   403de5 <clearbuf>
			//startcopy = 0;
			//finished = 0x01;
			sti();
  403eed:	fb                   	sti    
			return idx;
  403eee:	a1 20 d0 40 00       	mov    0x40d020,%eax
  403ef3:	89 45 ec             	mov    %eax,0xffffffec(%ebp)
  403ef6:	8b 45 ec             	mov    0xffffffec(%ebp),%eax
		}
		clearbuf();
		sti();
		return -1;
}
  403ef9:	c9                   	leave  
  403efa:	c3                   	ret    

00403efb <inb>:
/* Port read functions */
/* Inb reads a byte and returns its value as a zero-extended 32-bit
 * unsigned int */
static inline uint32_t inb(port)
{
  403efb:	55                   	push   %ebp
  403efc:	89 e5                	mov    %esp,%ebp
  403efe:	83 ec 10             	sub    $0x10,%esp
	uint32_t val;
	asm volatile("xorl %0, %0\n \
  403f01:	8b 55 08             	mov    0x8(%ebp),%edx
  403f04:	31 c0                	xor    %eax,%eax
  403f06:	ec                   	in     (%dx),%al
  403f07:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
			inb   (%w1), %b0"
			: "=a"(val)
			: "d"(port)
			: "memory" );
	return val;
  403f0a:	8b 45 fc             	mov    0xfffffffc(%ebp),%eax
}
  403f0d:	c9                   	leave  
  403f0e:	c3                   	ret    

00403f0f <tWrite>:


/*
* int32_t tWrite (int32_t fd, const void* buf, int32_t nbytes)
*   Inputs: fd -- File descriptor of file to write to. (Terminal)
*			buf -- Data to write to the terminal.
*			nbytes -- Number of bytes to write to the terminal.
*   Return Value: int32_t (number of bytes written)
*	Function: Writes nbytes from the buf to the terminal.
*/
int32_t
tWrite (int32_t fd, const void* buf, int32_t nbytes)
{
  403f0f:	55                   	push   %ebp
  403f10:	89 e5                	mov    %esp,%ebp
  403f12:	83 ec 18             	sub    $0x18,%esp
	int i;
	uint8_t * buf_ptr = (uint8_t*)buf;
  403f15:	8b 45 0c             	mov    0xc(%ebp),%eax
  403f18:	89 45 fc             	mov    %eax,0xfffffffc(%ebp)
	for(i = 0; i < nbytes; i++)
  403f1b:	c7 45 f8 00 00 00 00 	movl   $0x0,0xfffffff8(%ebp)
  403f22:	eb 20                	jmp    403f44 <tWrite+0x35>
	{
		printf("%c", buf_ptr[i]);
  403f24:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  403f27:	03 45 fc             	add    0xfffffffc(%ebp),%eax
  403f2a:	0f b6 00             	movzbl (%eax),%eax
  403f2d:	0f b6 c0             	movzbl %al,%eax
  403f30:	89 44 24 04          	mov    %eax,0x4(%esp)
  403f34:	c7 04 24 66 48 40 00 	movl   $0x404866,(%esp)
  403f3b:	e8 6d eb ff ff       	call   402aad <printf>
  403f40:	83 45 f8 01          	addl   $0x1,0xfffffff8(%ebp)
  403f44:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  403f47:	3b 45 10             	cmp    0x10(%ebp),%eax
  403f4a:	7c d8                	jl     403f24 <tWrite+0x15>
	}
	return (i+1);
  403f4c:	8b 45 f8             	mov    0xfffffff8(%ebp),%eax
  403f4f:	83 c0 01             	add    $0x1,%eax
}
  403f52:	c9                   	leave  
  403f53:	c3                   	ret    

00403f54 <tOpen>:

/*
* int32_t tOpen(const uint8_t* filename)
*   Inputs: filename -- File to open. (Terminal)
*   Return Value: int32_t (0 if success, -1 if failure)
*	Function: Opens the terminal by settting up the variables used by terminal.
*/
int32_t
tOpen(const uint8_t* filename)
{
  403f54:	55                   	push   %ebp
  403f55:	89 e5                	mov    %esp,%ebp
	clearbuf();
  403f57:	e8 89 fe ff ff       	call   403de5 <clearbuf>
	return 0;
  403f5c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  403f61:	5d                   	pop    %ebp
  403f62:	c3                   	ret    

00403f63 <tClose>:

/*
* int32_t tClose(int32_t fd)
*   Inputs: fd -- File descriptor of file to close.
*   Return Value: int32_t (0 if success, -1 if failure)
*	Function: Closes the terminal in the PCB array and makes it available.
*/
int32_t
tClose(int32_t fd)
{	
  403f63:	55                   	push   %ebp
  403f64:	89 e5                	mov    %esp,%ebp
	return 0;
  403f66:	b8 00 00 00 00       	mov    $0x0,%eax
}
  403f6b:	5d                   	pop    %ebp
  403f6c:	c3                   	ret    
